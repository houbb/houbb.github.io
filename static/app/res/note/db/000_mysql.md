# 索引

1、WHERE字句的查询条件里有不等于号（WHERE column!=...），MYSQL将无法使用索引

2、类似地，如果WHERE字句的查询条件里使用了函数（如：WHERE DAY(column)=...），MYSQL将无法使用索引

3、在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了
 索引也不会使用
 
4、如果WHERE子句的查询条件里使用了比较操作符LIKE和REGEXP，MYSQL只有在搜索模板的第一个字符不是通配符的情况下才能
使用索引。比如说，如果查询条件是LIKE 'abc%',MYSQL将使用索引；如果条件是LIKE '%abc'，MYSQL将不使用索引。

5、在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查
询里，即使有索引可用，那些索引在加快ORDER BY操作方面也没什么作用。

6、如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是
些诸如“0/1”或“Y/N”等值，就没有必要为它创建一个索引。
 
7、索引有用的情况下就太多了。基本只要建立了索引，除了上面提到的索引不会使用的情况下之外，其他情况只要是使用在
WHERE条件里，ORDER BY 字段，联表字段，一般都是有效的。 建立索引要的就是有效果。 不然还用它干吗？ 如果不能确定在
某个字段上建立的索引是否有效果，只要实际进行测试下比较下执行时间就知道。



# 表拆分

## 水平切分

## 垂直切分

将一个较大的表，将不同的属性拆分到不同的表。从而降低 单表的大小：

1) 每张表结构都不同
2) 被拆分的表之间属性有一个共同的交集，一般是UK
3) 表的并集是全部数据


> 拆分依据

1) 较短、访问较高的 放在主表
2) 较长、访问较低的 放在次表
3) 经常一起访问的数据


------------------------------------------------------------------------------------------------------------------------

> 为什么这样拆分？

1. 数据库有自己的内存BUFFER
2. 内存BUFFER 缓存以  ROW 为单位
3. 固定内存下 缓存数量与 每一行内存大小成反比
4. 访问高的 可以提高缓存命中率




# 表增加一列

> version+ext

每次修改版本号即可。不同版本可以同时存在。













# Sharding(分片)



# 主从复制  负载均衡 读写分离

