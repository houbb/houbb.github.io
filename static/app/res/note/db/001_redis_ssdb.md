# redis

> Redis 速度为什么这么快？

Redis 单线程-多路复用io模型

Redis为什么这么快，Redis的那些特性能够支持了它的高并发？
之前的我，也只是知道Redis是内存数据库，所以读取速度快；
IO使用的是多路复用，使用一个线程来轮询描述符，减少了线程上下文的切换，将数据库的开、关、读、写都转化成了时间，
所以IO时也有加速。虽然理解上就是这些（当然还有一些数据结构的原因，全程使用hash结构，加速读写)

Redis的高并发和快速原因很多，总结一下几点：

1. Redis是纯内存数据库，一般都是简单的存取操作，线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快。

2. 再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，
减少了线程切换时上下文的切换和竞争。

3. Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争(单线程，竞争个毛线==！)。

4. 另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，
如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。



TAG:COMMENT(谈谈NIO)    参见JDK7


> Redis简介
 
redis是Nosql数据库中使用较为广泛的非关系型内存数据库，redis内部是一个key-value存储系统。
它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型，类似于Java中的map）。
Redis基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一，也被人们称为数据结构服务器。 

2、 互联网时代背景下大机遇，什么要使用Nosql？ 
1） 当数据量的总大小一个机器放不下时。 
2） 数据索引一个机器的内存放不下时。 
3） 访问量（读写混合）一个实例放不下时。

单机时代模型 
如果每次存储成千上万条数据，这样很会导致MySQL的性能很差，存储以及读取速度很慢，然后就演变成缓存+MySQL+垂直拆分的方式。 

Cache作为中间缓存 
将所有的数据先保存到缓存中，然后再存入mysql中，减小数据库压力，提高效率。 
但是当数据再次增加到又一个量级，上面的方式也不能满足需求，由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。 
这里写图片描述
主从分离模式 
在redis的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。 


分表分库模式 
将变化小的、业务相关的放在一个数据库，变化多的，不相关的数据放在一个数据库。 

3、 nosql数据库的优势 

1）易扩展 

这些类型的数据存储不需要固定的模式，无需多余的操作就可以进行横向的扩展。相对于关系型数据库可以减少表和字段特别多的情况。
也无型之间在架构的层面上带来了可扩展的能力 

2）大数据量提高性能 

3）多样灵活的数据模型 

在nosql中不仅可以存储String，hash，set、Zset等数据类型，还可以保存javaBean以及多种复杂的数据类型。 

4、 NoSql 的应用 

1） 大数据时代淘宝、微信、以及微博等都广泛的使用了redis数据库，将一些固定不变的数据例如学校，区域等固定的信息保存在关系型数据库中。
然后对于经常变化的数据例如淘宝每个节日都会有比较热门的搜索显示在搜索框，当节日过去关键字自动删除，为了便于管理，可以将这些数据保存在redis数据库中，
并设置过期时间，到达时间就自动删除。 
2）为了缓解数据库压力，微博首先将发送的微博保存到redis数据库，自己可以立即查看到，然后将内存中的数据同步到关系型数据库。



## aop 

要求可以分析实现的原理。

## 分布式锁

要求可以分析实现的原理。



## 神奇的问题

- redis KV最大限度是多少？

1) V 最大为 512M

2) K 为 String.hashCode() 最大只是循环而已。



------------------------------------------------------------------------------------------------------------------------

# ssdb



## 是什么？

一个高性能的支持丰富数据结构的 NoSQL 数据库, 用于替代 Redis.

- 替代 Redis 数据库, Redis 的 100 倍容量
- LevelDB 网络支持, 使用 C/C++ 开发
- Redis API 兼容, 支持 Redis 客户端
- 适合存储集合数据, 如 list, hash, zset...
- 客户端 API 支持的语言包括: C++, PHP, Python, Java, Go
- 持久化的队列服务
- 主从复制, 负载均衡

## 怎么用

## 横向比较？

## 扩展？ 心德


简单说明下优缺点。












------------------------------------------------------------------------------------------------------------------------

LevelDB

## 是什么？


------------------------------------------------------------------------------------------------------------------------

# Memcached

要 Memcached 还是要 Redis?


两者相似之处

1) 它们都从属于数据管理解决方案中的NoSQL家族，而且都基于同样的键值数据模型。
2) 上手简单

Memcached与Redis都属于内存内、键值数据存储方案。
它们都从属于数据管理解决方案中的NoSQL家族，而且都基于同样的键值数据模型。
双方都选择将全部数据保存在内存当中，这自然也就让它们成为非常理想的缓冲层实现方案。
从性能表现的角度来看，两类数据存储机制也具备诸多共通性，包括拥有几乎相同的特征(与指标)表现、而且高度关注工作负载的数据吞吐量与延迟状况。


除了同为内存内键值数据存储方案，Memcached与Redis还都是相当成熟而且极具人气的开源项目。
Memcached最初是由Brad Fitzpatrick于2003年开发而成，当时其直接服务对象为LiveJournal交友网站。
在此之后，Memcached被重新用C语言进行了编写(其最初实现方式为Perl语言)且投身于公共领域，并在这里逐步发展为现代Web应用程序的构建基石。
Memcached项目的当前开发工作主要关注其运行稳定性及优化效果方面，而不再积极为其打造更多新型功能。


Redis则由Salvatore Sanfilippo于2009年创建，而且时至今日Sanfilippo仍然担任着该项目的首席开发者以及惟一维护者的角色。
Redis有时候会被人们称为“强化版的Memcached”。考虑到从Memcached身上吸取并借鉴到大量宝贵的经验教训，这样的评价其实并不令人意外。
Redis在功能多样性方面要胜过Memcached，这虽然让者更为强大也更具灵活性、但其复杂程度也较后者为甚。

作为两套被众多企业采纳并部署在无数关键性生产任务环境当中的解决方案，Memcached与Redis在任何一种可行性编程语言领域都拥有能够提供支持的客户端库，
而且二者也被包含在开发人员们使用的多种库及软件包之内。事实上，现在我们甚至已经很难找到一套不包含Memcached或者Redis内置支持机制的Web堆栈。

Memcached与Redis为什么如此受人拥戴?

除了二者卓越的实际效果之外，双方各自极为简便的上手难度也是又一大加分项。无论是Memcached还是Redis，
其使用便捷性在开发人员当中都可谓广为人知。只需要几分钟我们就能完成安装工作，并让它们开始与应用程序顺畅协作。
换句话来说，只需投入一小部分时间与精力，大家就能获得立竿见影且效果极佳的性能表现提升——具体而言，性能将直接步入新的量级。
面对如此简单而又能够带来巨大收益的解决方案，又有谁能抗拒得了它们的诱惑呢?

> 何时应该使用Memcached

1) 小型静态数据进行缓存处理(只支持String)

相对Memcached而言，Redis的面世时间更晚且具备更多功能，因此开发人员通常将其视为默认性首选方案。不过有两类特殊场景仍然是Memcached的一家天下。
首先就是对小型静态数据进行缓存处理，最具代表性的例子就是HTML代码片段。

Memcached的内部内存管理机制虽然不像Redis的那样复杂，
但却更具实际效率——这是因为Memcached在处理元数据时所消耗的内存资源相对更少。
作为Memcached所支持的惟一一种数据类型，
字符串非常适合用于保存那些只需要进行读取操作的数据，因为字符串本身无需进行进一步处理。

除此之外，Memcached在横向扩展方面也比Redis更具优势。由于其在设计上的思路倾向以及相对更为简单的功能设置，
Memcached在实现扩展时的难度比Redis低得多。不过根据我们了解到的情况，目前已经有多种经过测试且切实有效的方案能够将Redis扩展至多台服务器之上，
而其即将发布的3.0版本(感兴趣的朋友可以点击此处查看其候选版本说明)将包含专门针对横向扩展场景的内置集群化机制。

> 何时应该使用Redis

除非大家需要考虑某种限定性条件(例如处理传统应用程序)对于Memcached的特殊依赖性，或者自己的实际用例属于前面提到的两类场景中的一种，
否则请直接选择Redis并加以运用。凭借着Redis所带来的卓越缓存方案，我们将拥有强大的处理能力——例如对缓存内容及持久性进行细节调整的能力——
以及出色的整体执行效率。
Redis几乎在缓存管理工作中的每一个侧面都表现出显而易见的优越性。这套缓存方案采用所谓数据回收机制，
能够将陈旧数据从内存中删除以提供新数据所必需的缓存空间。Memcached的数据回收机制使用的是LRU(即最低近期使用量)算法，而且往往会比较武断地直接删除掉与新数据体系相近的原有内容。相比之下，Redis允许用户更为精准地进行细化控制，利用六种不同回收策略确切提高缓存资源的实际利用率。Redis还采用更为复杂的内存管理与回收对象备选方案。
Redis还能为我们带来最大程度的灵活性空间，从而保证管理员在打理缓存对象时拥有充裕的施展平台。在这方面，Memcached将键名限制在250字节，值也被限制在不超过1MB，且只适用于普通字符串。相比之下，Redis则将键名与值的最大上限各自设定为512MB，且支持二进制格式。Redis支持六种数据类型，因此能够更加智能地对数据进行缓存处理及操作，这相当于为应用程序开发人员敞开了一道通往无尽可能性的大门。
相对于将对象保存为序列化字符串，Redis允许开发人员以散列方式将对象域及值加以保存，并利用单一键对其进行管理。Redis散列机制的存在保证开发人员无需经历获取完整字符串、反序列化、更新值、对象重新序列化并在每次值更新后利用其替代缓存内完整字符串这一系列复杂的流程——这也意味着资源消耗量得以降低、性能表现迎来显著提升。Redis所支持的其它数据类型，例如Lists以及Sets——也可被用于实现更加复杂的缓存管理模式。
Redis的另一大重要优势在于，它所保存的数据具备透明化特性，也就是说服务器能够直接对这些数据进行操作。Redis当中提供160多种可用命令，其中大部分用于实现数据处理操作并通过服务器端脚本将逻辑嵌入至数据存储体系当中。这些内置命令及用户脚本带来了极大的灵活性优势，足以帮助大家直接在Redis内部完成数据处理任务——而不必将数据在网络中的其它专门处理系统之间来回移动。
Redis还提供可选而且能够具体调整的数据持久性方案，其设计目的在于在发生规划内停机或者计划外故障之后对缓存内容进行重新引导。虽然我们更倾向于强调缓存内数据的易失性与暂时性，但将数据在磁盘中加以持久保存在某些缓存场景当中仍然极具现实意义。这种机制能够在设备重启之后快速将保存在磁盘上的数据重新载入至缓存当中，从而大大缩短缓存预热周期并根据主数据存储内容对当前缓存内容进行重新评估。
最后但也同样重要的一点是，Redis能够提供复制功能。复制功能旨在帮助缓存体系实现高可用性配置方案，从而在遭遇故障的情况下继续为应用程序提供不间断的缓存服务。很明显，一套成熟的缓存方案应该能够在应用程序发生故障时略微甚至完全不给用户体验或者应用程序性能表现带来任何影响，而这种对缓存内容及服务可用性的有力保障在大多数情况下也成为缓存解决方案的一大主要优势。

