# goto

java 中的保留字,现在没有在 java 中使用。

# native

1) java调用非java代码的接口

2) 不可与 abstract 同时使用。


> 什么是Native Method

简单地讲，一个Native Method就是一个java调用**非java代码**的接口。

一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。
这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern "C"告知C＋＋编译器去调用一个C的函数。
"A native method is a Java method whose implementation is provided by non-java code."
在定义一个native method时，并**不提供实现体**（有些像定义一个java interface），因为其实现体是由非java语言在外面实现的。


标识符native可以与所有其它的java标识符连用，但是abstract除外。这是合理的，因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，
但是abstract却显然的指明这些方法无实现体。native与其它java标识符连用时，其意义同非Native Method并无差别。

一个native method方法可以返回任何java类型，包括非基本类型，而且同样可以进行异常控制。这些方法的实现体可以自制一个异常并且将其抛出，这一点与java的方法非常相似。
native method的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。

如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法（这个似乎看起来有些奇怪），同样的如果一个本地方法被fianl标识，它被继承后不能被重写。
本地方法非常有用，因为它有效地扩充了jvm.事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。
有了本地方法，java程序可以做任何应用层次的任务。


> 为什么要使用Native Method

1) 追求效率时候

2) 使用 java 本身没有封装的属性时候



java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。

与java环境外交互：
有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。
本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。

与操作系统交互：
JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。
然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。
通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。

Sun's Java
Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。
例如：类java.lang.Thread 的 setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority0()。
这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。
这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。


> JVM怎样使Native Method跑起来：

我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会回载一次。
在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。
如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。
当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。
当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的。

最后需要提示的是，使用本地方法是有开销的，它丧失了java的很多好处。如果别无选择，我们可以选择使用本地方法。


可以将native方法比作Java程序同Ｃ程序的接口，其实现步骤：
１、在Java中声明native()方法，然后编译；
２、用javah产生一个.h文件；
３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；
４、将第三步的.cpp文件编译成动态链接库文件；
５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。



# synchronized

并发时会提到这个关键字。(原理锁住的是 代码的内存块) 可以参见《程序员修炼手册》进行整理。

当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。

一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。

三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。

四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。

五、以上规则对其它对象锁同样适用.

...TBC



# volatile

1)  保证修改的可见性, 但是原子性需要自己保证。  仔细梳理下 concurrentHashMap 同样的原理。

2) 不存在线程阻塞, 是 sychronized 更轻量级的 同步机制。

并发时也会提及到这个字段。


http://www.cnblogs.com/zhengbin/p/5654805.html


先补充一下概念：Java并发中的可见性与原子性

> 可见性：

　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，
    有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。

　　可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。
    比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。
    但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；
    这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。

> 原子性：

　　原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。
再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。
非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。
一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。


为什么不是原子性??


i++并非原子操作。执行过程中JVM从内存中把变量i的值取出来放到寄存器中，在寄存器中做加1操作，之后把寄存器中的值在写入到内存中。

(这些涉及到 堆栈寄存器)




问题：
两个线程同时对i=0的数据分别进行i++一百次，结果出来并不是200。理论上来讲，结果最小值为2，最大值为200。
首先解释一下为什么会这样。
i++并非原子操作。执行过程中JVM从内存中把变量i的值取出来放到寄存器中，在寄存器中做加1操作，之后把寄存器中的值在写入到内存中。
值为2的情况：
线程A：从内存中读到i值为0，在寄存器中加1，还没有写入内存时线程B开始执行。
线程B：从内存中读到i值依然为0，线程B执行99次i++，这时候写入内存，此时内存中i=99，还没开始第100次读取内存中i的值，线程A开始执行。
线程A：把寄存器中的1写入到内存，此时内存中i=1，还没有开始第二次读取内存中i的值时，线程B开始执行。
线程B：把寄存器中的i=1读入到寄存器，进行加1操作，此时寄存器中值为2，还没有写入到内存中时，线程A开始执行。
线程A：把内存中的i=1读入到寄存器中加1然后写入内存，执行99次后，内存中的i=100，此时线程A执行完毕。线程B开始执行。
线程B：把寄存器中的i=2写入到内存中，线程B结束。
此时内存中的i=2。
值为200的情况：
线程完成从内存中读取到寄存器运算后写入内存这一个完整步骤。
其余情况类似。









Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。
当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。
volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。



当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。

　　而声明变量是volatile的，JVM保证了每次读变量都从内存中读，跳过CPU cache这一步。

　　当一个变量定义为volatile之后，将具备两种特性：

1.保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，新值对于其他线程是立即得知的。
但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。

2.禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），
只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。
当对非volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache中。

                                                                                                                                                                                    　　





