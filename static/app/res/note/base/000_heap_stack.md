# 何为寄存器

最快的存储区
数量极其有限
不可直接控制

> i++ 为何不是原子性？

i-》寄存器-》加操作-》内存

可能 未刷入内存之前其他线程开始读取内存。



# 何为栈

指针移动，分配空间。速度仅次于寄存器
为了指针的移动，必须知道堆栈内项确切的生命周期，限制了灵活性。

1) 8大基本数据类型，对象的引用存在这里




# 何为堆

无需知道存储数据的存活时间。new对象时，自动在堆中开辟空间。
分配清理数据的时间要长于堆栈
存放所有Java对象

> int[] arr = {1,2,3}; 

隐式 new 创建，存放在堆中。


# 静态域

常量值通常直接存储在程序代码内部

1) static 定义的成员变量



# 常量池

1) 字符串常量

2) public static final + 基本类型常量


# 非 RAM (硬盘等)  

数据可完全独立于程序而存在
流对象和可持久化对象

## 文件

## db

===================================================

栈 数据大小/生命周期 可以确定。无引用指向数据，数据就会消失。

堆 不确定。 GC 回收。

> what is gc?

TAG:TODO

1) 有向图 管理  HEAP



GC（GarbageCollection）是垃圾回收机制，GC是JVM对内存（实际上就是对象）进行管理的方式。
GC使得Java开发人员摆脱了繁琐的内存管理工作，让程序的开发更有效率。



对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。
通常，GC采用有向图的方式记录和管理堆（heap）中的所有对象（详见 参考资料1 ）。

通过这种方式确定哪些对象是\"可达的\"，哪些对象是\"不可达的\".
当GC确定一些对象为\"不可达\"时，GC就有责任回收这些内存空间。
但是，为了保证GC能够在不同平台实现的问题，Java规范对GC的很多行为都没有进行严格的规定。

例如，对于采用什么类型的回收算法、什么时候进行回收等重要问题都没有明确的规定。因此，不同的JVM的实现者往往有不同的实现算法。
这也给Java程序员的开发带来行多不确定性。本文研究了几个与GC工作相关的问题，努力减少这种不确定性给Java程序带来的负面影响。




#  JAVA 语言如何进行异常处理,关键字:throws,throw,try,catch,finally 分 别代表什么意义?在 try 块中可以抛出异常吗?

throws 捕获并向外抛出异常
throw 抛出异常
try catch 是内部捕获异常并做自定义处理
finally 是无论是否有异常都会被处理的语句,除非在 finally 前存在被执行的 System.exit(int i)时除外













> String

TAG:TODO

编译期已定义好(通过""直接定义)，则存放在常量池。

运行期(new)才可确定的存放在堆中。equals() 的 String，常量池中【只有一份】， 堆中多份。
 
- new String("XXX"); 详细过程

1. create string XXX, 常量池中是否有？没有，则放入其中。

2. 在堆中放一个此常量的copy




  







