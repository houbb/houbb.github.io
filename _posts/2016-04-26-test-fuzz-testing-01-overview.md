---
layout: post
title:  test fuzz-01-模糊测试（Fuzz Testing）入门 Atheris、Jazzer、jqf、kelinci、FLA、libfuzzer 对比 
date:  2016-04-26 14:10:52 +0800
categories: [Test]
tags: [java, test]
published: true
---

# 拓展阅读

[开源 Auto generate mock data for java test.(便于 Java 测试自动生成对象信息)](https://github.com/houbb/data-factory)

[开源 Junit performance rely on junit5 and jdk8+.(java 性能测试框架。性能测试。压测。测试报告生成。)](https://github.com/houbb/junitperf)

[test fuzz-01-模糊测试（Fuzz Testing）](https://houbb.github.io/2016/04/26/test-fuzz-testing-01-overview)

[test fuzz-02-模糊测试 JQF + Zest Semantic Fuzzing for Java](https://houbb.github.io/2016/04/26/test-fuzz-testing-02-jqf-intro)

[test fuzz-03-模糊测试 Atheris A Coverage-Guided, Native Python Fuzzer](https://houbb.github.io/2016/04/26/test-fuzz-testing-03-atheris-intro)

[test fuzz-04-模糊测试 jazzer Coverage-guided, in-process fuzzing for the JVM](https://houbb.github.io/2016/04/26/test-fuzz-testing-04-jazzer-intro)

[test fuzz-05-模糊测试 kelinci AFL-based fuzzing for Java](https://houbb.github.io/2016/04/26/test-fuzz-testing-05-kelinci-intro)

[test fuzz-06-模糊测试 AFL american fuzzy lop - a security-oriented fuzzer](https://houbb.github.io/2016/04/26/test-fuzz-testing-06-AFL)

[test fuzz-07-模糊测试 libfuzzer](https://houbb.github.io/2016/04/26/test-fuzz-testing-07-libfuzzer)

# chat

## 详细介绍一下 模糊测试（Fuzz Testing）

模糊测试（Fuzz Testing）是一种自动化的测试方法，通过向程序、应用程序或系统输入注入大量随机或半随机生成的数据（模糊输入），以寻找潜在的安全漏洞、软件缺陷或异常行为。

模糊测试的目标是通过在输入中引入未知、异常或非预期的数据，评估目标系统的鲁棒性和稳定性。

以下是模糊测试的一般流程和关键概念：

### 模糊测试流程：

1. **选择目标：**
   - 确定要进行模糊测试的目标，可以是一个应用程序、库、协议等。选择目标通常基于其重要性、复杂性和潜在的攻击面。

2. **生成模糊输入：**
   - 创建模糊测试工具或使用现有工具生成模糊输入。模糊输入通常是通过对有效输入进行随机修改、添加或删除而生成的。

3. **注入模糊输入：**
   - 将生成的模糊输入注入到目标系统中。这可以通过直接发送网络请求、修改文件、通过标准输入等方式进行。

4. **监测异常行为：**
   - 监测目标系统的行为，包括崩溃、错误消息、异常响应等。模糊测试工具通常会监测程序的执行状态，以检测到任何不正常的行为。

5. **收集反馈：**
   - 收集模糊测试过程中观察到的异常行为。这可能包括崩溃日志、错误报告、程序输出等。

6. **优化模糊输入生成：**
   - 根据反馈信息，调整模糊输入生成策略，以生成更有针对性的模糊输入，提高发现漏洞的效率。

7. **迭代：**
   - 重复模糊测试过程，不断优化生成的模糊输入，直到达到预期的测试目标或发现了潜在的问题。

### 模糊测试关键概念：

1. **模糊输入生成：**
   - 模糊测试工具需要能够生成有效且具有随机性的输入。这可能包括修改二进制数据、字符串、文件格式等。

2. **输入覆盖率：**
   - 模糊测试的有效性与其输入覆盖率直接相关。通过不断改进生成输入的策略，以覆盖尽可能多的代码路径。

3. **反馈机制：**
   - 及时获取目标系统的反馈信息至关重要。当发现异常行为时，模糊测试工具需要能够收集详细的信息以帮助分析问题。

4. **黑盒和白盒模糊测试：**
   - 黑盒模糊测试只使用目标系统的输入输出接口信息，而白盒模糊测试可能借助目标系统的内部信息，如源代码、符号表等。

5. **冷启动和热启动：**
   - 冷启动是指在每次测试前重新初始化目标系统，而热启动是指保持系统状态，以更接近实际使用情况。

模糊测试是一种强大的自动化测试方法，广泛用于发现软件中的安全漏洞和软件缺陷。它可以应用于不同层次的软件栈，包括应用程序、协议栈、文件格式等。

## java 有哪些模糊测试的开源组件？

请注意，软件生态系统不断发展，可能会有新的工具出现，因此建议查阅最新的资料以获取最新信息。

1. **JQF (Java QuickCheck Fuzzing):** JQF 是一个基于QuickCheck思想的模糊测试工具，可用于Java。它提供了一种基于属性的测试方法，能够自动生成随机输入来检测代码中的错误。

   GitHub链接: [https://github.com/rohanpadhye/jqf](https://github.com/rohanpadhye/jqf)

2. **Atheris:** Atheris 是一个Python的Fuzzing库，但它具有对Java的支持。它通过使用Java Native Interface（JNI）来调用Java代码，并通过Atheris库进行模糊测试。

   GitHub链接: [https://github.com/google/atheris](https://github.com/google/atheris)

3. **jazzer:** Coverage-guided, in-process fuzzing for the JVM

   GitHub链接: [https://github.com/CodeIntelligenceTesting/jazzer](https://github.com/CodeIntelligenceTesting/jazzer)

4. https://github.com/isstac/kelinci AFL-based fuzzing for Java

请注意，使用模糊测试工具需要谨慎，因为它们可能会导致不稳定的行为，并在生产环境中使用时可能会引入潜在的问题。在使用这些工具之前，请详细了解其文档，以确保正确配置和使用。

## 详细对比一下 Atheris、Jazzer、jqf、kelinci、FLA、libfuzzer，给出对比表格

下面是对Atheris、Jazzer、jqf、Kelinci、FLA、libFuzzer的对比表格：

| 功能/特性         | Atheris            | Jazzer              | jqf                 | Kelinci             | FLA                 | libFuzzer           |
|-------------------|---------------------|---------------------|---------------------|---------------------|---------------------|---------------------|
| 语言              | Python              | Java                | Java                | Java                | C                   | C++                 |
| 支持的目标程序类型 | Python              | Java                | Java                | Java                | C                   | C/C++               |
| 指导性模糊测试    | ✔️                  | ✔️                  | ✔️                  | ✖️                  | ✔️                  | ✔️                  |
| 静态分析          | ✖️                  | ✖️                  | ✖️                  | ✖️                  | ✔️                  | ✖️                  |
| 动态二进制插桩    | ✖️                  | ✔️                  | ✖️                  | ✔️                  | ✔️                  | ✔️                  |
| 支持的反馈机制    | 覆盖率              | 覆盖率              | 覆盖率              | 路径导向            | 覆盖率              | 覆盖率              |
| 支持的变异策略    | 多种                | 多种                | 多种                | 多种                | 多种                | 多种                |
| 最小化工具        | 自带                | ✔️                  | ✔️                  | 依赖Kelinci Minimizer | FLA Minimizer      | ✔️                  |
| 支持并行化        | ✖️                  | ✔️                  | ✖️                  | ✔️                  | ✔️                  | ✖️                  |
| 支持网络服务      | ✖️                  | ✔️                  | ✔️                  | ✔️                  | ✖️                  | ✖️                  |
| 是否开源          | ✔️                  | ✔️                  | ✔️                  | ✔️                  | ✔️                  | ✔️                  |

请注意，表格中的“✔️”表示支持，而“✖️”表示不支持。这只是一个简要的对比，实际选择取决于项目需求、编程语言偏好、目标程序类型等因素。

## java 模糊测试组件的实现原理是什么？

Java模糊测试组件的实现原理通常涉及以下关键步骤和概念：

1. **输入生成：**
   - 模糊测试的核心是生成具有随机性或半随机性的输入数据。在Java模糊测试中，这可以包括创建随机字符串、随机数、随机对象序列等。

2. **输入注入：**
   - 生成的随机输入需要被注入到目标Java应用程序中。这可能涉及到模拟用户输入、发送随机数据包、修改文件内容等方式。

3. **反馈收集：**
   - 模糊测试工具需要监测目标Java应用程序的执行，以收集反馈信息。这可能包括记录程序崩溃、异常堆栈跟踪、错误日志等。

4. **输入覆盖率：**
   - 为了提高测试的效果，模糊测试通常需要关注输入覆盖率，即生成的输入能够覆盖目标程序中的尽可能多的代码路径。这可以通过调整输入生成策略来实现。

5. **持久化状态：**
   - 为了模拟实际使用情况，模糊测试工具可能需要考虑保持目标Java应用程序的状态。这可以通过持久化一些状态信息，以实现冷启动和热启动等测试模式。

6. **异常处理：**
   - 模糊测试过程中可能会触发目标Java应用程序的异常，包括但不限于崩溃、内存错误等。模糊测试工具需要能够捕获和处理这些异常，以便进一步分析和测试。

7. **优化策略：**
   - 为了提高发现漏洞的效率，模糊测试工具可能会根据先前的测试结果优化输入生成策略。这可能涉及到一些智能算法，以更有针对性地生成输入。

8. **并发测试：**
   - 对于涉及并发和多线程的Java应用程序，模糊测试工具可能需要考虑并发输入生成和执行，以覆盖更多的执行路径。

请注意，具体的实现原理可能因不同的模糊测试工具而异。以上列举的步骤和概念是通用的，但具体实现可能依赖于工具的设计目标、测试范围以及模糊测试引擎的内部实现。


## 输入生成这一部分，组件如何保障数据生成的尽可能可以覆盖边界等情况的？

确保输入生成尽可能覆盖边界情况是模糊测试的关键之一，因为这有助于发现程序中可能存在的边界问题、边界条件错误以及潜在的漏洞。

以下是一些常见的技术和策略，模糊测试组件可以采用来保障生成的数据具有较好的覆盖性：

1. **边界值分析：**
   - 在输入生成阶段，模糊测试组件可以使用边界值分析来确定输入数据的边界。对于数值型输入，考虑在边界附近生成数据，例如最小值、最大值、中间值、边界值的加减偏移等。这确保了测试用例覆盖了输入范围的边界情况。

2. **随机性和变异性：**
   - 引入随机性和变异性是模糊测试的核心。在输入生成时，使用随机生成的数据，包括随机字符串、随机整数、随机对象等，以覆盖可能的不同情况。通过变异输入，可以生成类似但略有不同的输入，从而扩大测试范围。

3. **输入种子：**
   - 提供一组种子输入，其中包含了各种可能的边界情况和特殊情况。模糊测试工具可以基于这些种子输入进行变异和扩展，确保覆盖性更加广泛。

4. **模型驱动的生成：**
   - 基于目标应用程序的模型，设计和生成输入数据。这可以包括理解应用程序的输入要求、协议规范、文件格式等，然后生成符合这些规范的随机输入。

5. **符号执行和约束求解：**
   - 使用符号执行引擎和约束求解器，对输入进行符号执行，以发现更多的路径和输入组合。这有助于生成更具有针对性的输入，覆盖更多可能的执行路径。

6. **自适应优化：**
   - 根据测试的反馈结果，动态地调整输入生成策略。例如，根据先前的测试结果，调整生成输入的规则，以便更集中地测试先前发现的问题或未覆盖的执行路径。

7. **组合输入：**
   - 对于接受多个输入的系统，组合输入以测试系统在多个输入交互方面的鲁棒性。这有助于发现不同输入组合可能导致的问题。

通过结合上述技术和策略，模糊测试组件可以更好地确保生成的数据具有广泛的覆盖性，有效地挖掘潜在的边界问题和漏洞。

# 参考资料

* any list
{:toc}