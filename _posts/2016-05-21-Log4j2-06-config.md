---
layout: post
title: Log4j2-06-Configuration 配置
date:  2016-5-21 10:00:13 +0800
categories: [Log]
tags: [log, apache, log4j2]
published: true
---

# 配置

将日志请求插入到应用程序代码中需要进行大量的计划和工作。

观察表明，大约4%的代码专门用于日志记录。因此，即使是中等规模的应用程序也会在其代码中嵌入数千条日志记录语句。

考虑到它们的数量，必须管理这些日志语句，而不需要手动修改它们。

Log4j 2的配置可以通过以下四种方式之一完成:

- 通过用XML、JSON、YAML或属性格式编写的配置文件。

- 通过编程方式，创建一个ConfigurationFactory和Configuration实现。

- 通过编程方式，调用Configuration接口中公开的api，将组件添加到默认配置中。

- 以编程方式，通过调用内部Logger类上的方法。

本页主要关注通过配置文件配置Log4j。关于以编程方式配置Log4j的信息可以在扩展Log4j 2和程序化Log4j配置中找到。

所有可用的格式在功能上都是相同的。

例如，可以使用属性格式重写XML中的配置文件(反之亦然)，而不会损失任何功能。

但是，使用自然支持嵌套的格式可以更好地捕获Log4j配置的层次结构特性，因此XML、JSON和YAML文件通常更易于使用。

注意，这与Log4j 1不同。因此，公共Log4j 2 API不公开添加、修改或删除追加程序和过滤器的方法，也不公开以任何方式操纵配置的方法。

# 配置架构 Configuration Architecture

部分原因是首先添加了对XML的支持，所以Log4j的配置反映为树结构。

实际上，每种配置方言(包括ConfigurationBuilder)都会为每个配置元素生成一个Node。

节点是一个相当简单的结构，它包含一组属性、一组子节点和一个PluginType。

重要的是要注意，每个节点都必须有一个相应的插件，因为插件是实际执行节点所代表的工作的组件。

Log4j支持的每种文档类型都有一个ConfigurationFactory。工厂本身是一个Log4j插件，声明它支持的文件扩展名及其优先级。

属性的优先级最高，值为8，其次是yaml、json和xml。当执行自动配置时，Log4j将调用这些工厂中的每一个，以确定哪个(如果有的话)支持指定的配置文件格式。

如果找到一个，工厂将创建相应的Configuration对象，并将对配置数据的引用传递给它。

每个配置实现(如XMLConfiguration、YamlConfiguration、JsonConfiguration等)的主要任务都是将配置文本转换为Node树，通常是使用可用于该文档类型的任何工具解析文本。

应该注意的是，虽然大多数支持的文档类型本质上是树结构的，但Java属性语法不是。由于需要将语法转换为Node树，因此Log4j使用的Java属性语法要求所有属性遵循使树结构清晰的命名模式。

因此，Java Properties格式往往比使用其他文档类型更冗长。

创建了Node树后，将控制委托给AbstractConfiguration，后者使用Log4j的Plugin系统将节点转换为各自的Java对象，并提供所有公共功能。

# 仲裁者 Arbiters

在某些情况下，希望有一个可以在任何部署环境中使用的日志配置。

例如，可能需要在生产中使用与开发中不同的默认日志级别。另一种情况可能是本机运行时使用一种类型的appender，而部署到docker容器时使用另一种类型的appender。

处理这个问题的一种方法是使用Spring Cloud Config Server之类的工具，它可以感知环境，并为每个环境提供不同的文件。另一种选择是在配置中包含Arbiters。

Arbiters 仲裁者是一个Log4j插件，它的工作是确定是否应该在生成的配置中包含其他已配置的元素。

虽然所有其他“核心”插件都被设计为作为Log4j运行时逻辑的一部分执行，但Arbiters在Node树构建之后执行，但在树转换为配置之前执行。

仲裁者是一个节点本身，它总是在处理节点树之前从节点树中删除。

**仲裁器所做的只是提供一个方法，该方法返回一个布尔值结果，该结果确定仲裁器的子节点是应该保留在配置中还是应该被修剪**。

仲裁器可以出现在配置中允许元素的任何地方。

因此，仲裁者可以封装像单个属性声明或一整套appeners或logger一样简单的东西。仲裁者也可以嵌套，但是作为另一个仲裁者后代的仲裁者只有在祖先返回true时才会被评估。仲裁器的子元素必须是任何作为仲裁器父元素的有效元素。

这个例子显示了配置的两个仲裁器，根据env System属性的值是“dev”还是“prod”，它们将包括控制台Appender或列表Appender。

```xml
<Configuration name="ConfigTest" status="ERROR" monitorInterval="5">
  <Appenders>
 
    <SystemPropertyArbiter propertyName="env" propertyValue="dev">
      <Console name="Out">
        <PatternLayout pattern="%m%n"/>
      </Console>
    </SystemPropertyArbiter>
    <SystemPropertyArbiter propertyName="env" propertyValue="prod">
      <List name="Out">
      </List>
    </SystemPropertyArbiter>
 
  </Appenders>
  <Loggers>
    <Logger name="org.apache.test" level="trace" additivity="false">
      <AppenderRef ref="Out"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Out"/>
    </Root>
  </Loggers>
</Configuration>
```

通常情况下，仲裁者是独立于其他仲裁者的。

也就是说，一个仲裁者的结果不会影响任何其他仲裁者。

当您只想使用一组选项中的一个时，这可能会很麻烦。

在这种情况下，可以使用一个名为“Select”的特殊插件。

Select下的每个元素都必须是仲裁者。第一个返回真值的仲裁者将被使用，而其他仲裁者将被忽略。如果没有Arbiter返回true，则可以使用默认配置元素配置DefaultArbiter。

DefaultArbiter是一个总是返回true的仲裁者，所以在Select之外使用它会导致它的配置元素总是被包含，就好像它不存在一样。

这个例子展示了一个仲裁者，它使用驻留在单独文件中的Javascript来确定是否包含控制台Appender。如果结果为false，则会包含一个List Appender。

```xml
<Configuration name="ConfigTest" status="ERROR" monitorInterval="5">
  <Appenders>
    <Select>
      <ScriptArbiter>
        <ScriptFile language="JavaScript" path="src/test/resources/scripts/prodtest.js" charset="UTF-8" />
        <Console name="Out">
          <PatternLayout pattern="%m%n"/>
        </Console>
      </ScriptArbiter>
      <DefaultArbiter>
        <List name="Out">
        </List>
      </DefaultArbiter>
    </Select>
  </Appenders>
  <Loggers>
    <Logger name="org.apache.test" level="trace" additivity="false">
      <AppenderRef ref="Out"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Out"/>
    </Root>
  </Loggers>
</Configuration>
```

原生Log4j包含SystemProperty仲裁者，它可以根据SystemProperty是否为非空或具有特定值来评估是否包含元素，一个ClassArbiter根据指定的类是否存在做出决定，以及一个ScriptArbiter根据配置它的脚本的结果做出决定。

对于Spring Boot用户，提供了一个名为SpringProfile的仲裁器。指定的概要文件由Spring的 `Environment.acceptsProfiles()` 方法评估，因此它支持的任何表达式都可以用作name属性。

当Spring配置文件为“dev”或“staging”时，这个例子将使用控制台Appender，当活动配置文件为“prod”时，这个例子将使用列表Appender。

```xml
<Configuration name="ConfigTest" status="ERROR" monitorInterval="5">
  <Appenders>
 
    <SpringProfile name="dev | staging">
      <Console name="Out">
        <PatternLayout pattern="%m%n"/>
      </Console>
    </SpringProfile>
    <SpringProfile name="prod">
      <List name="Out">
      </List>
    </SpringProfile>
 
  </Appenders>
  <Loggers>
    <Logger name="org.apache.test" level="trace" additivity="false">
      <AppenderRef ref="Out"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Out"/>
    </Root>
  </Loggers>
</Configuration>
```

# 自动配置 Automatic Configuration

Log4j能够在初始化期间自动配置自身。当Log4j启动时，它将找到所有的ConfigurationFactory插件，并按照从高到低的加权顺序排列它们。

在交付时，Log4j包含四个ConfigurationFactory实现:一个用于JSON，一个用于YAML，一个用于属性，一个用于XML。

- Log4j将检查“log4j2”。如果设置了，将尝试使用与文件扩展名匹配的ConfigurationFactory加载配置。注意，这并不局限于本地文件系统上的某个位置，它可能包含一个URL。

- 如果没有设置系统属性，那么propertiesconfigurationfactory将查找log4j2-test。类路径中的属性。

- 如果没有找到这样的文件，YAML ConfigurationFactory将查找log4j2-test。Yaml或log4j2-test。类路径中的Yml。

- 如果没有找到这样的文件，JSON ConfigurationFactory将查找log4j2-test。Json或log4j2-test。类路径中的JSN。

- 如果没有找到这样的文件，XML ConfigurationFactory将在类路径中查找log4j2-test.xml。

- 如果无法找到测试文件，那么ConfigurationFactory将查找log4j2。类路径上的属性。

- 如果无法找到属性文件，YAML ConfigurationFactory将查找log4j2。Yaml或log4j2。类路径上的Yml。

- 如果无法找到YAML文件，则JSON ConfigurationFactory将查找log4j2。Json或log4j2。类路径上的JSN。

- 如果无法找到JSON文件，XML ConfigurationFactory将尝试在类路径上找到log4j2.xml。

- 如果找不到配置文件，则使用DefaultConfiguration。这将导致日志记录输出到控制台。

一个名为MyApp的使用log4j的示例应用程序可以用来说明如何做到这一点。

```java
import com.foo.Bar;
 
// Import log4j classes.
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
 
public class MyApp {
 
    // Define a static logger variable so that it references the
    // Logger instance named "MyApp".
    private static final Logger logger = LogManager.getLogger(MyApp.class);
 
    public static void main(final String... args) {
 
        // Set up a simple configuration that logs on the console.
 
        logger.trace("Entering application.");
        Bar bar = new Bar();
        if (!bar.doIt()) {
            logger.error("Didn't do it.");
        }
        logger.trace("Exiting application.");
    }
}
```

MyApp首先导入log4j相关的类。然后，它定义了一个名为MyApp的静态记录器变量，该变量恰好是类的完全限定名。

MyApp使用在 `com.foo.Bar` 中定义的Bar类。

```java
package com.foo;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
 
public class Bar {
  static final Logger logger = LogManager.getLogger(Bar.class.getName());
 
  public boolean doIt() {
    logger.entry();
    logger.error("Did it again!");
    return logger.exit(false);
  }
}
```

如果无法找到配置文件，Log4j将提供默认配置。DefaultConfiguration类中提供的默认配置将设置:

一个连接到根记录器的ConsoleAppender。

将PatternLayout设置为模式 ` "%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n" ` 附加到控制台appender

注意，默认情况下，Log4j将根记录器分配给Level.ERROR。

MyApp的输出类似于:

```
17:13:01.540 [main] ERROR com.foo.Bar - Did it again!
17:13:01.540 [main] ERROR MyApp - Didn't do it.
```

如前所述，Log4j将首先尝试从配置文件配置自身。

相当于默认值的配置如下所示:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Root level="error">
      <AppenderRef ref="Console"/>
    </Root>
  </Loggers>
</Configuration>
```

将上面的文件作为log4j2.xml放入类路径后，您将得到与上面列出的结果相同的结果。将根级别更改为trace将导致类似于以下结果:

```
17:13:01.540 [main] TRACE MyApp - Entering application.
17:13:01.540 [main] TRACE com.foo.Bar - entry
17:13:01.540 [main] ERROR com.foo.Bar - Did it again!
17:13:01.540 [main] TRACE com.foo.Bar - exit with (false)
17:13:01.540 [main] ERROR MyApp - Didn't do it.
17:13:01.540 [main] TRACE MyApp - Exiting application.
```

注意，使用默认配置时禁用状态日志记录。

# 来自URI的配置

当log4j2。configurationFile引用URL, Log4j将首先确定URL是否使用文件协议引用文件。

如果是这样，Log4j将验证文件URL是否有效，并按照前面描述的继续处理。

如果它包含一个协议而不是文件，那么Log4j将检查log4j2.Configuration的值。

allowedProtocols系统属性。如果提供的列表包含指定的协议，那么Log4j将使用URI来定位指定的配置文件。

否则将抛出异常并记录错误消息。如果没有为system属性提供值，它将默认为“https, file, jar”。

可以通过将系统属性值设置为“_none”来阻止使用除“file”之外的任何协议。此值将是一个无效的协议，因此不能与可能存在的任何自定义协议冲突。

Log4j支持访问需要身份验证的远程url。Log4j支持开箱即用的基本身份验证。如果“log4j2.Configuration. conf”用户名和log4j2.Configuration。

指定密码，这些值将用于执行身份验证。如果密码是加密的，可以通过在log4j2.Configuration中指定完全限定类名来提供自定义密码解密器。

password解密系统属性。可以通过设置log4j2.Configuration来使用自定义AuthenticationProvider。

authenticationProvider系统属性设置为提供程序的完全限定类名。

# 可加性 Additivity

也许需要从com.foo.Bar之外的所有内容中消除所有TRACE输出。

仅仅更改日志级别是无法完成任务的。

相反，解决方案是在配置中添加一个新的记录器定义:

```xml
<Logger name="com.foo.Bar" level="TRACE"/>
<Root level="ERROR">
  <AppenderRef ref="STDOUT">
</Root>
```

使用此配置，将记录来自com.foo.Bar的所有日志事件，而只记录来自所有其他组件的错误事件。

在前面的示例中，来自com.foo.Bar的所有事件仍然被写入控制台。这是因为com.foo.Bar的记录器没有配置任何appender，而它的父记录器配置了。

实际上，下面的配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Logger name="com.foo.Bar" level="trace">
      <AppenderRef ref="Console"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Console"/>
    </Root>
  </Loggers>
</Configuration>
```

结果如下：

```
17:13:01.540 [main] TRACE com.foo.Bar - entry
17:13:01.540 [main] TRACE com.foo.Bar - entry
17:13:01.540 [main] ERROR com.foo.Bar - Did it again!
17:13:01.540 [main] TRACE com.foo.Bar - exit (false)
17:13:01.540 [main] TRACE com.foo.Bar - exit (false)
17:13:01.540 [main] ERROR MyApp - Didn't do it.
```

注意，来自 `com.foo.Bar` 的跟踪消息出现了两次。

这是因为首先使用与logger `com.foo.Bar` 关联的appender，它将第一个实例写入控制台。

接下来， `com.foo.Bar` 的父类，在本例中是根记录器，被引用。

然后将事件传递给其附加程序，该附加程序也写入控制台，从而产生第二个实例。

这被称为可加性。虽然加法可以是一个非常方便的功能(如在前面的第一个示例中，不需要配置appender引用)，但在许多情况下，这种行为被认为是不可取的，因此可以通过将日志记录器上的additivity属性设置为false来禁用它:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Logger name="com.foo.Bar" level="trace" additivity="false">
      <AppenderRef ref="Console"/>
    </Logger>
    <Root level="error">
      <AppenderRef ref="Console"/>
    </Root>
  </Loggers>
</Configuration>
```

一旦事件到达将其相加性设置为false的记录器，该事件将不会传递给它的任何父记录器，无论它们的相加性设置如何。

# 自动重新配置 Automatic Reconfiguration

当从文件配置时，Log4j能够自动检测对配置文件的更改并重新配置自身。

如果在配置元素上指定了monitorInterval属性并将其设置为非零值，那么在下一次评估和/或记录日志事件时将检查该文件，并且自上次检查以来已经过了monitorInterval。

下面的示例显示了如何配置属性，以便在至少30秒之后才检查配置文件是否有更改。

最小间隔为5秒。

当从文件配置时，Log4j能够自动检测对配置文件的更改并重新配置自身。

如果在配置元素上指定了monitorInterval属性并将其设置为非零值，那么在下一次评估和/或记录日志事件时将检查该文件，并且自上次检查以来已经过了monitorInterval。

下面的示例显示了如何配置属性，以便在至少30秒之后才检查配置文件是否有更改。最小间隔为5秒。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration monitorInterval="30">
...
</Configuration>
```

# Chainsaw可以自动处理您的日志文件(发布appender配置)

Log4j提供了为所有基于文件的追加器以及基于套接字的追加器“发布”追加器配置细节的能力。例如，对于基于文件的appender，文件中的文件位置和模式布局包含在广告中。Chainsaw和其他外部系统可以发现这些广告，并使用这些信息智能地处理日志文件。

广告公开的机制以及广告格式是特定于每个Advertiser实现的。想要与特定的广告人实现工作的外部系统必须了解如何定位广告配置以及广告的格式。例如，一个'database' Advertiser可能在一个数据库表中存储配置细节。外部系统可以读取该数据库表，以便发现文件位置和文件格式。

Log4j提供了一个Advertiser实现，一个'multicastdns' Advertiser，它使用JmDNS库通过IP多播发布appender配置细节。

Chainsaw自动发现log4j的multicastdns生成的广告，并在Chainsaw的Zeroconf选项卡中显示这些发现的广告(如果jmdns库在Chainsaw的类路径中)。要开始解析和跟踪广告中提供的日志文件，只需双击Chainsaw的Zeroconf选项卡中的广告条目。目前，Chainsaw只支持FileAppender广告。

通告一个appender配置:

将JmDNS库从JmDNS GitHub Releases中添加到应用程序类路径中
将配置元素的'advertiser'属性设置为'multicastdns'
将appender元素的'advertise'属性设置为'true'
如果发布基于fileappender的配置，则将appender元素上的'advertiseURI'属性设置为适当的URI
基于fileappender的配置需要在appender上指定一个额外的'advertiseURI'属性。'advertiseURI'属性为Chainsaw提供了如何访问文件的信息。例如，链锯可以通过ssh/sftp远程访问文件，指定Commons VFS (https://commons.apache.org/proper/commons-vfs/) sftp:// URI;如果通过web服务器访问文件，可以使用http:// URI;如果从本地运行的链锯实例访问文件，可以指定file:// URI。

下面是一个启用广告的appender配置示例，本地运行的Chainsaw可以使用它来自动跟踪日志文件(注意file://advertiseuri):

请注意，您必须将JmDns库从https://jmdns.sourceforge.net添加到您的应用程序类路径中，以便使用'multicastdns'广告器进行广告(advertiser)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Configuration advertiser="multicastdns">
...
</Configuration>
<Appenders>
  <File name="File1" fileName="output.log" bufferedIO="false" advertiseURI="file://path/to/output.log" advertise="true">
  ...
  </File>
</Appenders>
```

# 配置语法 Configuration Syntax

从2.9版本开始，出于安全原因，Log4j不处理XML文件中的DTD。如

果希望将配置拆分到多个文件中，请使用XInclude或Composite configuration。

正如前面的示例以及后面的示例所示，Log4j允许您轻松地重新定义日志记录行为，而无需修改应用程序。

可以禁用应用程序的某些部分的日志记录，只在满足特定条件时记录日志，例如为特定用户执行的操作，将输出路由到Flume或日志报告系统等。要做到这一点，需要理解配置文件的语法。

XML文件中的配置元素接受以下几个属性:

| Attribute Name	| Description |
|:----|:----|
| advertiser | (可选)广告插件名称，用于发布单个FileAppender或SocketAppender配置。提供的唯一广告插件是“multicastdns”。 |
| dest | 标准输出为"err"，标准输出为"out"，文件路径或URL。 |
| monitorInterval | 在检查文件配置是否发生更改之前必须经过的最小时间(以秒为单位)。 |
| name | 配置名称 |
| packages | 不赞成使用packages属性，并将在Log4j 3.0中删除。应该使用Log4j注释处理器处理插件。一个逗号分隔的包名称列表，用于搜索插件。每个类加载器只加载插件一次，因此更改此值可能不会对重新配置产生任何影响。 |
| schema | 标识类装入器定位用于验证配置的XML Schema的位置。仅当strict设置为true时有效。如果没有设置，则不会进行模式验证。 |
| shutdownHook | 指定在JVM关闭时Log4j是否应该自动关闭。默认情况下，关机钩子是启用的，但可以通过将此属性设置为“disable”来禁用。 |
| shutdownTimeout | 指定JVM关闭时appender和后台任务关闭的毫秒数。默认值为零，这意味着每个appender使用其默认超时，并且不等待后台任务。并不是所有的appender都会遵守这一点，这是一个暗示，而不是绝对保证关闭过程不会花费更长时间。将此值设置得太低会增加丢失尚未写入最终目的地的未完成日志事件的风险。看到LoggerContext。停止(长,java.util.concurrent.TimeUnit)。(如果shutdownHook设置为“disable”，则不使用。) |
| status | 应该记录到控制台的内部Log4j事件的级别。该属性的有效值为off、trace、debug、info、warn、error、fatal和all。Log4j将把有关初始化、滚动和其他内部操作的详细信息记录到状态记录器中。如果需要对log4j进行故障排除，设置status="trace"是您可以使用的首批工具之一。(或者，设置系统属性Log4j2 .debug也会将内部Log4j2日志记录打印到控制台，包括在找到配置文件之前发生的内部日志记录。) |
| strict | 允许使用严格的XML格式。在JSON配置中不支持。 |
| verbose | 在加载插件时启用诊断信息。 |

# 参考资料

https://logging.apache.org/log4j/2.x/manual/configuration.html

* any list
{:toc}

