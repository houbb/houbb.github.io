---
layout: post
title:  【leetcode】80-recursive 递归
date:  2020-6-8 15:13:08 +0800
categories: [Algorithm]
tags: [algorithm, greedy, leetcode]
published: true
---

# chat

## 是什么？

递归算法是一种在计算机科学中非常常见的解决问题的方法，它通过函数调用自身来解决问题。

递归通常将复杂的问题分解成更小的子问题，通过逐步缩小问题规模直到满足某种条件（基准情况或边界条件）停止递归调用，从而得到解答。

### 递归的基本组成部分
一个典型的递归算法包含两个关键部分：

1. **基准条件（Base Case）**：基准条件是递归算法停止递归的条件。它通常用于处理最简单的情况，不需要进一步分解。例如，计算阶乘时，`0! = 1` 就是基准条件。
  
2. **递归条件（Recursive Case）**：递归条件定义了如何将问题分解为更小的子问题，并递归地调用函数自身来处理这些子问题。例如，计算阶乘时，`n! = n * (n - 1)!` 是递归条件。

### 递归算法的工作原理
递归通过函数的“自调用”逐层将问题分解成子问题并推入调用栈，直到满足基准条件，然后自下而上逐步回溯计算出结果。

### 示例：阶乘计算
阶乘问题可以用递归来简单地描述，数学上定义为：
- \( n! = n \times (n-1)! \)
- 基准条件：\( 0! = 1 \)

在代码中，用递归实现阶乘的示例如下：

```python
def factorial(n):
    if n == 0:  # 基准条件
        return 1
    else:
        return n * factorial(n - 1)  # 递归条件
```

例如，`factorial(3)` 的计算过程如下：
1. `factorial(3)` 计算 `3 * factorial(2)`
2. `factorial(2)` 计算 `2 * factorial(1)`
3. `factorial(1)` 计算 `1 * factorial(0)`
4. `factorial(0)` 返回 `1`
5. 逐步回溯计算，得到最终结果 `3 * 2 * 1 * 1 = 6`

### 递归的优缺点
#### 优点
- **简单直观**：递归有助于用简单的代码结构表达复杂的算法逻辑，特别适合分治问题和树结构的操作。
- **自然分治**：递归可以轻松地将问题分解成子问题，尤其适用于分治法。

#### 缺点
- **性能开销**：递归会占用较多的栈空间，因为每次递归调用都会增加一个函数调用栈。对于较大的输入规模，可能会导致栈溢出错误。
- **可能存在冗余计算**：有时递归会重复计算相同的子问题，导致效率下降。例如，使用递归计算斐波那契数列时，直接递归会重复计算相同的数值。

### 递归与动态规划

递归与动态规划（Dynamic Programming，DP）密切相关。

通过记忆化（Memoization）和自底向上的计算方式，可以避免冗余计算，从而提升效率。

例如，使用动态规划算法计算斐波那契数列，避免了重复计算。

### 递归的应用场景
递归算法广泛应用于以下场景：

1. **分治法**：快速排序、归并排序等分治法算法。
2. **树和图的遍历**：深度优先搜索（DFS）常用递归实现。
3. **组合与排列问题**：如八皇后问题、子集生成等。
4. **动态规划**：通过递归和记忆化实现动态规划问题，如背包问题。

### 递归优化建议
1. **尾递归**：若语言支持尾递归优化，可将递归转换为尾递归，降低栈空间使用。
2. **记忆化**：使用缓存保存已经计算过的结果，减少重复计算。
3. **迭代替换**：某些场景可以用迭代替换递归，从而避免栈溢出问题。

递归算法虽然简洁高效，但需要注意性能和内存的管理，通过优化可以在实际应用中取得更好的效果。

# 参考资料

https://leetcode.cn/problems/hanota-lcci/description/?envType=problem-list-v2&envId=recursion

* any list
{:toc}