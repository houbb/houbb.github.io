---
layout: post
title: java 变更日志-15-jdk15
date:  2017-06-28 23:15:43 +0800
categories: [Java]
tags: [jdk, java]
published: true
---

# 拓展阅读

[Java Functional java 函数式编程](https://houbb.github.io/2017/06/29/java-functional)

[Java Lambda](https://houbb.github.io/2017/06/28/java-lambda)

# jdk15 有哪些新特性

JDK 15 引入了一系列新特性和改进，以下是 JDK 15 的一些主要新特性：

1. **EdDSA 数字签名算法（JEP 339）**：引入了 Edwards-Curve 数字签名算法（EdDSA），这是一种现代的椭圆曲线签名方案，提供了更高的安全性和性能。

2. **封闭类（JEP 360）**：作为预览特性，封闭类允许类或接口限制哪些其他类可以继承或实现它们，增强了 Java 编程语言的能力。

3. **隐藏类（JEP 371）**：这一特性有助于框架在运行时生成类，同时限制对这些类的访问，只能通过反射进行访问。

4. **移除 Nashorn JavaScript 引擎（JEP 372）**：Nashorn 引擎及其 API 和工具 `jjs` 被移除，因为它的维护成本较高。

5. **重新实现旧版 DatagramSocket API（JEP 373）**：改进了 `java.net.DatagramSocket` 和 `java.net.MulticastSocket` 的底层实现，使其更简单、更易于维护和调试。

6. **禁用和弃用偏向锁（JEP 374）**：在 JDK 15 中，默认禁用了偏向锁，并弃用了所有相关命令行选项，以减少维护成本。

7. **模式匹配改进（JEP 375）**：作为第二次预览，这个特性增强了 `instanceof` 表达式，允许模式匹配来简化类型检查和变量声明。

8. **ZGC 功能转正（JEP 377）**：Z Garbage Collector（ZGC）从预览特性变更为正式特性，它是一个可伸缩、低延迟的垃圾回收器。

9. **文本块功能转正（JEP 378）**：文本块作为一个多行字符串特性，避免了使用大多数转义符号，并允许开发人员控制格式。

10. **Shenandoah 垃圾回收算法转正（JEP 379）**：Shenandoah 从预览特性变为正式特性，它通过与运行的 Java 线程并发进行疏散工作来减少 GC 暂停时间。

11. **移除 Solaris 和 SPARC 端口（JEP 381）**：移除了 Solaris/SPARC、Solaris/x64 和 Linux/SPARC 端口的源代码及构建支持。

12. **外部存储器访问 API（JEP 383）**：二次孵化的 API，允许 Java 程序安全有效地访问 Java 堆之外的外部内存。

13. **记录类型（JEP 384）**：第二次预览，提供了一种新的类，用于不可变数据的封装，类似于 Kotlin 中的数据类或 Scala 中的 case class。

14. **弃用 RMI 激活（JEP 385）**：RMI 激活被标记为弃用，因为它在现代应用程序中很少被使用，且维护成本较高。

这些新特性和改进体现了 JDK 15 在性能、安全性、易用性和现代化方面的持续进步。


# jdk15 EdDSA 数字签名算法（JEP 339）

JEP 339 引入了 JDK 15 中的 EdDSA（Edwards-curve Digital Signature Algorithm）数字签名算法。

这是一个现代的、高性能的数字签名算法，基于 Edwards 曲线，旨在提供更安全、更高效的签名生成和验证机制。

### EdDSA 简介

EdDSA 是一个基于 Edwards 曲线的数字签名算法，提供了一种安全、高效的方式来生成和验证数字签名。

相较于传统的 RSA 和 DSA 签名算法，EdDSA 提供了更好的性能和安全性，特别是在移动设备和嵌入式系统中。

### 主要特点

1. **高性能**：EdDSA 提供了比传统算法更快的签名生成和验证速度，特别是在有限资源的环境中。

2. **安全性**：基于现代密码学和数学，提供了高安全性的数字签名解决方案。

3. **简洁性**：相较于其他签名算法，EdDSA 的实现和使用更为简单和直观。

### 使用 EdDSA

在 JDK 15 中，你可以使用 `java.security.Signature` 类来使用 EdDSA 签名算法。

以下是一个简单的示例：

```java
import java.security.*;

public class EdDSASignatureExample {
    public static void main(String[] args) throws Exception {
        // 初始化密钥对生成器
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EdDSA");
        KeyPair keyPair = keyGen.generateKeyPair();

        // 获取私钥和公钥
        PrivateKey privateKey = keyPair.getPrivate();
        PublicKey publicKey = keyPair.getPublic();

        // 创建 Signature 对象
        Signature signature = Signature.getInstance("EdDSA");

        // 初始化签名对象
        signature.initSign(privateKey);

        // 更新签名对象的数据
        byte[] data = "Hello, EdDSA!".getBytes();
        signature.update(data);

        // 生成签名
        byte[] sign = signature.sign();
        System.out.println("Signature: " + bytesToHex(sign));

        // 初始化验证签名的对象
        signature.initVerify(publicKey);

        // 更新验证对象的数据
        signature.update(data);

        // 验证签名
        boolean isVerified = signature.verify(sign);
        System.out.println("Signature verified: " + isVerified);
    }

    // 将字节数组转换为十六进制字符串
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }
}
```

### 注意事项

- **版本依赖**：确保你的应用程序和库支持 EdDSA 签名算法。尽管 JDK 15 提供了对 EdDSA 的支持，但仍需要确保其他组件也支持此算法。

- **安全性**：始终确保在安全的环境中生成、存储和验证签名密钥，以防止密钥被泄露或篡改。

### 结论

JEP 339 引入的 EdDSA 签名算法为 JDK 15 增加了一种现代、高性能的数字签名解决方案。

通过提供安全、高效和简洁的签名机制，EdDSA 算法不仅可以提高数据的安全性，还可以在各种环境和应用程序中提供更好的性能和可用性。

# jdk15 封闭类（JEP 360）

JEP 360 引入了 JDK 15 中的密封类（Sealed Classes 和 Sealed Interfaces）。

这一特性提供了一种限制类和接口的继承的机制，使得开发者可以明确指定哪些类或接口可以扩展或实现它们，从而增强了类型系统的安全性和可维护性。

### 密封类简介

密封类（Sealed Classes）和密封接口（Sealed Interfaces）允许你定义一个类或接口的继承层次结构，明确指定哪些子类或实现类是允许的。

这可以防止在不应该被扩展或实现的类或接口上创建新的子类或实现类。

### 主要特点

1. **限制继承**：密封类和接口可以明确指定允许继承或实现的类和接口，防止未经授权的扩展。

2. **增强类型安全性**：通过限制允许的继承和实现，提供了更强的类型安全性，减少了潜在的错误和不一致性。

3. **提高代码可读性和可维护性**：明确的继承和实现关系使得代码更加清晰和易于维护，减少了对文档和注释的依赖。

### 基本语法

**密封类的定义**：

```java
public sealed class Shape permits Circle, Rectangle, Triangle {
    // 类定义
}
```

在上面的例子中，`Shape` 类是一个密封类，只允许 `Circle`、`Rectangle` 和 `Triangle` 作为它的直接子类。

**密封接口的定义**：

```java
public sealed interface Shape permits Circle, Rectangle, Triangle {
    // 接口定义
}
```

在这里，`Shape` 接口是一个密封接口，只允许 `Circle`、`Rectangle` 和 `Triangle` 实现它。

### 注意事项

- **权限控制**：需要仔细考虑哪些类或接口应该被允许扩展或实现，以确保代码的逻辑正确性和一致性。

- **迁移现有代码**：如果你的项目包含了需要密封的类或接口，可能需要进行一些代码重构和迁移，以适应新的密封类和接口的限制。

### 结论

JEP 360 的密封类和密封接口为 Java 引入了一种强大的类型系统增强特性，允许开发者更精确地控制类和接口的继承和实现。

通过限制继承和实现，密封类和接口提供了更高的代码安全性、可读性和可维护性，有助于减少潜在的错误和不一致性，从而提高了 Java 应用程序的质量和可靠性。

## 为什么 java 已经有 final 关键词了，还有额外引入这个 sealed?

Java 中的 `final` 关键字和新引入的封闭类（sealed classes）概念虽然都与类的继承相关，但它们的目的和用途是不同的。

1. **`final` 关键字**：
   - 当一个类被声明为 `final`，它不能被任何其他类继承。这通常用于表示该类是设计为不可变的，或者其实现细节应当保密，不应被扩展。
   - `final` 类主要用于阻止继承，确保该类不会被子类化，从而避免潜在的滥用或不当扩展。

2. **封闭类（sealed classes）**：
   - 封闭类允许更细粒度的控制，它不仅防止了类的继承，还可以精确指定哪些类可以继承该封闭类，或者哪些类可以是该封闭类的一个实例（通过 `permits` 关键字）。
   - 封闭类提供了一种机制，允许开发者定义一个受限的类层次结构，这在设计有限的或者固定的一组类时非常有用，例如，当设计一组紧密相关的类，且希望限制这些类之间的关系时。

**为什么需要 `sealed`？**

- **更明确的规范**：`sealed` 类提供了一种方式来明确地指定哪些类是类层次结构的一部分，这有助于开发者更精确地控制程序的结构，并且使得意图更加清晰。
- **增强的安全性**：通过限制可以继承特定类的其他类，封闭类有助于减少不可预见的或潜在的恶意子类化，从而增强了程序的安全性。
- **更好的维护性**：封闭类可以使得类的维护和理解变得更容易，因为开发者可以知道哪些类是预期的，并且可以限制对这些类的修改。
- **限制范围**：`sealed` 类允许你限制继承的范围，比如只允许特定包内的类继承，或者只允许在明确列出的类中进行继承，这是 `final` 关键字无法做到的。

总的来说，虽然 `final` 关键字提供了一种简单的机制来防止类的继承，但 `sealed` 类提供了一种更细粒度的控制方式，允许开发者更精确地定义和限制类继承的规则，从而在某些场景下提供更强大的类型安全和更好的代码设计。

# jdk15 隐藏类（JEP 371）

JEP 371 引入了 JDK 15 中的隐藏类（Hidden Classes）。这一特性为 Java 引入了一种新的类加载机制，允许开发者在运行时动态生成类，而不是通过传统的 `.class` 文件进行编译。

### 隐藏类简介

隐藏类是一种特殊类型的类，它不是通过传统的 `.class` 文件加载，而是在运行时通过特殊的 API 动态创建。隐藏类可以作为私有辅助类或内部实现类，用于实现框架、库或应用程序的内部逻辑。

### 主要特点

1. **动态生成**：隐藏类允许在运行时动态生成和加载类，无需预先编译为 `.class` 文件。

2. **隐私和封装**：由于隐藏类是动态生成的，它们可以被设计为不可见或私有，用于封装框架或库的内部实现细节。

3. **更高的安全性**：隐藏类可以作为内部辅助类，减少了不必要的访问权限和暴露风险。

### 如何使用隐藏类

使用隐藏类需要使用 `java.lang.invoke.MethodHandles.Lookup` API，该 API 提供了创建隐藏类的方法。

以下是一个简单的示例，演示如何使用 `MethodHandles.Lookup` 创建隐藏类：

```java
import java.lang.invoke.MethodHandles;

public class HiddenClassExample {
    public static void main(String[] args) throws Exception {
        MethodHandles.Lookup lookup = MethodHandles.lookup();
        
        Class<?> hiddenClass = lookup.defineHiddenClass(
            "HiddenClass", // 类名
            generateHiddenClassBytes(), // 类字节码
            null // 允许的父类
        );
        
        System.out.println("Hidden class name: " + hiddenClass.getName());
    }

    private static byte[] generateHiddenClassBytes() {
        // 生成隐藏类的字节码
        // 省略具体实现
        return new byte[]{ /* 字节码内容 */ };
    }
}
```

在这个例子中，`defineHiddenClass` 方法用于创建一个名为 "HiddenClass" 的隐藏类，其字节码由 `generateHiddenClassBytes()` 方法生成。

### 注意事项

- **安全性考虑**：由于隐藏类的动态性质，需要小心处理它们的生命周期和可访问性，以确保代码的安全性和一致性。

- **性能影响**：虽然隐藏类提供了更高的灵活性，但动态生成和加载类可能会对性能产生影响，特别是在大规模或复杂的应用程序中。

### 结论

JEP 371 的隐藏类特性为 Java 提供了一种新的、动态的类加载机制，允许开发者在运行时动态生成和加载类。这为实现框架、库或应用程序的内部逻辑提供了更高的灵活性和隐私性，同时还提供了一种安全、封装的方式来管理和组织代码。

尽管隐藏类为开发者提供了更多的工具和选项，但在使用它们时需要谨慎，确保代码的安全性、可维护性和性能。

# jdk15 移除 Nashorn JavaScript 引擎（JEP 372）

JEP 372 引入了 JDK 15 中的一个重大变更，即移除 Nashorn JavaScript 引擎。Nashorn 是 Java 8 中引入的一个 JavaScript 引擎，用于在 Java 环境中执行 JavaScript 代码。然而，由于一系列的原因，决定在 JDK 15 中将其移除。

### Nashorn 简介

Nashorn 是一个基于 JVM（Java 虚拟机）的 JavaScript 引擎，它允许 Java 开发者在 Java 应用程序中直接执行 JavaScript 代码。Nashorn 提供了一种简单、集成的方式来处理 JavaScript，特别是在需要在 Java 环境中嵌入 JavaScript 代码时。

### 移除原因

1. **维护成本**：Nashorn 的维护成本相对较高，需要专门的资源来维护和更新它。

2. **性能问题**：与现代的 JavaScript 引擎相比，Nashorn 在性能上可能不如预期，特别是在处理大型和复杂的 JavaScript 应用程序时。

3. **JIT 缺失**：Nashorn 不支持即时编译（JIT），这可能导致在某些情况下性能下降。

4. **社区支持**：JavaScript 社区在过去几年里已经发展得非常快速，有许多高质量、开源的 JavaScript 引擎可供选择，如 V8（由 Google 开发）和 SpiderMonkey（由 Mozilla 开发）。

### 迁移建议

- **使用其他 JavaScript 引擎**：考虑使用其他现代的 JavaScript 引擎，如 V8 或 SpiderMonkey，这些引擎在性能和功能上都有很好的表现。

- **升级到最新版本**：如果你仍然需要在 Java 中执行 JavaScript 代码，确保使用最新版本的 Nashorn 或其他可靠的 JavaScript 引擎。

- **检查依赖和代码**：审查你的项目，确保没有依赖 Nashorn 特定的功能或 API，如果有，找到替代方案或更新到更现代的实现。

### 结论

JEP 372 的 Nashorn 移除标志着 Java 平台对 JavaScript 支持的一个重要转变，鼓励开发者使用更现代、高效和可靠的 JavaScript 引擎。

虽然 Nashorn 在其存在期间为 Java 开发者提供了一个便捷的 JavaScript 执行环境，但随着技术的进步和社区的发展，现代的 JavaScript 引擎提供了更好的性能、功能和兼容性，有助于构建更强大、更灵活的应用程序。

因此，对于依赖 Nashorn 的项目，建议及时迁移到其他可靠的 JavaScript 引擎，以确保代码的可维护性和性能。

# jdk15 重新实现旧版 DatagramSocket API（JEP 373）

JEP 373 引入了 JDK 15 中的一个重要变更，即重新实现旧版 DatagramSocket API。这一变更旨在优化和现代化 JDK 中的 DatagramSocket API，以提高其性能、可维护性和安全性。

### DatagramSocket 简介

DatagramSocket 是 Java 中用于实现用户数据报协议（UDP）的基础网络通信类。它允许开发者通过 UDP 协议发送和接收数据报。

### 重新实现原因

1. **性能改进**：通过重新实现 DatagramSocket API，可以优化其底层实现，提高网络通信的性能和效率。

2. **可维护性**：现代化的实现使得代码更加模块化和可维护，便于后续的更新和扩展。

3. **安全性增强**：通过重新设计和实现，可以加强对安全漏洞和网络攻击的防护，提高应用程序的安全性。

4. **功能扩展**：新的实现可能会引入新的功能和改进，使 DatagramSocket API 更加强大和灵活。

### 主要变更和改进

1. **性能优化**：通过更有效的网络 IO 和资源管理，提高了数据传输的速度和稳定性。

2. **代码清理**：消除了旧代码中的冗余和过时的部分，简化了 API 的结构和设计。

3. **错误处理**：增强了错误处理和异常管理，提高了系统的健壮性和稳定性。

### 迁移建议

- **代码更新**：如果你的应用程序使用了旧版 DatagramSocket API，建议更新到最新版本，以利用新的性能和安全性改进。

- **测试验证**：在更新后，进行充分的测试，确保新的 DatagramSocket 实现满足你的应用程序的需求，并且与现有的网络架构兼容。

- **文档参考**：查阅相关的文档和资源，了解新的 API 设计和使用方法，以便正确地集成和使用它。

### 结论

JEP 373 的重新实现旧版 DatagramSocket API 是 JDK 15 中的一个重要改进，旨在提高 UDP 网络通信的性能、可维护性和安全性。

通过优化底层实现、简化 API 结构和加强错误处理，新的 DatagramSocket 实现为开发者提供了一个更强大、更可靠的网络通信工具。

对于依赖 DatagramSocket API 的项目，建议及时更新到 JDK 15 或更高版本，以利用这些有益的改进，并确保网络通信的质量和安全性。

# jdk15 禁用和弃用偏向锁（JEP 374）

JEP 374 引入了 JDK 15 中的一个重要变更，即禁用和弃用偏向锁。这一变更旨在优化和简化 Java 的锁机制，以提高应用程序的性能和可维护性。

### 偏向锁简介

偏向锁是 Java 中用于提高同步性能的一种优化技术。

当一个锁仅被一个线程持有时，JVM 会自动将其转换为偏向锁，以减少同步操作的开销。

然而，随着硬件和 JVM 的发展，偏向锁的效益逐渐减少，甚至在某些情况下可能导致性能下降。

### 禁用和弃用原因

1. **性能问题**：在某些情况下，偏向锁可能导致性能下降，特别是在多线程和高并发环境中。

2. **复杂性**：偏向锁的实现增加了 JVM 的复杂性，可能导致代码维护和优化的困难。

3. **资源使用**：虽然偏向锁减少了同步操作的开销，但它仍然消耗了额外的内存和 CPU 资源。

4. **一致性和可预测性**：弃用偏向锁可以使 JVM 行为更加一致和可预测，减少不必要的锁定和同步问题。

### 主要变更和影响

1. **禁用默认偏向锁**：JDK 15 默认禁用了偏向锁，意味着当一个锁首次被多个线程竞争时，它不会自动转换为偏向锁。

2. **弃用偏向锁**：虽然偏向锁仍然存在于 JDK 15，但它已被标记为弃用，并且可能在未来的版本中被完全移除。

3. **性能优化**：除了禁用偏向锁外，JVM 也进行了其他性能优化，以提高同步操作的效率和吞吐量。

### 迁移建议

- **代码审查**：检查你的应用程序，识别和替换依赖偏向锁的代码，使用其他同步机制（如轻量级锁、重量级锁等）来保持代码的正确性和性能。

- **性能测试**：在更新后进行性能测试，确保新的同步机制满足你的应用程序的需求，并且与现有的线程模型兼容。

- **文档更新**：更新相关文档和资源，通知开发者和用户关于偏向锁的禁用和弃用，以及如何迁移和优化应用程序。

### 结论

JEP 374 的禁用和弃用偏向锁是 JDK 15 中的一个关键改进，旨在简化和优化 Java 的同步机制，提高应用程序的性能和可维护性。

尽管偏向锁曾经是 Java 同步优化的一部分，但随着技术的进步和应用程序的发展，其效益已经减少。

因此，对于依赖偏向锁的项目，建议及时迁移到其他更现代、更高效的同步机制，以确保应用程序的稳定性和性能。

# jdk15 模式匹配改进（JEP 375）

JEP 375 引入了 JDK 15 中的模式匹配改进，旨在进一步提升 Java 语言的表达能力和灵活性。

模式匹配是一种强大的编程语言特性，它使得代码更加清晰、简洁，并提供了更好的类型安全性。

### 模式匹配简介

模式匹配是一种结构化的、类型安全的方式来检查和提取数据。它允许开发者通过模式匹配语法来识别对象的结构或属性，并据此执行相应的操作。

### 主要改进和特性

1. **更强大的 instanceof**：引入了新的 `instanceof` 模式匹配语法，允许在 `instanceof` 操作中同时进行类型检查和类型转换。

   ```java
   if (obj instanceof String s) {
       System.out.println("String length: " + s.length());
   }
   ```

   在上面的例子中，如果 `obj` 是 `String` 类型，`s` 将会是 `String` 类型的引用，并且可以直接访问 `String` 的方法，无需强制类型转换。

2. **switch 表达式的改进**：进一步改进了 `switch` 表达式，使其更加强大和灵活，支持更多的模式匹配操作。

   ```java
   int result = switch (obj) {
       case String s -> s.length();
       case Integer i -> i * 2;
       default -> 0;
   };
   ```

   在上面的例子中，`switch` 表达式根据 `obj` 的类型执行不同的操作，并返回相应的结果。

3. **更好的类型推断**：模式匹配改进还提供了更好的类型推断，使得编写泛型代码更加容易和直观。

### 优势和影响

1. **代码清晰性**：模式匹配使得代码更加结构化和直观，减少了冗余的类型检查和类型转换代码。

2. **类型安全性**：通过强类型检查和模式匹配，提高了代码的类型安全性，减少了运行时错误。

3. **提高生产力**：简洁的语法和强大的功能使得开发者能够更快速地编写和理解代码，提高了开发效率。

### 迁移建议

- **学习新特性**：熟悉新的模式匹配语法和语义，了解如何正确和有效地使用它们。

- **更新代码**：识别和替换旧的 `instanceof` 和 `switch` 语句，使用新的模式匹配语法来改进和简化代码。

- **性能测试**：在更新后进行性能测试，确保新的模式匹配特性不会影响应用程序的性能和稳定性。

### 结论

JEP 375 的模式匹配改进为 Java 引入了一种强大和灵活的编程工具，使得代码更加清晰、简洁，并提供了更好的类型安全性。

通过引入新的 `instanceof` 模式匹配语法和改进的 `switch` 表达式，Java 语言得到了显著的语法和语义提升，有助于构建更加健壮、高效和可维护的应用程序。

对于 Java 开发者，掌握和应用新的模式匹配特性将是提升编程技能和提高代码质量的关键。

# jdk15 ZGC 功能转正（JEP 377）

JEP 377 引入了 JDK 15 中的一个重要变更，即将 ZGC（Z Garbage Collector）从实验阶段转正。ZGC 是一款由 Oracle 开发的低延迟垃圾回收器，专为大内存堆和需要快速响应时间的应用程序设计。

### ZGC 简介

ZGC 是一个全并发、低延迟的垃圾回收器，它采用了并发执行的方式来最小化 GC 停顿时间，从而提供更高的应用程序响应性和可用性。

ZGC 主要为大内存应用程序设计，支持数十 GB 或数百 GB 的堆内存，并且在维持低延迟的同时也保持了高吞吐量。

### 功能转正的原因

1. **稳定性和可靠性**：经过多个版本的迭代和大规模测试，ZGC 已经证明了其在生产环境中的稳定性和可靠性。

2. **广泛的应用需求**：随着大内存应用程序的普及，对于低延迟和高吞吐量的垃圾回收器的需求也在增加，ZGC 正好满足了这些需求。

3. **社区支持和反馈**：ZGC 得到了广大开发者社区的积极反馈和支持，证明了其在实际应用中的有效性和性能优势。

### 主要特性和优势

1. **低延迟**：ZGC 的全并发执行策略显著减少了 GC 停顿时间，使得应用程序能够更快速地响应用户请求。

2. **高吞吐量**：除了低延迟外，ZGC 也提供了高吞吐量，适用于需要处理大量数据和高并发的应用场景。

3. **大堆支持**：ZGC 专为大内存堆设计，能够高效管理大容量的堆内存，满足高性能和大数据应用的需求。

### 迁移建议

- **更新 JDK 版本**：考虑将 JDK 升级到支持 ZGC 的最新版本，以获得其提供的低延迟和高吞吐量优势。

- **性能监控和调优**：使用性能监控工具和分析数据，识别和优化可能影响 ZGC 性能的因素和瓶颈。

- **文档和培训**：更新相关文档和资源，提供有关 ZGC 的最佳实践、性能调优建议和使用指南，以帮助开发者更好地利用 ZGC 的特性和优势。

### 结论

JEP 377 的 ZGC 功能转正标志着 ZGC 已经从实验阶段成功演变为一个稳定、成熟和可靠的低延迟垃圾回收解决方案。对于需要快速响应时间、高吞吐量和大内存支持的 Java 应用程序，ZGC 提供了一种高效、可靠的 GC 策略，有助于提高应用程序的性能、可用性和可维护性。因此，对于正在寻找高性能垃圾回收器的 Java 应用程序，ZGC 是一个值得考虑和采用的强大选择。

# jdk15 文本块功能转正（JEP 378）

JEP 378 引入了 JDK 15 中的一个关键变更，即将文本块（Text Blocks）功能从预览阶段转正。文本块是为了简化在 Java 代码中编写多行字符串而引入的一项语言特性，它提供了一种更加直观和易于维护的方式来定义多行文本。

### 文本块简介

文本块允许开发者使用三个双引号（"""）来定义一个多行字符串，而无需手动添加换行符或转义特殊字符。这使得在代码中嵌入多行文本变得更加简洁和清晰。

```java
String html = """
              <html>
                  <body>
                      <p>Hello, world!</p>
                  </body>
              </html>
              """;
```

### 功能转正的原因

1. **稳定性和成熟性**：经过多次版本迭代和广泛的社区反馈，文本块功能已经证明了其在实际应用中的稳定性和成熟性。

2. **广泛的应用需求**：随着 Java 开发者对简化和提高代码可读性的需求增加，文本块提供的多行字符串定义方式已经得到了广泛的应用和认可。

3. **社区支持和反馈**：文本块功能得到了开发者社区的积极反馈和支持，证明了其在提高代码清晰度和简洁性方面的有效性。

### 主要特性和优势

1. **代码清晰性**：文本块使得多行字符串的定义更加直观和易于理解，提高了代码的可读性和可维护性。

2. **避免转义和换行符**：文本块允许开发者在字符串中自由使用换行符和双引号，无需手动添加转义字符，简化了字符串的编写。

3. **支持缩进**：文本块保留字符串中的初始缩进，使得格式化和代码排版更加灵活和自然。

### 迁移建议

- **更新 JDK 版本**：考虑将 JDK 升级到支持文本块的最新版本，以利用其提供的代码简洁性和可读性优势。

- **代码重构**：识别和替换旧的多行字符串定义方式，使用新的文本块语法来简化和清晰地表达多行文本。

- **文档和培训**：更新相关文档和教程，提供有关文本块的最佳实践、使用技巧和示例，以帮助开发者更好地利用这一特性。

### 结论

JEP 378 的文本块功能转正标志着文本块已经从实验阶段进化为 Java 的一个稳定、成熟和广泛应用的语言特性。

对于需要在 Java 代码中处理多行文本的开发者，文本块提供了一种更加简洁、清晰和可维护的方式来定义和处理多行字符串，有助于提高代码的质量、可读性和开发效率。

因此，对于正在寻找提高代码清晰度和简洁性的 Java 项目，文本块是一个非常有价值的特性，值得开发者广泛采用和应用。

# jdk15 Shenandoah 垃圾回收算法转正（JEP 379）

JEP 379 引入了 JDK 15 中的一个重要变更，即将 Shenandoah 垃圾回收算法从实验阶段转正。

Shenandoah 是一个低延迟、并发的垃圾回收算法，旨在减少垃圾回收造成的应用停顿时间，特别适用于需要快速响应时间和大内存容量的 Java 应用程序。

### Shenandoah 简介

Shenandoah 是由 Red Hat 开发的一款现代、并发的垃圾回收器，它采用了全并发的方式来最小化 GC 停顿时间，从而提供更高的应用程序响应性和可用性。

Shenandoah 主要为大内存堆和需要快速响应时间的应用程序设计，能够高效管理数十 GB 或数百 GB 的堆内存。

### 功能转正的原因

1. **稳定性和成熟性**：经过多个版本的迭代和大规模测试，Shenandoah 已经证明了其在生产环境中的稳定性和可靠性。

2. **广泛的应用需求**：随着大内存应用程序的普及，对于低延迟和高吞吐量的垃圾回收器的需求也在增加，Shenandoah 正好满足了这些需求。

3. **社区支持和反馈**：Shenandoah 得到了广大开发者社区的积极反馈和支持，证明了其在实际应用中的有效性和性能优势。

### 主要特性和优势

1. **低延迟**：Shenandoah 的全并发执行策略显著减少了 GC 停顿时间，使得应用程序能够更快速地响应用户请求。

2. **高吞吐量**：除了低延迟外，Shenandoah 也提供了高吞吐量，适用于需要处理大量数据和高并发的应用场景。

3. **大堆支持**：Shenandoah 专为大内存堆设计，能够高效管理大容量的堆内存，满足高性能和大数据应用的需求。

### 迁移建议

- **更新 JDK 版本**：考虑将 JDK 升级到支持 Shenandoah 的最新版本，以获得其提供的低延迟和高吞吐量优势。

- **性能监控和调优**：使用性能监控工具和分析数据，识别和优化可能影响 Shenandoah 性能的因素和瓶颈。

- **文档和培训**：更新相关文档和资源，提供有关 Shenandoah 的最佳实践、性能调优建议和使用指南，以帮助开发者更好地利用 Shenandoah 的特性和优势。

### 结论

JEP 379 的 Shenandoah 垃圾回收算法转正标志着 Shenandoah 已经从实验阶段成功演变为一个稳定、成熟和可靠的低延迟垃圾回收解决方案。

对于需要快速响应时间、高吞吐量和大内存支持的 Java 应用程序，Shenandoah 提供了一种高效、可靠的 GC 策略，有助于提高应用程序的性能、

可用性和可维护性。因此，对于正在寻找高性能垃圾回收器的 Java 项目，Shenandoah 是一个值得考虑和采用的强大选择。

# jdk15 移除 Solaris 和 SPARC 端口（JEP 381）

JEP 381 引入了 JDK 15 中的一个重要变更，即正式移除对 Solaris 操作系统和 SPARC 架构的支持。这个变更反映了 Java 平台和 JDK 开发团队在决定哪些平台和架构继续得到支持时的战略选择。

### 背景信息

Solaris 是 Sun Microsystems 开发的 UNIX 操作系统，而 SPARC（Scalable Processor Architecture）是 Sun Microsystems 开发的一个 RISC 处理器架构。Sun Microsystems 于 2010 年被 Oracle 收购后，对 Solaris 和 SPARC 的支持逐渐减少，而开发焦点转向了更为流行和广泛采用的操作系统和硬件架构。

### 移除的原因

1. **降低维护成本**：维护多个平台和架构需要显著的人力和资源投入。移除对 Solaris 和 SPARC 的支持可以让开发团队集中精力在更为主流和广泛采用的平台上，提高开发效率和代码质量。

2. **集中开发资源**：随着技术的发展和市场需求的变化，Java 平台和 JDK 开发团队需要集中开发资源在最有前景和发展潜力的平台上，以确保 Java 的持续创新和竞争力。

3. **响应市场趋势**：随着企业和开发者对操作系统和硬件架构的选择趋于标准化，对于非主流平台和架构的支持需求逐渐减少。

### 影响和考虑因素

1. **兼容性问题**：移除对 Solaris 和 SPARC 的支持可能会影响依赖这些平台的旧版本应用程序的兼容性。

2. **市场影响**：虽然 Solaris 和 SPARC 的市场份额已经大幅下降，但仍然有一些特定行业和应用场景依赖这些平台。这些用户可能需要寻找替代方案或考虑迁移到其他平台。

3. **社区反馈**：开发者社区可能对这一决策有不同的看法和反馈。一些开发者可能支持这一变更，认为它有助于简化和优化 JDK 的发展；而其他开发者可能对此表示关注，特别是那些仍在使用 Solaris 和 SPARC 的用户。

### 迁移建议

- **评估依赖关系**：识别和评估应用程序和服务是否依赖于 Solaris 和 SPARC。如果依赖关系存在，考虑寻找替代方案或迁移到其他平台。

- **更新文档和资源**：更新相关文档、教程和资源，通知开发者和用户关于 Solaris 和 SPARC 支持的移除，以及可能的迁移路径和建议。

- **提供支持和帮助**：提供有关迁移、替代方案和兼容性的支持和帮助，以帮助用户顺利过渡和适应新的环境。

### 结论

JEP 381 的移除 Solaris 和 SPARC 端口反映了 Java 平台和 JDK 开发团队对未来发展方向的策略调整。

尽管这一变更可能会影响到一些特定的用户和应用程序，但它有助于简化和优化 JDK 的发展，集中资源在最有前景和发展潜力的平台上。

对于受影响的用户，及时评估依赖关系，寻找替代方案，并获取必要的支持和帮助将是关键。

# jdk15 外部存储器访问 API（JEP 383）

JEP 383 引入了 JDK 15 中的一个重要特性，即外部存储器访问 API。这一新的 API 旨在提供一种统一、灵活的方式，以便 Java 应用程序可以更容易地访问和管理外部存储设备，如 SSD、HDD、USB 驱动器等。

### 外部存储器访问 API 简介

外部存储器访问 API 提供了一组 Java 接口和类，使开发者能够轻松地读取、写入、复制、移动和管理外部存储设备上的文件和目录。这有助于简化文件系统操作，提高代码可读性和可维护性，并增强 Java 应用程序与外部存储设备的集成性。

### 主要特性和功能

1. **统一的文件和目录操作**：外部存储器访问 API 提供了一套统一的接口，支持文件和目录的基本操作，如创建、删除、重命名、复制和移动。

2. **异步操作支持**：API 支持异步文件和目录操作，允许开发者在执行 I/O 操作时并发地执行其他任务，提高应用程序的性能和响应性。

3. **灵活的路径解析**：API 支持灵活的路径解析，允许开发者使用各种路径表达式来访问和操作外部存储设备上的文件和目录。

4. **安全和权限管理**：API 提供了安全的访问控制和权限管理机制，确保只有授权的应用程序和用户能够访问和修改外部存储设备上的文件和目录。

### 示例代码

以下是使用外部存储器访问 API 的简单示例：

```java
import java.nio.file.*;
import java.util.concurrent.*;

public class ExternalStorageExample {
    public static void main(String[] args) {
        Path externalPath = Paths.get("/mnt/external-drive/data.txt");

        try {
            // 异步读取文件内容
            CompletableFuture<String> contentFuture = CompletableFuture.supplyAsync(() -> {
                try {
                    return Files.readString(externalPath);
                } catch (Exception e) {
                    throw new RuntimeException("Failed to read file", e);
                }
            });

            // 打印文件内容
            contentFuture.thenAccept(content -> {
                System.out.println("File content: " + content);
            }).join(); // 等待异步操作完成
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 迁移建议

- **替换旧的文件操作 API**：考虑替换现有的旧文件操作 API，如 `java.io.File` 和 `java.nio.file.Files`，使用新的外部存储器访问 API，以利用其提供的新特性和功能。

- **更新文档和教程**：更新相关文档、教程和示例，提供有关外部存储器访问 API 的详细信息、最佳实践和使用指南，以帮助开发者更好地理解和利用这一新特性。

- **性能优化和测试**：在使用外部存储器访问 API 的应用程序中进行性能测试和优化，以确保其满足性能和可靠性要求。

### 结论

JEP 383 的外部存储器访问 API 为 Java 开发者提供了一种更加灵活、统一和高效的方式，以便访问和管理外部存储设备上的文件和目录。

这一新特性不仅有助于简化文件系统操作，提高代码质量和可维护性，还增强了 Java 应用程序与外部存储设备的集成性。

对于需要与外部存储设备交互的 Java 应用程序，外部存储器访问 API 将是一个非常有价值的新特性，值得开发者进一步探索和应用。

# jdk15 记录类型（JEP 384）

JEP 384 引入了 JDK 15 中的一个重要特性，即记录类型（Records）。记录类型是一种不可变、透明的数据载体，旨在简化数据封装和值对象的定义。它提供了一种更为简洁和明确的方式来定义只包含数据的类，避免了繁琐的样板代码和冗余的方法实现。

### 记录类型简介

记录类型是一种紧凑、不可变的类，由一组属性和自动生成的访问器方法组成。它们是显式声明为 final 的，且属性是 final 的，这确保了它们的不可变性。记录类型自动生成了构造方法、`equals()`、`hashCode()` 和 `toString()` 方法，简化了数据封装和值对象的创建。

### 主要特性和优势

1. **简洁的语法**：使用记录类型，开发者可以使用更简洁和直观的语法来定义数据载体，避免了手动编写样板代码。

2. **不可变性**：记录类型是不可变的，提供了更强的线程安全性和数据完整性保证。

3. **自动生成的方法**：记录类型自动生成了常用的方法，如构造方法、`equals()`、`hashCode()` 和 `toString()`，减少了开发者的工作量。

4. **语义明确**：通过使用记录类型，代码的意图和数据结构变得更加明确和一致，提高了代码的可读性和可维护性。

### 示例代码

以下是使用记录类型定义的简单示例：

```java
public record Person(String name, int age) {}

public class RecordExample {
    public static void main(String[] args) {
        Person person = new Person("Alice", 30);
        System.out.println(person.name());  // 输出 "Alice"
        System.out.println(person.age());   // 输出 30

        // 自动生成的 toString() 方法
        System.out.println(person);  // 输出 "Person[name=Alice, age=30]"
    }
}
```

### 迁移建议

- **替换值对象**：考虑使用记录类型替换现有的值对象或数据载体，以提高代码的简洁性和可读性。

- **更新文档和教程**：更新相关文档、教程和示例，提供有关记录类型的详细信息、最佳实践和使用指南，以帮助开发者更好地理解和利用这一新特性。

- **代码重构和优化**：对现有的代码进行审查和重构，识别和替换适合使用记录类型的部分，以充分利用其提供的优势和便利。

### 结论

JEP 384 的记录类型为 Java 开发者提供了一种简洁、明确和高效的方式来定义和使用数据载体。

通过减少样板代码、提高代码的可读性和可维护性，记录类型有助于提高开发效率和代码质量。

对于需要定义和操作值对象或数据结构的 Java 应用程序，记录类型将是一个非常有价值的新特性，值得开发者广泛探索和采用。

# jdk15 弃用 RMI 激活（JEP 385）

JEP 385 引入了 JDK 15 中的一个重要变更，即弃用远程方法调用（RMI）激活。RMI 激活是 Java RMI（Remote Method Invocation）框架的一部分，用于在远程主机上动态启动服务。

然而，由于现代分布式应用和微服务架构的普及，RMI 激活的使用逐渐减少，导致其被认为是过时和不再建议使用的特性。

### RMI 激活简介

RMI 激活允许开发者在远程主机上注册和激活 RMI 服务。它通过 RMI 注册表来管理和查找服务，然后在需要时动态激活服务。

尽管这一特性在过去是分布式系统和企业应用的常见选择，但由于现代微服务架构、容器化技术和云计算的发展，其在实际应用中的使用逐渐减少。

### 弃用的原因

1. **不再是首选方案**：随着微服务、容器化和云原生技术的兴起，开发者更倾向于使用轻量级、灵活和可扩展的解决方案，而不是传统的 RMI 激活方式。

2. **复杂性和维护成本**：RMI 激活的实现和维护相对复杂，需要特定的环境配置和管理，增加了部署和运维的负担。

3. **安全性和可靠性**：RMI 激活的安全性和可靠性问题可能导致潜在的安全风险和服务中断，这进一步削弱了其在现代应用中的吸引力。

### 迁移建议

- **替代技术选择**：考虑使用更现代、灵活和可扩展的技术替代 RMI 激活，如 RESTful API、gRPC、消息队列等。

- **更新文档和教程**：更新相关文档、教程和示例，通知开发者 RMI 激活已被弃用，提供迁移指南和替代方案建议。

- **评估依赖关系**：识别和评估应用程序是否依赖于 RMI 激活，如果依赖关系存在，考虑迁移到其他技术或平台。

### 结论

JEP 385 的弃用 RMI 激活反映了 Java 平台和 JDK 开发团队对分布式系统和远程服务访问方式的演变和变革。

随着现代应用架构和云计算的发展，传统的 RMI 激活特性逐渐被认为是过时和不再建议使用的。

因此，对于仍在使用 RMI 激活的开发者和组织，及时了解其弃用消息，评估依赖关系，并考虑采纳替代技术或方案将是至关重要的。

# 总结一下 jdk15 的变化

JDK 15 作为 Java 语言和平台的一次重要更新，引入了多项新特性、改进和弃用声明，以下是 JDK 15 的主要变化总结：

1. **EdDSA 数字签名算法（JEP 339）**：引入了一种新的、高效的数字签名算法，提高了安全性和性能。

2. **封闭类（JEP 360）**：作为预览特性，允许类或接口限制哪些其他类可以继承或实现它们。

3. **隐藏类（JEP 371）**：帮助框架在运行时生成类，同时限制对这些类的访问。

4. **删除 Nashorn JavaScript 引擎（JEP 372）**：移除了 Nashorn 引擎及其 API，因为它的维护成本较高。

5. **重新实现旧版 DatagramSocket API（JEP 373）**：改进了 `java.net.DatagramSocket` 和 `java.net.MulticastSocket` 的底层实现。

6. **禁用和弃用偏向锁（JEP 374）**：在 JDK 15 中，默认禁用了偏向锁，并弃用了所有相关命令行选项。

7. **模式匹配改进（JEP 375）**：作为第二次预览，增强了 `instanceof` 表达式，允许模式匹配。

8. **ZGC 功能转正（JEP 377）**：Z Garbage Collector 从预览特性变更为正式特性，提供了低延迟的垃圾回收。

9. **文本块功能转正（JEP 378）**：文本块作为一个多行字符串特性，避免了使用大多数转义符号。

10. **Shenandoah 垃圾回收算法转正（JEP 379）**：Shenandoah 从预览特性变为正式特性，以减少 GC 暂停时间。

11. **移除 Solaris 和 SPARC 端口（JEP 381）**：移除了 Solaris/SPARC、Solaris/x64 和 Linux/SPARC 端口的源代码及构建支持。

12. **外部存储器访问 API（JEP 383）**：二次孵化的 API，允许 Java 程序安全有效地访问 Java 堆之外的外部内存。

13. **记录类型（JEP 384）**：作为第二次预览，提供了一种新的类，用于不可变数据的封装。

14. **不推荐的 RMI 激活去除（JEP 385）**：RMI 激活被标记为弃用，因为它在现代应用程序中很少被使用。

这些变化体现了 JDK 15 在性能、安全性、易用性和现代化方面的持续进步。开发者应当关注这些变化，以确保他们的应用程序能够利用 JDK 15 引入的新特性和改进。

同时，对于预览特性和实验性特性，开发者应在生产环境中谨慎使用，并进行充分的测试。

* any list
{:toc}