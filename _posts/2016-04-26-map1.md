---
layout: post
title: Thinking in Java (hashmap-01)
date:  2016-4-25 12:15:54 +0800
categories: [Java]
tags: [map]
---

## Associative Array

Before learn map, let's see how Associative Array work;

```java
public class AssociativeArray<K, V>{
    private Object[][] pairs;
    private int index = 0;

    public AssociativeArray(int size) {
        pairs = new Object[size][2];    //
    }

    public AssociativeArray put(K key, V value) {
        if(index > pairs.length) {
            throw new ArrayIndexOutOfBoundsException();
        } else {
            pairs[index] = new Object[]{key, value};
            index++;
        }
        return this;
    }

    public V get(K key) {
        for(int i = 0; i < pairs.length; i++) {
            if(key.equals(pairs[i][0])) {
                return (V) pairs[i][1];
            }
        }
        return null;    //not found;
    }

    @Override
    public String toString() {
        return "AssociativeArray{" +
                "pairs=" + Arrays.deepToString(pairs) +
                '}';
    }
}
```

test

```java
public static void main(String[] args) {
        AssociativeArray<String, String> associativeArray = new AssociativeArray<String, String>(3);

        associativeArray.put("hello", "world").put("blue", "sky").put("happy","end");
        System.out.println(associativeArray);
        System.out.println(associativeArray.get("happy"));
    }
```

result

```java
AssociativeArray{pairs=[[hello, world], [blue, sky], [happy, end]]}
end

Process finished with exit code 0
```

If you continue to add, what will happened?

```java
public static void main(String[] args) {
    AssociativeArray<String, String> associativeArray = new AssociativeArray<String, String>(3);

    associativeArray.put("hello", "world").put("blue", "sky").put("happy","end");

    try{
        associativeArray.put("bad", "end");
    }catch(Exception e){
        e.printStackTrace();
    }
}
```

result

```java
java.lang.ArrayIndexOutOfBoundsException: 3
	at com.ryo.map.AssociativeArray.put(AssociativeArray.java:20)
	at com.ryo.map.AssociativeArray.main(AssociativeArray.java:48)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)

Process finished with exit code 0
```

## equals

When we use class in Java standard library as Map's key, they works well.But...

```java
public class Counter {
    private int num;
    public Counter(int num) {
        this.num = num;
    }
}
```

test

```java
public static void main(String[] args) {
    Map<Counter, String> map = new HashMap<Counter, String>();

    Counter one = new Counter(1);
    Counter two = new Counter(2);
    map.put(one, "too bad");
    map.put(two, "not bad");

    Counter one2 = new Counter(1);
    System.out.println(map.get(one2));
}
```

result

```java
null

Process finished with exit code 0
```

- why?

> Because our class Counter is default extends Object. Object's equals compare two object's address to adjust they are equal or not.

So...If you want it works well, you need override equals();

```java
public class Counter {
    private int num;

    public Counter(int num) {
        this.num = num;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Counter counter = (Counter) o;

        if (num != counter.num) return false;

        return true;
    }

    @Override
    public int hashCode() {
        return num;
    }
}

```

result

```java
too bad

Process finished with exit code 0
```
