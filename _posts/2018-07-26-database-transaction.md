---
layout: post
title:  Database Transaction
date:  2018-07-26 11:17:13 +0800
categories: [Database]
tags: [database, transaction, sf]
published: true
---

# 数据库事务

数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。

## 概要

一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的：

1. 为数据库操作序列提供了一个**从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法**。

2. 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以**防止彼此的操作互相干扰**。

当事务被提交给了DBMS（数据库管理系统），则DBMS（数据库管理系统）需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。
为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。

# ACID 性质

并非任意的对数据库的操作序列都是数据库事务。数据库事务拥有以下四个特性，习惯上被称之为ACID特性。

- 原子性（Atomicity）

事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。

- 一致性（Consistency）

事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。

- 隔离性（Isolation）

多个事务并发执行时，一个事务的执行不应影响其他事务的执行。

- 持久性（Durability）

已被提交的事务对数据库的修改应该永久保存在数据库中。

# 事务的隔离级别

如果不对数据库进行并发控制，可能会产生异常情况：

## 脏读(Dirty Read)

当一个事务读取另一个事务尚未提交的修改时，产生脏读。

同一事务内不是脏读。 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。
这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。

## 非重复读(Nonrepeatable Read) 

一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。

## 幻读(Phantom Reads) 

事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。

当对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。

## 丢失修改(Lost Update)

第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。

第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。

# SQL 标准事务隔离级别

为了兼顾并发效率和异常控制，在标准SQL规范中，定义了4个事务隔离级别，（ Oracle 和 SQL Server 对标准隔离级别有不同的实现 ）

## 未提交读(Read Uncommitted)

直译就是"读未提交"，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。

Read Uncommitted 允许脏读。

## 已提交读(Read Committed)

直译就是"读提交"，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。

Oracle等多数数据库**默认都是该级别**。

Read Commited 不允许脏读，但会出现非重复读。

## 可重复读(Repeatable Read)：

直译就是"可以重复读"，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。

Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。

## 串行读(Serializable)

直译就是"序列化"，意思是说这个事务执行的时候不允许别的事务并发执行。

完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

Serializable 不允许不一致现象的出现。

# 事务隔离的实现——锁

## 共享锁(S锁)

用于只读操作(SELECT)，锁定共享的资源。

共享锁不会阻止其他用户读，但是阻止其他的用户写和修改。

## 更新锁(U锁)

用于可更新的资源中。防止当多个会话在读取、锁定以及随后可能进行的资源更新时发生常见形式的死锁。

## 独占锁(X锁，也叫排他锁)

一次只能有一个独占锁用在一个资源上，并且阻止其他所有的锁包括共享缩。

写是独占锁，可以有效的防止“脏读”。


Read Uncommited 如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。

Read Committed 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。可以通过“瞬间共享读锁”和“排他写锁”实现。

Repeatable Read 读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。可以通过“共享读锁”和“排他写锁”实现。

Serializable 读加共享锁，写加排他锁，读写互斥。

# 参考资料

https://zh.wikipedia.org/zh-hans/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1

https://hit-alibaba.github.io/interview/basic/db/Transaction.html

https://www.jianshu.com/p/eb150b4f7ce0

* any list
{:toc}