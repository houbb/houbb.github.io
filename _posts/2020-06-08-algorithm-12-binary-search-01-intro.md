---
layout: post
title:  二分查找法？binary-search-01-基本概念介绍
date:  2020-6-8 15:13:08 +0800
categories: [Algorithm]
tags: [algorithm, search, binary-search]
published: true
---


# 二分查找法是什么？

二分查找法，这是一种在有序数组中查找特定元素的极其高效的算法。

## 核心思想：分而治之（Divide and Conquer）

二分查找的核心思想非常简单：不断将待查找的区间分成两半，根据中间元素与目标值的比较结果，排除掉一半不可能包含目标值的区间，在剩下的一半中继续查找。

这个过程反复进行，直到找到目标值或者确定目标值不存在。

## 为什么需要有序？

* 二分查找依赖于一个关键前提：数组必须是有序的（通常是升序，降序实现逻辑类似）。
* 只有有序，才能通过比较中间元素的值，确定目标值一定位于左半区间或者右半区间（或者正好是中间元素）。如果数组无序，这种“一半排除”的逻辑就不成立。

## 算法步骤详解（以升序数组为例）

1.  初始化指针：
    *   设置两个指针 `left` 和 `right`，分别指向当前待查找区间的起始索引和结束索引。初始时，`left = 0`，`right = n - 1`（`n` 是数组长度）。

2.  循环查找： 当 `left <= right` 时（表示当前待查找区间还有元素），重复以下步骤：
    *   计算中间索引： `mid = left + (right - left) // 2`
        *   *为什么这样计算？* 直接 `(left + right) // 2` 在 `left` 和 `right` 很大时可能导致整数溢出。`left + (right - left) // 2` 是更安全的写法，结果相同（取整数除法）。
    *   比较中间元素：
        *   如果 `array[mid] == target`：恭喜！找到目标值，返回 `mid`（目标元素的索引）。
        *   如果 `array[mid] < target`：目标值只可能在 `mid` 的右侧（因为数组升序）。将查找区间调整为右半部分：`left = mid + 1`。
        *   如果 `array[mid] > target`：目标值只可能在 `mid` 的左侧（因为数组升序）。将查找区间调整为左半部分：`right = mid - 1`。

3.  循环结束：
    *   如果循环结束（即 `left > right`），说明在整个数组中都没有找到目标值。返回一个特殊值（如 `-1`）表示未找到。

## 关键点图解

```
假设数组：[2, 5, 8, 12, 16, 23, 38, 56, 72, 91] (n=10, 索引0-9)
查找目标：23

初始状态： left=0, right=9
Step 1: mid = 0 + (9-0)//2 = 4 -> array[4]=16
    16 < 23 -> 目标在右侧 -> left = mid + 1 = 5
    当前区间: [23, 38, 56, 72, 91] (索引5-9)

Step 2: left=5, right=9
    mid = 5 + (9-5)//2 = 5 + 2 = 7 -> array[7]=56
    56 > 23 -> 目标在左侧 -> right = mid - 1 = 6
    当前区间: [23, 38] (索引5-6)

Step 3: left=5, right=6
    mid = 5 + (6-5)//2 = 5 + 0 = 5 -> array[5]=23
    23 == 23 -> 找到目标！返回索引 5。
```

## 时间复杂度：O(log n)

*   这是二分查找最强大的优势。
*   为什么是 O(log n)?
    *   每次比较都将搜索范围缩小一半。
    *   最坏情况下，需要缩小多少次范围直到只剩下一个元素（或空）？答案是 log₂(n) 次（以2为底的对数）。
    *   例如：n=1024 -> 最多需要 10 次比较 (2¹⁰ = 1024)。n=1000000 -> 最多需要约 20 次比较 (2²⁰ ≈ 1,000,000)。
    *   相对于线性查找的 O(n)，在大型数据集上效率提升巨大。

## 空间复杂度：O(1)

*   算法只使用了常数级别的额外空间（`left`, `right`, `mid` 等几个变量），与输入数组大小 `n` 无关。

## 优缺点

*   优点：
    *   极其高效： O(log n) 的时间复杂度在大型有序数据集上优势非常明显。
    *   概念清晰： 算法逻辑相对简单易懂。
*   缺点：
    *   依赖有序数组： 这是最大的限制。如果数组无序，必须先排序（排序本身通常需要 O(n log n) 时间），这可能抵消二分查找的优势，或者数组本身需要频繁插入/删除元素导致难以维护有序性。
    *   仅适用于顺序存储结构： 主要适用于数组（或能通过索引随机访问的类似结构）。链表不适合，因为无法在常数时间内访问任意索引的元素。

## 实际应用

二分查找不仅仅是找一个数，其思想广泛应用于各种需要高效搜索的场景：

1.  在排序数组中查找元素： 最直接的用途。
2.  查找边界值： 变种问题，如查找第一个等于目标值的元素、最后一个等于目标值的元素、第一个大于等于目标值的元素、最后一个小于等于目标值的元素等。这些变种在实现时循环条件和指针更新略有不同。
3.  数值计算中的近似解： 例如求平方根、立方根，在满足一定精度的解空间内进行二分查找。
4.  系统库函数： 许多编程语言的标准库中都实现了二分查找或其变种（如 C++ 的 `std::binary_search`, `std::lower_bound`, `std::upper_bound`；Java 的 `Arrays.binarySearch`；Python 的 `bisect` 模块）。
5.  数据库索引： 数据库的 B/B+ 树索引结构利用了类似二分查找的思想进行快速数据检索。
6.  游戏和图形： 在排序的数据（如碰撞检测中的空间划分结构、动画关键帧）中快速查找。

## 总结

二分查找法是一种基于有序数组的、利用分治思想的经典搜索算法。

其核心在于通过比较中间元素的值，每次排除一半不可能的搜索区间，从而将时间复杂度降低到非常高效的 O(log n)。

理解其原理、前提条件（有序）、实现步骤（指针更新、循环条件）以及时间复杂度分析是掌握该算法的关键。

虽然它要求数据有序，但在满足这个条件的场景下，它是搜索问题的首选高效解决方案。

# c 语言例子

```c
#include <stdio.h>

// 二分查找函数
int binary_search(int arr[], int size, int target) {
    int left = 0;             // 搜索区间的左边界
    int right = size - 1;     // 搜索区间的右边界
    
    // 当左边界 <= 右边界时继续搜索
    while (left <= right) {
        // 防止整数溢出的中间位置计算
        int mid = left + (right - left) / 2;
        
        // 找到目标值，返回索引
        if (arr[mid] == target) {
            return mid;
        }
        // 如果中间值小于目标值，搜索右半部分
        else if (arr[mid] < target) {
            left = mid + 1;
        }
        // 如果中间值大于目标值，搜索左半部分
        else {
            right = mid - 1;
        }
    }
    
    // 未找到目标值
    return -1;
}
```

# leetcode 经典题目

## 可以解决哪些问题？

| **问题类型**               | **核心技巧**                              | **经典例题**                     |
|----------------------------|------------------------------------------|----------------------------------|
| 基础查找                   | 区间定义（左闭右闭/左闭右开）             | LeetCode 704                    |
| 插入位置                   | 利用 `left` 指针返回位置                  | LeetCode 35                     |
| 重复元素边界               | 两次二分分别找左右边界                    | LeetCode 34                     |
| 旋转数组                   | 判断 `mid` 所在段，引入 `±inf` 调整比较   | LeetCode 33, 153                |
| 山脉数组                   | 先找峰值，再分段二分                      | LeetCode 852, 1095              |
| 缺失元素                   | 利用索引与值的差值二分                    | 剑指 Offer 53-II, LeetCode 1539 |
| 二维矩阵/局部峰值          | 坐标映射或利用局部单调性                  | LeetCode 74, 162                |

二分查找的核心是 **循环不变量规则**：保持区间定义一致，边界处理需严格。

更多变种问题可参考 [LeetCode 二分查找专题](https://leetcode.cn/tag/binary-search/problemset/)。

后续我们来针对实际题目练习二分。

# 小结

希望本文对你有帮助，如果有其他想法的话，也可以评论区和大家分享哦。

各位极客的点赞收藏转发，是老马持续写作的最大动力！

下一节我们将讲解一下二叉查询树，感兴趣的小伙伴可以关注一波，精彩内容，不容错过。

# 参考资料

- 顺序查找

https://www.cnblogs.com/yw09041432/p/5908444.html

https://www.jb51.net/article/53863.htm

https://blog.csdn.net/jiandanokok/article/details/50517837

- 二分查找

[二分搜索算法](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)

https://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html

* any list
{:toc}
