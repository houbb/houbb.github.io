---
layout: post
title: test 系统学习-04-test converate 测试覆盖率 jacoco 原理介绍
date:  2018-06-23 16:18:11 +0800
categories: [Test]
tags: [test, sh]
published: true
---

# 测试覆盖率

测试覆盖率(test coverage)是衡量软件测试完整性的一个重要指标。掌握测试覆盖率数据，有利于客观认识软件质量，正确了解测试状态，有效改进测试工作。

当然，要发挥这些作用，前提是我们掌握了真实的测试覆盖率数据。通常这并不是一件很直接的事情。

## 如何度量

那么，如何度量测试覆盖率呢？

在度量测试覆盖率之前，我们需要明确测试覆盖率的定义。毕竟，不同的定义会产生完全不同的覆盖率数据。

这里，我基于个人认知和经验，总结三种最常见的测试覆盖率定义及度量方法。

### 代码覆盖率

最著名的测试覆盖率就是代码覆盖率。这是一种面向软件开发和实现的定义。它关注的是在执行测试用例时，有哪些软件代码被执行到了，有哪些软件代码没有被执行到。被执行的代码数量与代码总数量之间的比值，就是代码覆盖率。

这里，根据代码粒度的不同，代码覆盖率可以进一步分为源文件覆盖率，类覆盖率，函数覆盖率，分支覆盖率，语句覆盖率等。它们形式各异，但本质是相同的。

如何度量代码覆盖率呢？一般可以通过第三方工具完成。不同编程语言，有不同的工具。

例如Java语言有Jacoco，Go语言有GoCov，Python语言有Coverage.py。

这些度量工具有个特点，那就是它们一般只适用于白盒测试，尤其是单元测试。对于黑盒测试(例如功能测试/系统测试)来说，度量它们的代码覆盖率则相对困难多了。

主流编程语言一般都有现成的单元测试工具，拿过来稍作配置即可使用。但是，如果想更进一步去了解这些工具背后的实现原理，就需要花费一些功夫了。

以Python覆盖率工具Coverage.py为例，它包括执行，分析和生成报告三大模块。最核心的执行模块依赖Python内置的trace函数。这是一个由Python解释器提供的，当每一行Python代码被执行时所激活的函数。

基于trace函数，我们可以得到每一行被执行的代码所在的文件和行数。然后，结合软件源代码，我们就可以分析出测试的代码覆盖情况，最后生成覆盖报告。

对于黑盒测试，例如功能测试/集成测试/系统测试等来说，测试用例通常是基于软件需求而不是软件实现所设计的。

因此，度量这类测试完整性的手段一般是需求覆盖率，即测试所覆盖的需求数量与总需求数量的比值。

### 需求覆盖率

视需求粒度的不同，需求覆盖率的具体表现也有不同。例如，系统测试针对的是比较粗的需求，而功能测试针对的是比较细的需求。当然，它们的本质是一致的。

如何度量需求覆盖率呢？通常没有现成的工具可以使用，而需要依赖人工计算，尤其是需要依赖人工去标记每个测试用例和需求之间的映射关系。

对于黑盒测试来说，由于测试是基于用户场景而不是软件实现设计的。因此，这个时候去度量软件代码覆盖率，其意义并不显著，至少是不如需求覆盖率的。

代码覆盖率和需求覆盖率有一个共同点，即它们都是面向测试过程的指标。因此有个不足之处，即覆盖率数据可能无法完全反映真实的测试状态和水平。

对于代码覆盖率来说，广为诟病的一点就是100%的代码覆盖率并不能说明代码就被完全覆盖没有遗漏了。因为代码的执行顺序和函数的参数值，都可能是千变万化的。一种情况被覆盖到，不代表所有情况被覆盖到。

对于需求覆盖率来说，100%的覆盖率也不能说“万事大吉”。因为需求可能有遗漏或存在缺陷，测试用例与需求之间的映射关系，尤其是用例是否真正能够覆盖对应的测试需求，也可能是存在疑问的。

### 缺陷覆盖率

测试的目的是发现软件缺陷。因此，衡量测试完整性的终极指标应该是面向测试结果的缺陷覆盖率，即测试所实际发现的缺陷数量与测试所应该发现的缺陷总量的比值。

软件测试一般是分为多个测试阶段的。每个阶段有每个阶段的任务。对于当前测试阶段来说，在后续阶段发现的缺陷中，属于当前阶段(而不是更早阶段)遗漏出去的缺陷是我们需要重点关注的。

虽然讨论缺陷覆盖率有一种“事后诸葛亮”的感觉，但是它的意义是不容忽视的。一方面它提供了评价某一阶段测试工作成效的重要指标，另一方面它为我们改进测试工作提供了重要参考。例如，针对每一个遗漏缺陷深入挖掘，举一反三，可以避免同类问题在未来再次发生。

总结一下，这里介绍了三种常见的测试覆盖率的定义和度量方法，分别是代码覆盖率，需求覆盖率和缺陷覆盖率。它们适用于不同的场景，有各自的优势与不足。需要注意的是，它们不是互相排斥，而是相互补充的。

# JAVA覆盖率工具介绍

市场上java主要代码覆盖率工具：EMMA、JaCoCo

总结一下个人对JaCoCo优势的理解：

（1）JaCoCo支持分支覆盖、引入了Agent模式。

（2）EMMA官网已经不维护了，JaCoCo是其团队开发的，可以理解为一个升级版。

（3）JaCoCo社区比较活跃，官网也在不断的维护更新。

我们前期使用的EMMA，也做了全量、差异覆盖率，和精准耦合也结合在了一起，但后来考虑到JaCoCo的优势，也就全部切换了过来。

## JaCoCo 简述

JaCoCo 是一个开源的覆盖率工具(官网地址：http://www.eclemma.org/JaCoCo/)，它针对的开发语言是java，其使用方法很灵活，可以嵌入到Ant、Maven中；可以作为Eclipse插件，可以使用其JavaAgent技术监控Java程序等等。

很多第三方的工具提供了对JaCoCo的集成，如sonar、Jenkins等。

JaCoCo包含了多种尺度的覆盖率计数器,包含指令级覆盖(Instructions,C0coverage)，分支（Branches,C1coverage）、圈复杂度(CyclomaticComplexity)、行覆盖(Lines)、方法覆盖(non-abstract methods)、类覆盖(classes)，后面会一一介绍。

我们先看看其覆盖率结果展现如下图1-1所示，方便读者先有一个大概的了解。

##  JaCoCo 基本概念

行覆盖率：度量被测程序的每行代码是否被执行，判断标准行中是否至少有一个指令被执行。

类覆盖率：度量计算class类文件是否被执行。

分支覆盖率：度量if和switch语句的分支覆盖情况，计算一个方法里面的

总分支数，确定执行和不执行的分支数量。

方法覆盖率：度量被测程序的方法执行情况，是否执行取决于方法中是否有至少一个指令被执行。

指令覆盖：计数单元是单个java二进制代码指令，指令覆盖率提供了代码是否被执行的信息，度量完全独立源码格式。

圈复杂度：在（线性）组合中，计算在一个方法里面所有可能路径的最小数目，缺失的复杂度同样表示测试案例没有完全覆盖到这个模块。

![输入图片说明](https://images.gitee.com/uploads/images/2020/0915/141601_59ef4a47_508704.png)

这个图包含了几种不同的收集覆盖率信息的方法，每种方法的实现方法都不一样，带颜色的部分是JaCoCo比较有特色的地方。

上面各个名次含义（带颜色的为JaCoCo支持）：

![输入图片说明](https://images.gitee.com/uploads/images/2020/0915/141626_213957f9_508704.png)

上表JaCoCo支持的部分，再详细的解释下：

## 插桩模式

（1）JaCoCo在Byte Code时使用的ASM技术修改字节码方法，可以修改Jar文件、class文件字节码文件。

（2）JaCoCo同时支持on-the-fly和offline的两种插桩模式。

### On-the-fly插桩：

JVM中通过-javaagent参数指定特定的jar文件启动Instrumentation的代理程序，代理程序在通过Class Loader装载一个class前判断是否转换修改class文件，将统计代码插入class，测试覆盖率分析可以在JVM执行测试代码的过程中完成。

### Offline模式：

在测试前先对文件进行插桩，然后生成插过桩的class或jar包，测试插过桩的class和jar包后，会生成动态覆盖信息到文件，最后统一对覆盖信息进行处理，并生成报告。

### 对比

On-the-fly和offline比较：

On-the-fly模式更方便简单进行代码覆盖分析，无需提前进行字节码插桩，无需考虑classpath 的设置。

存在如下情况不适合on-the-fly，需要采用offline提前对字节码插桩：

（1）运行环境不支持java agent。

（2）部署环境不允许设置JVM参数。

（3）字节码需要被转换成其他的虚拟机如Android Dalvik VM。

（4）动态修改字节码过程中和其他agent冲突。

（5）无法自定义用户加载类。

# java方法控制流分析

JaCoCo是如何在字节码注入的？

我们带着疑问来看下面的内容：

先举个实例，有个java方法：

![输入图片说明](https://images.gitee.com/uploads/images/2020/0915/141845_6043906f_508704.png)

编译后转换成字节码后，内容如下：

![输入图片说明](https://images.gitee.com/uploads/images/2020/0915/141904_471e34b7_508704.png)

我们知道JaCoCo是字节码注入方式，它是通过一个Probe探针的方式来注入的，具体如下：

探针是字节指令集插入到java方法中，程序执行后可以被记录，它不会改变原有代码的行为。

我们看看探针前后插入比较：

![输入图片说明](https://images.gitee.com/uploads/images/2020/0915/141928_7801f67b_508704.png)

颜色的部分就是探针注入的地方。

JaCoCo是根据控制流Type来采用不同的探针插入策略的。

一个用java字节码定义的java方法的控制流图可能有以下的type，每一个type连接一个源指令与目标指令,type不同探针的注入策略也会不同，如下是type定义：

![输入图片说明](https://images.gitee.com/uploads/images/2020/0915/141951_fd98a395_508704.png)

探针不改变该方法的行为，但记录他们已被执行的事实，从理论上讲，可以在控制流图的每一个边插入一个探针，作为探针实现本身需要多个字节码指令，这将增加几倍的类文件的大小和执行速度。

事实上，只需要一个几个探头，根据每个方法的控制流的方法，下面说明了如何在不同的边缘类型的情况下添加额外的指令：

![输入图片说明](https://images.gitee.com/uploads/images/2020/0915/142020_58f8a482_508704.png "屏幕截图.png")
![输入图片说明](https://images.gitee.com/uploads/images/2020/0915/142031_033feaff_508704.png "屏幕截图.png")

# 参考资料

[iOS 覆盖率检测原理与增量代码测试覆盖率工具实现](https://www.jianshu.com/p/0431b23adba3)

[聊聊度量测试覆盖率的几种方式](https://zhuanlan.zhihu.com/p/73521606)

[伊斯坦布尔测试覆盖率的实现原理](https://segmentfault.com/a/1190000019817317)

[测试覆盖率](https://www.cnblogs.com/surewing/p/12587909.html)

* any list
{:toc}