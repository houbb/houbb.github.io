---
layout: post
title:  【leetcode】力扣刷题之时间复杂度介绍 Time Complexity
date:  2020-6-8 15:13:08 +0800
categories: [Algorithm]
tags: [algorithm, tips, leetcode]
published: true
---

## 1. 核心概念：什么是时间复杂度？

*   定义： 时间复杂度衡量的是一个算法执行所需的时间如何随输入数据规模（通常用 `n` 表示）的增长而增长。它不是计算算法运行的具体秒数（这取决于硬件、编程语言、编译器优化等），而是描述运行时间随输入规模 `n` 变化的趋势。
*   目的：
    *   比较算法优劣： 在解决同一问题时，不同算法可能有不同的时间效率。时间复杂度提供了一个理论框架来比较它们，帮助我们选择更高效的算法，尤其是在处理大规模数据时。
    *   预测性能： 了解算法的时间复杂度，可以帮助我们预估当输入规模 `n` 增大时（例如从 1000 条数据到 100 万条数据），算法执行时间会如何变化。这对于系统设计和性能优化至关重要。
    *   分析算法瓶颈： 识别算法中耗时最多的部分，指导优化方向。
*   核心思想： 忽略常数因子和低阶项，关注最高阶项。 因为当 `n` 变得非常大时，最高阶项对运行时间增长的影响起主导作用。

## 2. 大 O 表示法 (Big O Notation)

这是描述时间复杂度最常用的数学符号，表示渐进上界。它描述了算法运行时间在最坏情况下的增长级别（或增长率）。

*   定义： 我们说一个算法的时间复杂度是 `O(f(n))`，如果存在正常数 `c` 和 `n0`，使得当 `n >= n0` 时，算法的运行时间 `T(n)` 满足 `T(n) <= c * f(n)`。
    *   `T(n)`: 算法在输入规模为 `n` 时的实际运行时间（或基本操作次数）。
    *   `f(n)`: 一个描述增长率的函数（如 `n`, `n²`, `log n`）。
    *   `c`: 一个常数因子。
    *   `n0`: 一个输入规模阈值，当 `n` 大于这个值时，不等式成立。
*   含义： `O(f(n))` 表示算法的运行时间增长率不会超过 `f(n)` 的增长率（乘以某个常数因子）。它关注的是最坏情况或增长的上限。

## 3. 常见的时间复杂度等级（从快到慢）

以下是算法中最常遇到的时间复杂度等级，按照效率从高到低（增长速度从慢到快）排列：

1.  O(1) - 常数时间 (Constant Time):
    *   含义： 算法的运行时间与输入规模 `n` 无关。无论输入数据有多大，执行时间都是固定的。
    *   例子：
        *   访问数组中的单个元素（通过索引）`arr[i]`。
        *   在哈希表中插入或查找一个元素（理想情况下，无冲突）。
        *   执行一次算术运算（如 `a + b`）。
        *   链表/栈/队列的插入或删除操作（如果已知确切位置，如头/尾）。
    *   图形： 一条水平直线。

2.  O(log n) - 对数时间 (Logarithmic Time):
    *   含义： 算法的运行时间随着输入规模 `n` 的增长而增长，但增长得非常缓慢。运行时间大致是 `n` 的对数（通常底数为 2）。
    *   特点： 算法通常通过每次操作将问题规模减半（或按比例减少）来工作。
    *   例子：
        *   二分查找 (Binary Search): 在已排序的数组中查找元素。每次比较都能排除一半的元素。
        *   在平衡二叉搜索树（如 AVL 树、红黑树）中查找、插入或删除元素。
        *   某些分治算法（如快速排序的理想情况下的划分，但快速排序平均是 O(n log n)，最坏是 O(n²)）。
    *   图形： 一条非常平缓上升的曲线（增长极慢）。

3.  O(n) - 线性时间 (Linear Time):
    *   含义： 算法的运行时间与输入规模 `n` 成正比。如果 `n` 翻倍，运行时间也大致翻倍。
    *   特点： 算法通常需要对输入数据中的每个元素执行一次（或常数次）操作。
    *   例子：
        *   在无序数组中查找最大值或最小值（需要遍历整个数组）。
        *   计算数组中所有元素的和（需要遍历整个数组）。
        *   遍历链表的所有节点。
        *   线性搜索（在无序数组中查找特定元素 - 最坏情况）。
    *   图形： 一条斜率为正的直线。

4.  O(n log n) - 线性对数时间 / 准线性时间 (Linearithmic Time):
    *   含义： 运行时间比 O(n) 慢一些，但比 O(n²) 快很多。它是许多高效排序算法的复杂度。
    *   特点： 通常出现在结合了线性操作和分治策略（每次将问题分成子问题，解决子问题后再合并结果）的算法中。
    *   例子：
        *   归并排序 (Merge Sort)
        *   堆排序 (Heap Sort)
        *   快速排序 (Quick Sort) 的平均情况（最坏情况是 O(n²)）。
        *   许多高效的比较排序算法的下限。
    *   图形： 一条比 O(n) 曲线更陡峭一些的曲线，但仍远低于 O(n²)。

5.  O(n²) - 平方时间 (Quadratic Time):
    *   含义： 算法的运行时间与输入规模 `n` 的平方成正比。如果 `n` 翻倍，运行时间大约变为原来的 4 倍。
    *   特点： 通常出现在包含嵌套循环的算法中，内层循环的次数与 `n` 相关。
    *   例子：
        *   冒泡排序 (Bubble Sort)
        *   选择排序 (Selection Sort)
        *   插入排序 (Insertion Sort) （最坏和平均情况）。
        *   检查一个数组中的所有元素对（如计算所有点对之间的距离）。
    *   图形： 一条抛物线（增长较快）。

6.  O(nᶜ) - 多项式时间 (Polynomial Time) (c > 2):
    *   含义： 运行时间是输入规模 `n` 的某个常数 `c` 次幂（c > 2）。例如 O(n³), O(n⁴) 等。
    *   特点： 效率通常较低，尤其是当 `n` 较大时。
    *   例子：
        *   三层嵌套循环（O(n³)），如朴素矩阵乘法。
        *   某些动态规划问题（如果状态维度较高）。
    *   图形： 比 O(n²) 更陡峭的曲线（增长非常快）。

7.  O(2ⁿ) - 指数时间 (Exponential Time):
    *   含义： 运行时间随着输入规模 `n` 的增长呈指数级增长（翻倍增长）。即使 `n` 稍微增大一点，运行时间也会急剧增加，变得完全不实用。
    *   特点： 通常出现在需要穷举所有可能性的算法中。
    *   例子：
        *   解决旅行商问题 (TSP) 的暴力穷举法（检查所有可能的路径）。
        *   某些递归算法（如朴素地计算斐波那契数列 `F(n) = F(n-1) + F(n-2)`，没有优化）。
    *   图形： 一条急剧上升的曲线（增长极其迅速）。

8.  O(n!) - 阶乘时间 (Factorial Time):
    *   含义： 运行时间随着输入规模 `n` 的增长呈阶乘级增长。这是效率最低的常见复杂度之一。
    *   特点： 出现在需要穷举所有排列或组合的算法中。
    *   例子：
        *   暴力破解密码（尝试所有可能的字符组合）。
        *   生成集合的所有可能排列。
    *   图形： 一条比指数时间更陡峭的曲线（增长最快）。

## 4. 如何分析一个算法的时间复杂度？

1.  识别基本操作： 找出算法中执行次数最多的、最耗时的核心操作（如比较、赋值、算术运算、函数调用等）。这个操作的执行次数通常决定了时间复杂度。
2.  计算执行次数： 分析这个基本操作的执行次数 `T(n)` 如何依赖于输入规模 `n`。这通常需要：
    *   分析循环结构（特别是嵌套循环的层数和每层循环的次数）。
    *   分析递归结构（建立递归方程并求解）。
    *   考虑最好、最坏和平均情况（通常最坏情况或平均情况用大 O 表示）。
3.  用大 O 表示： 将计算出的 `T(n)` 表达式进行简化：
    *   忽略常数项： 例如，`T(n) = 3n² + 2n + 10` -> 只关心 `n²`。
    *   忽略低阶项： 例如，`T(n) = n² + n log n + n` -> 只关心最高阶项 `n²`。
    *   忽略常数系数： 例如，`T(n) = 5n²` -> 表示为 `O(n²)`。
    *   保留最高阶项： 简化后的结果就是算法的时间复杂度 `O(f(n))`。

## 5. 关键点与注意事项

*   关注趋势，而非精确值： 大 O 表示法描述的是运行时间增长的趋势，而不是精确的运行时间。
*   最坏情况 vs 平均情况：
    *   最坏情况时间复杂度 (Worst-case Time Complexity)： 对任何大小为 `n` 的输入，算法运行时间的上界。这是最常用的分析指标，因为它能保证性能不会比这个更差。例如，插入排序的最坏情况（逆序数组）是 O(n²)。
    *   平均情况时间复杂度 (Average-case Time Complexity)： 对所有可能的大小为 `n` 的输入，算法运行时间的期望值。这通常更难计算，因为它需要知道输入数据的分布。例如，快速排序的平均情况是 O(n log n)，但最坏情况是 O(n²)。
    *   最好情况时间复杂度 (Best-case Time Complexity)： 对某些特定（通常有利）的大小为 `n` 的输入，算法运行时间的下界。通常意义不大（例如，冒泡排序在已排序数组上是 O(n)，但这不代表它高效）。
*   空间复杂度： 与时间复杂度类似，空间复杂度衡量的是算法执行过程中所需的额外内存空间随输入规模 `n` 的增长趋势，也用大 O 表示法描述。优化时常常需要在时间复杂度和空间复杂度之间进行权衡（Time-Space Tradeoff）。
*   实际影响： 理解时间复杂度对于处理大规模数据至关重要。一个 O(n²) 的算法在 `n=1000` 时可能需要 1 秒，但当 `n=1000000` 时，可能需要超过 11 天！而一个 O(n log n) 的算法在 `n=1000000` 时可能只需几秒到几分钟。
*   非比较排序： 如计数排序、桶排序、基数排序，它们利用输入数据的特定属性（如范围有限、可分解为数字位等），可以达到 O(n) 或 O(n + k) 的时间复杂度，但突破了基于比较排序的 O(n log n) 下限。它们有特定的适用场景。

## 总结

时间复杂度是算法分析的基石，它使用大 O 表示法来描述算法运行时间随输入规模增长而变化的渐进趋势。

通过理解常见的时间复杂度等级（O(1), O(log n), O(n), O(n log n), O(n²), O(2ⁿ), O(n!)）以及它们的含义和典型例子，我们可以：

1.  有效比较不同算法的效率。
2.  预测算法在处理大规模数据时的性能表现。
3.  为特定问题选择最合适的算法。
4.  识别代码中的性能瓶颈并进行优化。

掌握时间复杂度的概念和分析方法是成为高效程序员和算法工程师的必备技能。

# 参考资料


* any list
{:toc}