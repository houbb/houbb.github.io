---
layout: post
title: viterbi 算法：利用动态规划寻找最短路径
date:  2020-1-23 10:09:32 +0800
categories: [Data-Struct]
tags: [data-struct, algorithm, sh]
published: true
---

# 动态规划原理

基本思想：问题的最优解如果可以由子问题的最优解推导得到，则可以先求解子问题的最优解，在构造原问题的最优解；若子问题有较多的重复出现，则可以自底向上从最终子问题向原问题逐步求解。

## 使用条件

可分为多个相关子问题，子问题的解被重复使用

### Optimal substructure（优化子结构）：

一个问题的优化解包含了子问题的优化解

缩小子问题集合，只需那些优化问题中包含的子问题，降低实现复杂性

我们可以自下而上的

### Subteties（重叠子问题）

在问题的求解过程中，很多子问题的解将被多次使用。

## 动态规划算法的设计步骤：

分析优化解的结构

递归地定义最优解的代价

自底向上地计算优化解的代价保存之，并获取构造最优解的信息

根据构造最优解的信息构造优化解

## 动态规划特点：

把原始问题划分成一系列子问题；

求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间

自底向上地计算。

整体问题最优解取决于子问题的最优解（状态转移方程）（将子问题称为状态，最终状态的求解归结为其他状态的求解）

# 利用动态规划寻找最短路径

动态规划是运筹学的一个分支，是求解决策过程最优化的数学方法，通常情况下应用于最优化问题，这类问题一般有很多个可行的解，每个解有一个值，而我们希望从中找到最优的答案。

在计算机科学领域，应用动态规划的思想解决的最基本的一个问题就是：寻找有向无环图（篱笆网络）当中两个点之间的最短路径（实际应用于地图导航、语音识别、分词、机器翻译等等）。

下面举一个比较简单的例子做说明：求S到E的最短路径。

如下图（各点之间距离不相同）：

![image](https://user-images.githubusercontent.com/18375710/72722971-99e37d00-3bba-11ea-9917-336d7cc4b8ff.png)

## 穷举法

我们知道，要找到S到E之间最短路径，最容易想到的方法就是穷举法。

也就是把所有可能的路径都例举出来。

从S走向A层共有4种走法，从A层走向B层又有4种走法，从B层走向C层又有4种走法，然后C层走向E点只有一种选择。

所以最终我们穷举出了4X4X4=64种可能。

显然，这种方法必定可行。

但在实际的应用当中，对于数量极其庞大的结点数和边数的图，其计算复杂度也将会变得非常大，而计算效率也会随之降低。

![image](https://user-images.githubusercontent.com/18375710/72723039-baabd280-3bba-11ea-8246-8b09e8feb740.png)

因此，这里选择使用一种基于动态规划的方式来寻找最佳路径。

所谓动态规划。

其核心就是“动态”的概念，**把大的问题细分为多个小的问题，基于每一步的结果再去寻找下一步的策略，通过每一步走过之后的局部最优去寻找全局最优。**

这样解释比较抽象，下面直接用回刚刚的例子说明。如下图：

## 最短路径是存在的

![image](https://user-images.githubusercontent.com/18375710/72723105-dca55500-3bba-11ea-8715-1fe0db18c55d.png)

首先，我们假设S到E之间存在一条最短路径（红色），且这条路径经过C2点，那么我们便一定能够确定从S到C2的64条（4X4X4=64）子路径当中，该子路径一定最短。

（证明：反证法。如果S到C2之间存在一条更短的子路径，那么便可以用它来代替原先的路径，而原先的路径显然就不是最短了，这与原假设自相矛盾）。

同理，我们也可以得出从S到B2点为两点间最短子路径的结论。

这时候，真相便慢慢浮出水面：

既然如此，我们计算从S点出发到点C2的最短路径，是不是只要考虑从S出发到B层所有节点的最短路径就可以了？

答案是肯定的！

因为，从S到E的“全局最短”路径必定经过在这些“局部最短”子路径。

没错！这就是上面提及到的通过局部最优的最优去寻找全局最优，问题的规模被不断缩小！

接下来，要揭晓答案了！继续看下图：

![image](https://user-images.githubusercontent.com/18375710/72723186-0b233000-3bbb-11ea-9bee-509f4e7c3b24.png)

回顾之前的分析：我们计算从S起到C2点的最短路径时候只需要考虑从S出发到B层所有节点的最短路径，B层也如是。

对B2来说，一共有4条路线可以到达，分别是A1→B2，A2→B2，A3→B2，A4→B2。

我们需要做的就是把A2→B2这条最短路线保留，而其他3条删除掉（因为根据以上的分析，它们不可能构成全程的最短路线）。

OK，来到这里，我们会发现一个小“漏洞”，这段S→A2→B2→C2→E的路线只是我一厢情愿的假设，最短路径不一定是经过以上这些点。

所以，我们要把每层的每个节点都考虑进来。

## 完整算法

以下是具体的做法：
step1：从点S出发。对于第一层的3个节点，算出它们的距离d（S,A1）,d（S,A2）,d（S,A3）,d（S,A4），因为只有一步，所以这些距离都是S到它们各自的最短距离。

step2：对于B层的所有节点（B1,B2,B3,B4），要计算出S到它们的最短距离。我们知道，对于特定的节点B2，从S到它的路径可以经过A层的任何一个节点（A1,A2,A3,A4）。对应的路径长就是d（S,B2）=d（S,Ai）+d（Ai,B2）（其中i=1,2,3,4）。由于A层有4个节点（即i有4个取值），我们要一一计算，然后找到最小值。这样，对于B层的每个节点，都需要进行4次运算，而B层有4个节点，所以共有4X4=16次运算。

step3：这一步是该算法的核心。我们从step2计算得出的结果只保留4个最短路径值（每个节点保留一个）。那么，若从B层走向C层来说，该步骤的基数已经不再是4X4，而是变成了4！也就是说，从B层到C层的最短路径只需要基于B层得出的4个结果来计算。这种方法一直持续到最后一个状态，每一步计算的复杂度为相邻两层的计算复杂度为4X4乘积的正比！再通俗点说，连接这两两相邻层的计算符合变成了“+”号，取代了原先的“X”号。用这种方法，只需进行4X4X2=32次计算！

其实上述的算法就是著名的维特比算法，事实上非常简单！

若假设整个网格的宽度为D，网格长度为N，那么若使用穷举法整个最短路径的算法复杂度为O（D^N），而使用这种算法的计算复杂度为O（ND^2）。

试想一下，若D与N都非常大，使用维特比算法的效率将会提高几个数量级！

## 代码实现

![image](https://user-images.githubusercontent.com/18375710/72723589-f4c9a400-3bbb-11ea-9934-2a6185c2b59d.png)

同样是实现从S到E的最短路径。不过这次把刚刚的情况简化了一下，原理是相同的。

```java
#include<stdlib.h> 
#include<stdio.h>  
#define x 9999
#define max 9999
int data[10][10];
int dist[10];//记录最短路径为多少
int path[10];//记录最短路径
int kmin(int,int);
void fpath(int a[][10]);
int froute(int a[][10]);
void main()
{
    int i,m;
    int a[10][10]=
  {
    {x,4,2,3,x,x,x,x,x,x}, 
    {x,x,x,x,10,9,x,x,x,x},
    {x,x,x,x,6,7,10,x,x,x},
    {x,x,x,x,x,3,8,x,x,x},
    {x,x,x,x,x,x,x,4,8,x},
    {x,x,x,x,x,x,x,9,6,x},
    {x,x,x,x,x,x,x,5,4,x},
    {x,x,x,x,x,x,x,x,x,8},
    {x,x,x,x,x,x,x,x,x,4},
    {x,x,x,x,x,x,x,x,x,x}
  };
    /*for (i=0;i<10;i++)
    {
    for(j=0;j<10;j++)
    printf("%d ",a[i][j]);
    printf("\n"); 
    }*/
    fpath(a);
      printf("最短路径大小为: %d\n",dist[9]);

    m=froute(a);
    for(i=m-1;i>=0;i--)
      printf("最短路径经过: %d\n",path[i]);
    }
    void fpath(int a[][10])
    {
      int i,j,k;42 dist[0]=0;
      for(i=1;i<10;i++)
      {
        k=max;
        for(j=0;j<i;j++)
        {
          if(a[j][i]!=x)
            if((dist[j]+a[j][i])<k)
            k=dist[j]+a[j][i];  
        } 
      dist[i]=k;
      }
    }
    int froute(int a[][10])
    {
     int j,b,k=1,i=9;
     path[0]=10;
     while(i>0)
     {
      for(j=i-1;j>=0;j--)
      { 
       if(a[j][i]!=x)
       {
        b=dist[i]-a[j][i];
        if(b==dist[j])
        {
          path[k++]=j+1;
          i=j; 
          break;
        }
      }
    } 
  }
  return k;
}
```


# 设计最短路径的动态规划算法

算法导论中一般将设计动态规划算法归纳为下面几个步骤：

1）分析最优解的结构

2）递归定义最优解的值

3）自底向上计算最优解的值

4）从计算的最优解的值上面构建出最优解

## 最短路径的结构

从最优解的结构开始分析(我们假设没有权值为负的路径),对于图 `G<V,E>` 的所有结点对最短路径的问题，我们能知道一条最短路径的子路径都是最短路径。

假设用邻接矩阵W=w(ij)来表示输入带权图,考虑从结点i到结点j的一条最短路径p，如果p最多有m(m为有限值)条边。

若i=j，则p的权值为0而且不包含其他边。

若i ≠ j，可以将i到j的路径转换为i -> k、k->j。

## 给定一个有向图

### 有向图

![image](https://user-images.githubusercontent.com/18375710/72721509-3015a400-3bb7-11ea-81ea-f87bdaaea1fe.png)

### 邻接矩阵

我们可以给出这个有向图的邻接矩阵

![image](https://user-images.githubusercontent.com/18375710/72721534-44f23780-3bb7-11ea-9fcd-eb21743ea66d.png)

# 参考资料

[动态规划实现最短路径问题](https://blog.csdn.net/qq_40148886/article/details/86154237)

[如何理解动态规划？](https://www.zhihu.com/question/39948290)

[【算法复习】动态规划](https://www.cnblogs.com/hithongming/p/9229871.html)

https://www.jianshu.com/p/3b6569cefd0e

[动态规划的特点及其应用](https://it.dgzx.net/drkt/oszt/zltk/yxlw/dongtai1.htm)

* any list
{:toc}