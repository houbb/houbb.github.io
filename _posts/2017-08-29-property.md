---
layout: post
title:  Java Property
date:  2017-08-29 20:15:38 +0800
categories: [Java]
tags: [java, property]
published: true
---

# Property 

简单记录一下，便于明天查阅。

为了测试方便，新建一个简单 Java 项目。目录结构如下：

```
.
├── a.properties
├── out
│   └── production
│       └── property
│           ├── Main.class
│           └── com
│               └── ryo
│                   └── property
│                       ├── ReadProperty.class
│                       ├── WriteProperty.class
│                       └── a.properties
├── property.iml
└── src
    ├── Main.java
    └── com
        └── ryo
            └── property
                ├── ReadProperty.java
                ├── WriteProperty.java
                └── a.properties
```

- src/.../a.properties

```
name=class
age=10
```

- /a.properties

```
name=root
age=10
```


# Read

## 固定路径

直接写出配置文件的全路径。

- easyRead()

```java
private static InputStream easyRead() throws FileNotFoundException {
    InputStream inputStream = new FileInputStream("/Users/houbinbin/IT/fork/property/a.properties");
    return inputStream;
}
```

- main()

```java
/**
 * @since 1.7
 * @param args
 * @throws IOException
 */
public static void main(String[] args) throws IOException {
    try(InputStream inputStream = easyRead()) {
        Properties properties = new Properties();
        properties.load(inputStream);
        String name = properties.getProperty("name");
        System.out.println(name);

        commonRead();
    }
}
```

- output

```
root
```

## 常用方式

上一种方式虽然简单明了，但是有一个缺陷，在不同的环境下(如换个文件夹)，可能结果就不正确了。所以我们一般需要相对路径。

- commonRead()

此方法读取在根目录下的配置文件。

```java
private static InputStream commonRead() throws IOException {
    InputStream inputStream = new FileInputStream("a.properties");
    return inputStream;
}
```

- main()

`easyRead()` 替换为 `commonRead()`

- output

```
root
```

## class 读取

还有一种方式是根据 class 来读取。此时去读的路径在是根据当前类编译后的 `class` 文件路径决定。

对应上述目录结构中的这一段：

```
├── out
│   └── production
│       └── property
│           ├── Main.class
│           └── com
│               └── ryo
│                   └── property
│                       ├── ReadProperty.class
│                       ├── WriteProperty.class
│                       └── a.properties
```

- classRead()

```java
private static InputStream classRead() {
    InputStream inputStream = ReadProperty.class.getResourceAsStream("a.properties");
    return inputStream;
}
```

- main()

`easyRead()` 替换为 `classRead()`

- output

```
class
```


# Write


上面介绍了对于配置文件的读取，我们继续看下对于配置文件的写入。

## 内存写

```java
public static void main(String[] args) throws IOException {
    final String filePath = "/Users/houbinbin/IT/fork/property/a.properties";
    try(InputStream inputStream = new FileInputStream(filePath)) {
        Properties properties = new Properties();
        properties.load(inputStream);
        properties.setProperty("name", "newName");
        String name = properties.getProperty("name");
        System.out.println(name);
    }
}
```

- output

```
newName
```

此时去查看配置文件内容，其实是没有变化的。我们只是修改了内存中对应的属性值。

如果想让修改的值持久保存在文件中，怎么办呢？

## 文件写

```java
final String filePath = "/Users/houbinbin/IT/fork/property/a.properties";
try(InputStream inputStream = new FileInputStream(filePath);
    OutputStream outputStream = new FileOutputStream(filePath)) {
    Properties properties = new Properties();
    properties.load(inputStream);
    properties.setProperty("name", "newName");  //内存修改
    properties.store(outputStream, "this is update comment");   //文件修改
}
```

然后去看下配置文件。

- a.properties

```properties
#this is update comment
#Tue Aug 29 20:32:13 CST 2017
name=newName
```

等等，我的 age 信息怎么不见了？

其实看下 JDK 源码就知道了。如下：

```java
/**
 * Creates a file output stream to write to the file with the specified
 * name.  If the second argument is <code>true</code>, then
 * bytes will be written to the end of the file rather than the beginning.
 * A new <code>FileDescriptor</code> object is created to represent this
 * file connection.
 * <p>
 * First, if there is a security manager, its <code>checkWrite</code>
 * method is called with <code>name</code> as its argument.
 * <p>
 * If the file exists but is a directory rather than a regular file, does
 * not exist but cannot be created, or cannot be opened for any other
 * reason then a <code>FileNotFoundException</code> is thrown.
 *
 * @param     name        the system-dependent file name
 * @param     append      if <code>true</code>, then bytes will be written
 */
public FileOutputStream(String name, boolean append)
    throws FileNotFoundException{
    this(name != null ? new File(name) : null, append);
}

public FileOutputStream(String name) throws FileNotFoundException {
    this(name != null ? new File(name) : null, false);
}
```

1. 我们直接调用的话，是默认不添加的。(会导致直接文件清空)。

2. 我们此时的输入流也没有关闭，所以才造成了上述的情况。正确的姿势如下：

```java
final String filePath = "/Users/houbinbin/IT/fork/property/a.properties";
InputStream inputStream = new FileInputStream(filePath);

Properties properties = new Properties();
properties.load(inputStream);
inputStream.close();    //提前关闭输入流对象

OutputStream outputStream = new FileOutputStream(filePath);
properties.setProperty("name", "newName");//内存修改
properties.store(outputStream, "this is update comment");
outputStream.close();
```


- a.properties

```properties
#this is update comment
#Tue Aug 29 20:39:56 CST 2017
age=10
name=newName
```








* any list
{:toc}












