---
layout: post
title: Docker learn-09-Docker 与 LXC
date:  2019-12-18 11:34:23 +0800
categories: [Docker]
tags: [docker, windows, devops, sh]
published: true
---

# Docker在LXC基础上做了什么

LXC，一般指Linux Container，即内核容器技术的简称。

Docker在内核容器技术上做了什么工作，简单的说，Docker在内核容器技术（Cgroup和Namespace）的基础上，提供了一个更高层的控制工具，该工具包含以下特性：

## 1、跨主机部署。

Docker定义镜像格式，该格式将应用程序和其所依赖的文件打包到同一个镜像文件中，从而使其在转移到任何运行Docker的机器中时都可以运行，并能保证在任何机器中该应用程序执行的环境都是一样的。

LXC实现了“进程沙盒”，这一重要特性是跨主机部署的前提条件，但是只有这一点是不够的，比如，在一个特定的LXC配置下执行应用程序，将该应用程序打包并拷贝到另一个LXC环境下，程序很有可能无法正常执行，因为该程序的执行依赖该机器的特定环境配置，包括网络、存储、发行版等。

而Docker则将上述相关配置进行抽象并与应用程序一同打包，所以可以保证在不同硬件、不同配置的机器上Docker容器中运行的环境和其所依赖的环境配置是一样的。

## 2、以应用为中心。

Docker为简化应用程序的部署过程做了很多优化，这一目的在Docker的API、用户接口、设计哲学和用户文档中都有体现。其Dockerfile机制大大简化和规范了应用的部署方法。

## 3、自动构建。

Docker提供了一套能从源码自动构建镜像的工具。该工具可以灵活地使用make、maven、chef、pupper、salt、RPM和源码包等形式，将应用程序的依赖、构建工具和安装包进行打包处理，而且当前机器的配置不会影响镜像的构建过程。

## 4、版本管理。

Docker提供了类似于Git的版本管理功能，支持追踪镜像版本，检验版本更新、提交新的版本改动和回退版本等功能。

镜像的版本信息中包括制作方式和制作者信息，因此可以从生产环境回溯到上游开发人员。

Docker同样实现了镜像的增量上传和下载的功能，用户可以通过获取新旧版本直接新增的镜像层来更新镜像版本，而不必下载完整镜像，类似于Git的pull命令。

## 5、组件重用。

任何容器都可以用作生成另一个组件的基础镜像。这一过程可以手动执行，也可以写入自动化构建脚本。

例如，可以创建一个包含Python开发环境的镜像，并将其作为基础镜像部署其他使用Python环境进行开发的应用程序。

## 6、共享。

Docker用户可以访问公共的镜像Registry

## 7、工具生态链。

# Docker容器和虚拟机之间有什么不同

## 容器与虚拟机是互补的。

虚拟机是用来进行硬件划分的完美解决方案，它利用了硬件虚拟化技术，例如VT-x，AMD-V会同时通过一个hypervisor层来实现对资源的隔离；

而容器则是操作系统级别的虚拟化，利用的是内核的Cgroup和NameSpace特性，此功能完全通过软件来实现，仅仅是进程本身就可以与其他进程隔开，不需要任何辅助。

## Docker 更加轻量

Docker容器与主机共享操作系统内核，不同容器之间可以共享部分系统资源，因此容器更加轻量级，消耗的资源也更少。而虚拟机会独占分配给自己的资源，几乎不存在资源共享，各个虚拟机之间近乎完全隔离，虚拟机更加重量级，也会消耗更多的资源。

我们可以很轻松地在一台物理机上运行100个或者更多的呃Docker容器，而且不会占用太多系统资源（如果Docker占用资源不多）；而在单台机器上不可能创建100台虚拟机，因为每一个虚拟机实例都会占用一个完整的操作系统所需要的所有资源。

另外，Docker容器启动很快，通常是秒级甚至是毫秒级启动。而虚拟机的启动虽然会快于物理机，但是也是在数秒级甚至数十秒级。

因此，可以根据需求的不同选择相应的隔离方式。如果需要资源完全隔离并且不考虑资源消耗，可以选择使用虚拟机；而若是想隔离进程并且需要大量进程实例，则应该选择Docker。

# 参考资料

[Docker在LXC基础上做了什么 && Docker与虚拟机之间有什么不同](https://blog.csdn.net/x_i_y_u_e/article/details/51287049)

# 拓展阅读

[code shell docker 系列博客](https://coolshell.cn/tag/docker)

* any list
{:toc}