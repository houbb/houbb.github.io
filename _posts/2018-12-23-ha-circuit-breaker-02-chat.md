---
layout: post
title: 高可用之熔断 Circuit Breaker-02-chat 断路器（Circuit Breaker）
date: 2018-12-23 13:55:13 +0800
categories: [Distributed]
tags: [distributed, ha, sh]
published: true
---

# chat

## 详细介绍一下熔断 what

熔断（Circuit Breaker）是一种用于提升分布式系统稳定性和可用性的设计模式，特别是在微服务架构中。

当系统中某个服务出现故障时，熔断机制能够快速识别问题，并防止故障进一步扩散到整个系统。

下面是熔断机制的主要组成部分和工作原理：

### 主要组成部分

1. **状态**：
   - **闭合（Closed）**：正常状态，所有请求都被允许通过。如果请求成功，熔断器保持闭合；如果请求失败达到一定阈值，熔断器转入打开状态。
   - **打开（Open）**：当请求失败率超过预设阈值时，熔断器进入打开状态，此时所有请求都会被拒绝。熔断器会在一段时间后进入半开状态。
   - **半开（Half-Open）**：在这个状态下，熔断器会允许一小部分请求通过，以检测目标服务是否恢复。如果这些请求成功，熔断器可能会恢复到闭合状态；如果仍然失败，熔断器继续保持打开状态。

2. **阈值和超时**：
   - **失败阈值**：定义了请求失败的比例或次数，以决定何时触发熔断。
   - **超时设置**：设定熔断器在打开状态下的持续时间。

### 工作原理

1. **请求监控**：熔断器监控服务的请求和响应情况，包括成功率和失败率。
2. **状态转换**：
   - 当请求失败率超过阈值时，熔断器会立即切换到打开状态，拒绝后续请求。
   - 在打开状态下，熔断器会定期检查服务的健康状况（例如，发送心跳请求）。
   - 如果心跳请求成功，熔断器会进入半开状态，允许一部分请求通过进行测试。
   - 如果测试请求成功，熔断器恢复到闭合状态；如果失败，熔断器继续保持打开状态。

### 优点

1. **提升系统稳定性**：避免因个别服务故障而导致整个系统崩溃。
2. **快速失败**：及时拒绝失败请求，减少不必要的资源消耗。
3. **改善用户体验**：减少用户等待时间，避免长时间的错误响应。

### 实现方式

熔断器可以通过多种方式实现，包括使用库（如 Hystrix、Resilience4j）、中间件或自定义代码。常见的编程语言和框架都提供了熔断器的实现工具。

### 适用场景

- 微服务架构中的服务调用。
- 外部 API 请求。
- 数据库访问等易受网络波动影响的操作。

通过合理配置和使用熔断器，可以有效提高系统的健壮性和用户体验。

## 为什么需要熔断？why

**熔断（Circuit Breaker）**的引入是为了提升分布式系统的稳定性和可用性，尤其是在微服务架构中。它通过监控服务的运行状态，预防由于某个服务的故障而导致整个系统出现级联故障。熔断器的核心思想是当某个服务发生故障时，快速隔离故障点，从而避免进一步的影响。

### 为什么需要熔断？

1. **避免系统级故障传播**：
   - 在分布式系统中，服务之间往往存在大量依赖。如果某个服务出现性能问题或不可用，而其他服务仍然继续向它发送请求，这可能会导致依赖服务资源耗尽，进而引发系统级的连锁反应，最终导致整个系统的崩溃。熔断机制能在服务出现故障时，快速切断后续请求，避免问题扩散。

2. **防止资源耗尽**：
   - 如果某个服务不断重试调用故障服务，可能会使系统中的线程、连接池等资源被大量占用，导致服务崩溃。熔断器通过在检测到问题后停止请求，节省资源。

3. **提升用户体验**：
   - 如果服务长时间等待故障服务的响应，会导致用户体验下降。而熔断机制能够让请求快速失败，向用户返回替代响应或错误信息，减少用户等待时间。

4. **增强系统的自我恢复能力**：
   - 熔断器不仅在故障时保护系统，还能在服务恢复时自动检测并逐步恢复对服务的调用，从而增强系统的自愈能力。

### 总结

熔断机制通过在服务故障时隔离问题，避免系统中资源的过度消耗和故障扩散，提升系统的稳定性和自愈能力。

然而，它也引入了额外的复杂性和性能开销，因此需要根据系统的实际情况，合理配置熔断器的阈值和策略，以发挥其最大效用。

## 熔断有什么优缺点？适用的场景？

### 熔断的优缺点

#### 优点

1. **防止故障蔓延**：
   - 熔断器通过切断对故障服务的请求，防止局部故障扩展到整个系统，避免级联故障，从而保护系统的整体稳定性。
   
2. **节省资源**：
   - 当服务不可用时，熔断器会快速拒绝请求，避免无效的重试操作。这节省了系统的宝贵资源，如线程、数据库连接和内存，使其他服务能够正常运行。

3. **快速响应**：
   - 熔断后，系统不会等待长时间的请求超时，而是立即拒绝请求，返回错误或降级的响应，减少用户等待时间，提升用户体验。

4. **增强弹性**：
   - 熔断器允许系统在部分服务不可用时仍然正常工作，通过隔离故障和保护健康的服务，增强了系统的弹性和容错能力。

5. **自动恢复**：
   - 熔断器具有自动恢复机制。当检测到故障服务恢复正常时，会允许部分流量进入并逐步恢复调用，提升系统的自愈能力。

#### 缺点

1. **增加复杂性**：
   - 实现熔断器涉及状态管理（如闭合、打开、半开）、失败率监控、时间窗口管理等，增加了系统的设计和实现复杂性。

2. **误触发风险**：
   - 如果熔断器的阈值设置不合理，可能会过早或过晚触发熔断，导致不必要的服务阻断或迟缓的故障处理。

3. **性能开销**：
   - 熔断器的状态监控和流量管理带来了一定的性能开销，特别是在高并发环境下，系统需要平衡熔断逻辑和核心业务逻辑的执行效率。

4. **流量激增问题**：
   - 当熔断器从打开状态恢复到半开状态时，突然允许部分或全部请求通过，可能会导致目标服务出现瞬间流量激增，进一步加剧故障。

5. **响应退化处理复杂**：
   - 熔断器拒绝请求后，如何优雅地处理这些失败请求（如降级服务、缓存数据等）需要设计完善的备用方案，否则可能导致用户体验下降。

---

## 熔断的适用场景 where/when

1. **微服务架构中的服务调用**：
   - 在微服务架构中，服务之间存在大量依赖。熔断器可以用来保护一个服务在依赖的其他服务不可用时，不会因等待这些不可用服务的响应而使自己挂起，从而保证系统整体的可用性。

2. **外部 API 调用**：
   - 当系统需要调用外部第三方 API 时，由于网络不稳定或 API 出现问题，可能导致响应延迟甚至失败。熔断机制能快速判断问题并保护系统资源，避免无意义的重试和资源耗尽。

3. **数据库连接池和资源限额管理**：
   - 熔断器可用于控制对数据库或其他资源的访问。例如，当数据库连接池耗尽时，熔断器可以阻止新的数据库请求进入，避免因过度并发请求导致数据库崩溃。

4. **网络抖动或间歇性故障的系统**：
   - 对于易受网络抖动或间歇性故障影响的系统，熔断器可以帮助系统快速识别问题，防止在短时间内频繁重试影响系统的稳定性。

5. **需要快速失败的场景**：
   - 在一些对响应时间要求较高的场景下，熔断器可以帮助系统快速拒绝那些可能无法正常处理的请求，减少等待时间。

6. **分布式系统中的下游依赖问题**：
   - 在复杂的分布式系统中，某个下游服务发生故障可能会导致上游服务长时间等待，甚至拖垮整个链路。熔断器通过快速失败，防止下游故障波及上游服务。

## 如何优雅的实现熔断？最佳实践？how?

要优雅地实现熔断（Circuit Breaker），需要考虑以下几个方面：合理的设计、合适的工具选择以及可靠的配置和监控。这可以确保系统在遇到故障时，不仅能够及时熔断，还能有序恢复，保证系统的稳定性和用户体验。

### 优雅实现熔断的关键步骤

#### 1. **选择合适的熔断库或框架**

在微服务架构或分布式系统中，熔断器一般通过开源框架实现，以下是几个流行的库：
   - **Netflix Hystrix**：Hystrix 是熔断模式的经典实现，支持请求超时、隔离、限流、熔断和降级等功能（目前已不再维护，但仍在使用）。
   - **Resilience4j**：Resilience4j 是 Hystrix 的轻量级替代品，支持熔断、限流、重试、超时等功能。它基于 Java 8 函数式编程，提供了非常灵活的配置。
   - **Spring Cloud Circuit Breaker**：Spring Cloud 提供了一个熔断器的抽象层，支持多种实现（如 Resilience4j 和 Hystrix），易于与 Spring 项目集成。
   - **Istio**：服务网格中的熔断可以通过 Istio 等工具实现，它可以在服务之间的通信层面应用熔断器，无需在代码中实现。

#### 2. **定义合理的熔断策略**

- **失败阈值**：设定熔断的触发条件，比如在一个时间窗口内连续发生一定数量的请求失败（例如 50% 失败率或 10 次失败）。
- **超时时间**：为每个请求设定合理的超时时间，防止服务因长时间等待响应而阻塞。这个值应根据系统的响应时间而设定，避免因为偶尔的延迟误触发熔断。
- **恢复时间窗口**：在服务熔断之后，设定一个恢复检查窗口（如 5 秒或 30 秒），在此期间系统不会发送任何请求，并在之后进入半开状态进行健康检查。
- **半开状态测试**：进入半开状态时，允许少量请求通过，测试服务是否恢复正常。根据测试结果决定是否恢复正常流量，还是继续保持熔断。

#### 3. **实现降级策略**

当熔断器开启时，系统应提供**降级处理**，以保持部分功能可用：
   - **默认返回值**：在服务不可用时，返回一个默认值或静态响应。例如，当用户信息服务不可用时，可以返回缓存的用户数据或提示用户稍后再试。
   - **服务降级**：熔断期间，可以调用备用服务或轻量化的备用逻辑，以确保关键功能不受影响。例如，当主要的支付网关不可用时，可以切换到备用的支付提供商。
   - **缓存与异步处理**：对于非关键请求，可以缓存数据并在熔断期间返回缓存的内容；对于耗时较长的操作，可以使用异步处理将请求放入队列，稍后重试执行。

#### 4. **合理配置超时时间和重试机制**

- **请求超时**：为每个服务调用设定适当的超时时间，防止长时间等待某个服务响应而阻塞系统。
- **重试机制**：在某些情况下可以实现带有退避策略的重试机制，与熔断器结合，当请求失败时，不是立即重试，而是根据指数退避策略逐步延长重试时间，防止服务负载过重。

#### 5. **监控与报警**

熔断机制的有效性依赖于持续的监控和调优，使用以下工具来观察熔断状态：
   - **度量指标**：使用指标（如成功率、失败率、超时次数）监控系统的健康状态。常见的度量指标包括：
     - 请求成功率/失败率
     - 熔断器的状态转换次数
     - 每秒请求数
   - **日志**：在日志中记录熔断器的状态变化（打开、关闭、半开），以及失败的请求和调用情况。日志可以帮助排查熔断器触发的原因。
   - **报警机制**：当熔断器触发时，立即发出警报，提醒运维人员检查相关服务的健康状态。

#### 6. **设计系统的容错能力**

熔断器并不能解决服务本身的故障问题，而是将故障隔离并通知系统。因此，系统本身应该具备更好的容错能力：
   - **服务冗余**：当一个服务不可用时，系统应能够迅速切换到备用服务或副本，确保业务不中断。
   - **资源隔离**：不同服务的资源（如线程池、数据库连接池）应当隔离，防止一个服务的故障影响到其他服务。
   - **限流**：熔断器可以与限流机制结合使用，在流量过高时优雅地拒绝部分请求，以防止系统过载。

#### 7. **合理设置半开状态**

- **部分请求通过**：在半开状态下，不要一次性恢复所有流量，而是部分请求通过，以测试服务的健康状况。如果这些请求成功，恢复正常流量；如果失败，继续保持熔断。
- **逐步增加请求量**：在恢复时可以采用渐进式恢复方式，逐步增加允许通过的请求量，以确保服务不会因瞬时流量激增再次崩溃。

---

### 熔断的最佳实践

1. **逐渐引入熔断器**：不要一开始就为所有服务启用熔断器，可以先在最容易出现故障的服务或对用户体验影响最大的服务中引入熔断，逐步扩展到整个系统。
  
2. **动态配置熔断参数**：熔断器的阈值、超时时间等配置项最好支持动态调整。可以通过运维管理平台或者配置中心实时更新参数，而无需重启系统。

3. **结合重试与限流**：熔断器常常与重试和限流机制结合使用。重试可以帮助在短暂故障后恢复请求，限流则可以保护服务避免过载。

4. **业务优先级降级**：对于业务上不那么关键的服务，允许在熔断期间进行降级。例如，推荐服务故障时，直接返回空结果而不影响核心功能（如支付）。

5. **监控与持续优化**：随着系统规模和流量的变化，熔断器的参数可能需要调整。通过实时监控熔断触发次数、失败率、延迟等指标，持续优化配置。

---

通过结合合适的熔断工具、合理的熔断策略、降级处理以及监控机制，能够优雅地实现熔断，提升系统的容错性、稳定性和可恢复性。

# 参考资料

[熔断](https://mp.weixin.qq.com/s?__biz=MzAxODcyNjEzNQ==&mid=2247486481&idx=1&sn=87aee20e301d87030be2636cd0a124b7&chksm=9bd0a189aca7289f0a5e8a91907d21e32bd367341251c713e76c2fd97f6f64c06379ad7c4f93&scene=21#wechat_redirect)

[springcloud(四)：熔断器Hystrix - 纯洁的微笑](https://www.cnblogs.com/ityouknow/p/6868833.html)

[服务熔断、降级、限流、异步RPC -- HyStrix](https://blog.csdn.net/chunlongyu/article/details/53259014)

* any list
{:toc}