---
layout: post
title:  【leetcode】力扣刷题之空间复杂度介绍 Space Complexity
date:  2020-6-8 15:13:08 +0800
categories: [Algorithm]
tags: [algorithm, tips, leetcode]
published: true
---

# 算法中的空间复杂度

好的，空间复杂度（Space Complexity）是算法分析中与时间复杂度同等重要的概念，它衡量的是算法在执行过程中所需额外存储空间（除输入数据本身占据的空间外）随输入数据规模（通常用 `n` 表示）增长的幅度。理解空间复杂度对于评估算法的内存消耗、优化资源利用以及设计高效系统至关重要。

---

## 1. 核心概念：什么是空间复杂度？

*   定义： 空间复杂度衡量算法在运行期间临时占用存储空间大小的变化趋势。它关注的是算法为了完成计算任务，除了存储原始输入数据之外，还需要申请多少额外的内存空间（例如，变量、数据结构、函数调用栈等）。
*   目的：
    *   评估内存消耗： 了解算法需要多少额外内存，尤其在处理大规模数据或内存受限环境（如嵌入式系统、移动设备）时至关重要。
    *   比较算法优劣： 在解决同一问题时，不同算法可能有不同的内存需求。空间复杂度提供了一个理论框架来比较它们，帮助我们选择内存效率更高的算法。
    *   预测资源需求： 预估当输入规模 `n` 增大时（例如从 1GB 数据到 1TB 数据），算法所需内存会如何增长。
    *   识别内存瓶颈： 找出算法中消耗内存最多的部分，指导优化方向。
*   核心思想： 忽略常数因子和低阶项，关注最高阶项。 与时间复杂度一样，当 `n` 非常大时，最高阶项对空间需求增长的影响起主导作用。
*   表示法： 大 O 表示法 (Big O Notation)。空间复杂度通常表示为 `S(n) = O(f(n))`，其中 `f(n)` 是一个描述空间增长率的函数（如 `1`, `n`, `n²`, `log n`）。`O(f(n))` 表示算法所需的额外空间增长率不会超过 `f(n)` 的增长率（乘以某个常数因子）。

## 2. 空间复杂度的组成

算法运行期间占用的空间主要包括：

1.  指令空间 (Instruction Space)： 存储编译后的程序指令（代码本身）所需的空间。这部分通常是固定的，与输入规模 `n` 无关，因此常被忽略或归入常数项 `O(1)`。
2.  数据空间 (Data Space)：
    *   常量空间 (Constant Space)： 存储固定数量的简单变量（如基本数据类型 `int`, `float`, `bool`, `char` 的变量、指针等）。这部分空间大小与 `n` 无关。
    *   结构空间 (Structure Space)： 存储算法运行过程中动态创建的数据结构（如数组、链表、栈、队列、树、图、哈希表等）所需的空间。这部分空间的大小通常与输入规模 `n` 或其某些特征（如边的数量 `E`）直接相关，是空间复杂度分析的重点。
3.  栈空间 (Stack Space) / 环境栈空间：
    *   存储函数调用信息（返回地址、参数、局部变量等）所需的空间。
    *   递归算法会显著影响栈空间。递归深度（即嵌套调用函数的层数）决定了栈空间的大小。例如，深度为 `d` 的递归可能需要 `O(d)` 的栈空间。
    *   非递归算法（或递归深度固定的算法）的栈空间需求通常是常数 `O(1)`。

重点分析对象： 空间复杂度分析主要关注 数据空间 和 栈空间 中那些与输入规模 `n` 相关的部分。

## 3. 常见的空间复杂度等级（从低到高）

1.  O(1) - 常数空间 (Constant Space):
    *   含义： 算法运行所需的额外空间大小不随输入规模 `n` 的变化而变化，是一个固定的常数。
    *   特点： 算法通常只使用固定数量的变量，或者使用的数据结构大小是固定的（与 `n` 无关）。原地算法 (In-place Algorithm) 通常具有 O(1) 的空间复杂度。
    *   例子：
        *   使用有限个变量交换两个数。
        *   在数组上遍历查找最大值/最小值（只用了几个临时变量）。
        *   冒泡排序、选择排序、插入排序（通常只使用常数级别的额外空间进行交换或比较）。
        *   迭代计算斐波那契数列（只用 `prev`, `curr`, `next` 三个变量）。
    *   图形： 一条水平直线。

2.  O(log n) - 对数空间 (Logarithmic Space):
    *   含义： 算法运行所需的额外空间大小随输入规模 `n` 的增长而对数增长（通常底数为 2）。
    *   特点： 常见于递归深度与 `log n` 相关的算法，或者使用了空间复杂度为 `O(log n)` 的数据结构（如平衡二叉搜索树的递归操作栈）。
    *   例子：
        *   二分查找（递归实现）的栈空间：递归深度是 `O(log₂ n)`。
        *   快速排序的最优栈空间：在理想的分割（每次划分均匀）下，递归深度是 `O(log n)`，栈空间也是 `O(log n)`。
        *   树的遍历（递归实现）：平衡树（如 AVL 树、红黑树）的深度是 `O(log n)`，递归遍历所需的栈空间也是 `O(log n)`。
    *   图形： 一条非常平缓上升的曲线。

3.  O(n) - 线性空间 (Linear Space):
    *   含义： 算法运行所需的额外空间大小与输入规模 `n` 成正比。如果 `n` 翻倍，所需空间也大致翻倍。
    *   特点： 算法通常需要创建与输入规模 `n` 线性相关的数据结构。
    *   例子：
        *   创建一个大小为 `n` 的新数组来存储结果（如归并排序中的合并操作）。
        *   将长度为 `n` 的链表存入数组（数组大小 `O(n)`）。
        *   广度优先搜索（BFS）的队列空间（在最坏情况下可能需要存储所有节点 `O(V) ≈ O(n)`）。
        *   深度优先搜索（DFS）的递归栈空间（在树形结构或线性结构最坏情况下 `O(V) ≈ O(n)`）。
        *   计数排序（需要大小为 `k` (数据范围) 的计数数组，如果 `k` 是常数则 `O(1)`，如果 `k` 与 `n` 相关则 `O(n)` 或 `O(k)`）。
    *   图形： 一条斜率为正的直线。

4.  O(n log n) - 线性对数空间 (Linearithmic Space):
    *   含义： 所需空间比 `O(n)` 稍大，但比 `O(n²)` 小得多。
    *   特点： 相对少见，有时出现在递归树结构复杂或需要额外空间存储中间结果的算法中。
    *   例子：
        *   一些高效的排序算法在非原地实现时的空间复杂度（如堆排序通常 `O(1)`，但某些实现可能达到 `O(n log n)` 如果存储堆结构有额外开销）。
        *   处理树结构问题时，如果需要在每个节点存储与其子树大小相关的信息（子树大小本身是 `O(n)`，但树有 `O(n)` 个节点）。
    *   图形： 一条比 `O(n)` 更陡峭的曲线，但仍远低于 `O(n²)`。

5.  O(n²) - 平方空间 (Quadratic Space):
    *   含义： 算法运行所需的额外空间大小与输入规模 `n` 的平方成正比。
    *   特点： 常见于需要创建二维数组（矩阵）且其大小与 `n` 相关的算法。
    *   例子：
        *   使用邻接矩阵存储图（矩阵大小为 `V x V`，即 `O(V²) ≈ O(n²)`）。
        *   动态规划中需要 `n x n` 维度的 `dp` 表（如计算最长公共子序列 LCS）。
        *   存储所有点对之间的距离（需要 `O(n²)` 的空间）。
        *   二维数组的转置（如果创建新数组，大小 `O(n²)`）。
    *   图形： 一条抛物线。

6.  O(nᶜ) - 多项式空间 (Polynomial Space) (c > 2):
    *   含义： 所需空间是输入规模 `n` 的某个常数 `c` 次幂（c > 2）。例如 `O(n³)`, `O(n⁴)`。
    *   特点： 空间消耗巨大，通常只适用于小规模问题。
    *   例子：
        *   使用三维 `dp` 数组解决某些复杂问题（如 `dp[i][j][k]`）。
        *   存储所有可能的 `k` 元组（当 `k` 是常数时是 `O(nᵏ)`）。
    *   图形： 比 `O(n²)` 更陡峭的曲线。

7.  O(2ⁿ) / O(cⁿ) - 指数空间 (Exponential Space):
    *   含义： 所需空间随输入规模 `n` 的增长呈指数级增长。
    *   特点： 空间需求爆炸式增长，通常出现在需要存储所有可能子集、排列、组合或状态空间的算法中。这类算法在实际中往往不可行，除非 `n` 非常小。
    *   例子：
        *   暴力解决旅行商问题（TSP）时存储所有可能的路径（`O(n!)`，比指数还高）。
        *   动态规划解决某些状态压缩问题，但状态空间本身是指数级的（如精确覆盖问题）。
        *   穷举所有长度为 `n` 的二进制字符串（需要存储 `2ⁿ` 个字符串）。
    *   图形： 一条急剧上升的曲线。

8.  O(n!) - 阶乘空间 (Factorial Space):
    *   含义： 所需空间随输入规模 `n` 的增长呈阶乘级增长。
    *   特点： 空间消耗最大的一类，几乎只存在于理论分析或极小规模问题中。
    *   例子：
        *   存储集合的所有排列（`n!` 个）。
        *   暴力解决某些组合优化问题。
    *   图形： 一条比指数时间更陡峭的曲线。

## 4. 如何分析算法的空间复杂度？

分析步骤与时间复杂度类似，但关注点是额外空间：

1.  定义 `n`： 明确输入规模 `n` 指什么（数组长度？节点数？数值位数？）。
2.  识别额外空间消耗源：
    *   显式数据结构： 算法中显式创建的数组、链表、栈、队列、哈希表、树、图等数据结构的大小如何依赖于 `n`？(例如：创建了一个长度为 `n` 的数组 -> `O(n)`；创建了一个 `n x n` 的矩阵 -> `O(n²)`）。
    *   递归调用栈： 如果是递归算法，递归的最大深度是多少？深度如何依赖于 `n`？(例如：二分查找递归深度 `O(log n)`；链表递归深度 `O(n)`）。
    *   辅助变量： 算法中使用的简单变量（`int`, `float`, `pointer` 等）通常是 `O(1)`，除非数量依赖于 `n`（罕见）。
    *   输入/输出空间： 通常不计入空间复杂度！空间复杂度关注的是额外空间，即算法运行过程中临时申请的、不包括存储原始输入和最终输出结果的空间。但也有观点认为如果输出规模巨大（如生成所有排列），可能需要考虑。约定俗成，分析时通常不包括输入和输出。
3.  计算 `S(n)`： 量化上述空间源的总大小。通常取主要消耗源的最大值。
4.  简化到大O： 忽略常数因子、系数、低阶项，保留最高阶项。

### 分析示例

1.  归并排序 (非原地)：
    *   需要额外的临时数组来合并两个有序子数组。这个临时数组的大小最大为 `n`。
    *   递归深度为 `O(log n)`，但每一层递归使用的临时数组空间是独立的吗？注意： 在标准的递归归并排序实现中，虽然递归深度是 `O(log n)`，但每一层递归在合并时都需要 `O(n)` 的临时空间。关键在于，这些递归调用是顺序执行的，而不是同时活跃的。当一个递归调用完成合并并返回后，它的临时空间就被释放了，然后才进行下一个递归调用。因此，任意时刻只需要一个最大为 `O(n)` 的临时数组（在递归树的某一层合并时使用），以及递归栈 `O(log n)`。
    *   空间复杂度： `O(n)` (主要来自合并所需的临时数组) + `O(log n)` (递归栈) = `O(n)` (因为 `n` 比 `log n` 增长快得多)。

2.  快速排序 (递归)：
    *   通常是原地排序（`O(1)` 额外数据空间）。
    *   递归调用栈空间：最坏情况（输入已排序/逆序）下递归深度为 `O(n)`；最好/平均情况下递归深度为 `O(log n)`。
    *   空间复杂度：
        *   最坏情况：`O(n)` (栈空间)
        *   平均情况：`O(log n)` (栈空间)

3.  深度优先搜索 (DFS) - 递归实现：
    *   需要标记节点是否访问过的数组 `visited`，大小为 `O(V) ≈ O(n)`。
    *   递归调用栈空间：最坏情况（图是一条链）下深度为 `O(V) ≈ O(n)`。
    *   空间复杂度： `O(n)` (`visited`) + `O(n)` (栈) = `O(n)`。

4.  广度优先搜索 (BFS)：
    *   需要标记节点是否访问过的数组 `visited`，大小为 `O(V) ≈ O(n)`。
    *   需要一个队列 `queue`：最坏情况下需要存储所有节点 `O(V) ≈ O(n)`。
    *   空间复杂度： `O(n)` (`visited`) + `O(n)` (`queue`) = `O(n)`。

5.  动态规划 - 斐波那契数列 (迭代)：
    *   如果使用一个大小为 `n+1` 的数组 `dp` 存储 `F(0)` 到 `F(n)` -> `O(n)`。
    *   如果只使用三个变量 (`prev`, `curr`, `next`) 滚动更新 -> `O(1)`。

6.  动态规划 - 最长公共子序列 (LCS)：
    *   创建一个 `(m+1) x (n+1)` 的二维 `dp` 表（`m`, `n` 是两个输入序列的长度）-> `O(m*n)`。

## 5. 关键点与注意事项

*   关注额外空间： 空间复杂度分析的是算法临时申请的、不包括输入数据本身和最终输出结果的额外空间。输入和输出空间是问题固有的，与算法设计无关。
*   原地算法 (In-place Algorithm)： 指空间复杂度为 `O(1)` 的算法。它们通常通过直接在输入数据上进行修改、交换或覆盖来完成计算，几乎不需要额外的存储空间。冒泡、选择、插入排序通常是原地算法；堆排序是原地算法 (`O(1)` 数据空间 + `O(1)` 栈空间（迭代实现）)。
*   时间与空间的权衡 (Time-Space Tradeoff)： 这是算法设计的核心原则之一。通常可以通过消耗更多的内存空间来换取运行时间的减少，反之亦然。 例如：
    *   哈希表：用 `O(n)` 的空间换取 `O(1)` 的平均查找时间（相比数组的 `O(n)` 查找）。
    *   动态规划：用 `O(n²)` 的空间存储子问题解，避免重复计算，将指数时间 (`O(2ⁿ)`) 优化到多项式时间 (`O(n²)`)。
    *   归并排序：用 `O(n)` 的额外空间换取稳定的 `O(n log n)` 时间。
    *   缓存 (Memoization/Caching)：存储计算结果，用空间换时间。
*   递归 vs 迭代： 递归代码简洁，但可能带来显著的栈空间开销 (`O(depth)`)。迭代实现通常栈空间开销为 `O(1)`，但代码可能更复杂。深度很大的递归可能导致栈溢出 (Stack Overflow)。
*   数据结构的选择： 不同数据结构对同一操作的空间开销不同（如邻接表 vs 邻接矩阵存储图）。
*   共享空间： 如果多个数据结构或变量可以共享或复用同一块内存区域，则不应重复计算其空间。
*   垃圾回收 (Garbage Collection)： 在托管语言（如 Java, Python, C#）中，分析空间复杂度时通常不考虑垃圾回收机制本身的开销，只关注算法逻辑上申请的空间。但要意识到 GC 的存在会影响实际内存使用和性能。
*   实际影响： 理解空间复杂度对于防止内存溢出 (Out Of Memory, OOM) 错误至关重要。一个 `O(n)` 的算法处理 1GB 数据可能只需 1GB 额外内存，而一个 `O(n²)` 的算法处理同样的数据可能需要 1EB (Exabyte) 内存，这在当前硬件上完全不可能。

## 6. 与时间复杂度的关系

*   独立但相关： 时间复杂度和空间复杂度是衡量算法效率的两个独立但密切相关的维度。
*   并非绝对正相关： 一个时间复杂度低的算法不一定空间复杂度也低（如归并排序 `O(n log n)` 时间但 `O(n)` 空间），反之亦然（如某些空间复杂度 `O(1)` 的排序算法时间可能是 `O(n²)`）。
*   共同决定效率： 评价一个算法的优劣需要同时考虑时间和空间复杂度，根据实际应用场景（是时间敏感还是空间敏感）进行权衡选择。

## 总结

空间复杂度是评估算法内存资源消耗的关键指标，使用大 O 表示法描述算法所需额外存储空间随输入规模增长的渐进趋势。掌握常见空间复杂度等级（`O(1)`, `O(log n)`, `O(n)`, `O(n log n)`, `O(n²)`, `O(2ⁿ)`, `O(n!)`）及其含义和典型例子，结合分析技巧（关注数据结构大小、递归深度），能够帮助我们：

1.  选择内存高效的算法。
2.  预测算法处理大规模数据时的内存需求。
3.  避免内存溢出错误。
4.  理解并应用时间-空间权衡原则进行算法优化。

与时间复杂度分析相辅相成，空间复杂度分析是设计和实现高效、可靠软件系统不可或缺的技能。




# 参考资料


* any list
{:toc}