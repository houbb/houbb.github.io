---
layout: post
title: Dubbo3.x-15-[Google Paper] 面向云时代的应用开发新模式
date:  2016-09-25 18:46:04 +0800
categories: [RPC]
tags: [dobbo, rpc, dubbo3, java, sh]
published: true
---


# 回顾

大家好，我是老马。

最近 dubbo3.x 在公司内部分享，于是想系统梳理一下。

总体思路是官方文档入门+一些场景的问题思考+源码解析学习。

本文翻译自发表在以下地址的论文：https://serviceweaver.dev/assets/docs/hotos23_vision_paper.pdf


# chat

## 简单介绍下，什么问题？如何解决？


这篇论文主要解决了传统微服务架构在开发云原生应用时面临的五大核心问题（C1-C5），并提出了**逻辑单体开发+运行时自动化部署**的新模式（原型实现为Service Weaver）。

以下是关键问题和解决方案的通俗解释：

---

### **解决了什么问题？**
1. **性能差**（C1）  
   - **问题**：微服务过度拆分导致网络通信（RPC）频繁，序列化/反序列化开销大，延迟高。
   - **例子**：一个电商应用拆分成用户服务、订单服务、支付服务，每次下单需多次跨服务调用，网络开销成为瓶颈。

2. **版本冲突与正确性难保障**（C2）  
   - **问题**：不同微服务版本共存时，交互可能出错（如新订单服务调用旧支付接口）。
   - **例子**：支付接口升级后，未更新的订单服务调用旧接口导致交易失败。

3. **管理复杂**（C3）  
   - **问题**：需独立构建、测试、部署多个微服务，本地调试困难，依赖复杂。
   - **例子**：开发新功能需同时修改订单和支付服务，需协调两者的构建和部署流程。

4. **API冻结**（C4）  
   - **问题**：微服务间API一旦发布难以修改，遗留接口成为技术债务。
   - **例子**：用户服务的旧版查询接口无法下线，只能长期维护兼容。

5. **开发效率低**（C5）  
   - **问题**：跨服务改动需分步发布，无法原子化更新。
   - **例子**：重构用户认证逻辑需先更新网关服务，再更新用户服务，中间存在兼容风险。

---

### **如何解决？**
#### 1. **逻辑单体开发**（写代码像写单体）  
   - **方法**：开发者将应用拆分为**逻辑组件**（类似微服务），但以单体形式编写代码，**不关心物理部署**。
   - **优势**：  
- 组件间调用是本地方法调用（非RPC），无需处理序列化、网络通信。
- 重构时可直接修改组件接口，无需担心破坏其他服务（API不暴露）。

   **示例**：  
   ```go
   // 定义组件接口（类似微服务）
   type UserService interface {
       GetUser(id string) (User, error)
   }

   // 实现组件（业务逻辑）
   type userServiceImpl struct {
       Implements[UserService]  // 标记为组件
   }

   func (u *userServiceImpl) GetUser(id string) (User, error) {
       // 直接调用其他组件的方法（本地调用）
       order, _ := Get[OrderService]().GetOrder(id)
       return User{ID: id, Order: order}, nil
   }
   ```


#### 2. **运行时自动化部署**（运行时决定组件如何分布）  
   - **方法**：运行时（Service Weaver）根据性能、资源等因素，**动态决定组件部署位置**（同进程、跨机器、多副本等）。
   - **优势**：  
- **性能优化**：频繁交互的组件自动合并部署（减少RPC）。
- **弹性伸缩**：按负载自动扩缩容组件副本。
- **原子化部署**：全量替换应用版本，避免版本冲突。

   **示例场景**：  
   - 用户服务与订单服务交互频繁 → 运行时将其部署在同一进程内（本地调用）。
   - 支付服务负载高 → 运行时自动创建多副本，分布在多台机器。

#### 3. **原子化发布**  
   - **方法**：新版本应用整体发布，运行时逐步切换流量到新版本，新旧版本完全隔离。
   - **优势**：避免微服务分步发布导致的跨版本问题（解决C2）。

---

### **实际效果**
- **延迟降低15倍**：组件合并部署减少网络开销。
- **成本减少9倍**：资源利用率提升，减少冗余副本。
- **开发效率提升**：本地调试像单体应用，无需模拟微服务环境。

---

### **适用场景**
- 需要快速迭代的中大型云原生应用。
- 微服务拆分导致性能和管理成本过高的场景。
- 团队希望专注业务逻辑而非基础设施细节。

---

### **局限性与未解决问题**
- **有状态服务**：组件若依赖持久化状态（如数据库），版本升级时需处理数据兼容性（论文提到这是未来方向）。
- **生态成熟度**：Service Weaver尚属原型阶段，生产落地需更多工具链支持。

总之，Service Weaver通过**逻辑与物理边界的解耦**，在保留微服务模块化优势的同时，规避了其固有缺陷，为云应用开发提供了一种更高效的新模式。

---------------------------------

# 面向云时代的应用开发新模式：谷歌发布的关于单体&微服务开发与部署的论文，文中原型实现为 Service Weaver

借由 **Google** | Friday, May 26, 2023

> 本文翻译自发表在以下地址的论文：https://serviceweaver.dev/assets/docs/hotos23_vision_paper.pdf

> 原文作者(Authors): Sanjay Ghemawat, Robert Grandl, Srdjan Petrovic, Michael Whittaker, Parveen Patel, Ivan Posva, Amin Vahdat
> 
> 转载或发布请遵循原文许可： Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for thirdparty components of this work must be honored. For all other uses, contact the owner/author(s). HOTOS ’23, June 22–24, 2023, Providence, RI, USA © 2023 Copyright held by the owner/author(s). ACM ISBN 979-8-4007-0195-5/23/05. [https://doi.org/10.1145/3593856.3595909](https://doi.org/10.1145/3593856.3595909)

## 摘要

在编写分布式应用程序时，传统的明智做法是将您的应用程序拆分为可以分别拉起的独立服务。

这种方式的用意是好的，但像这样基于微服务的架构经常会适得其反，带来的挑战抵消了架构试图实现的好处。

从根本上说，这是因为微服务将逻辑边界（代码的编写方式）与物理边界（代码的部署方式）混为一谈。

在本文中，我们提出了一种不同的编程方法，将两者（代码编写与部署方式）分离以解决这些挑战。

通过我们的方法，开发人员将他们的应用程序编写为逻辑上的单体，将有关如何分发和运行应用程序的决策放到一套自动化运行时 (runtime)，并以原子方式部署应用程序。

与当前的微服务开发模式相比，我们的原型应用最多可减少延迟 15 倍、成本最多减少了 9 倍。

ACM 参考格式： Sanjay Ghemawat, Robert Grandl, Srdjan Petrovic, Michael Whit-taker, Parveen Patel, Ivan Posva, Amin Vahdat. 2022. Towards Mod-ern Development of Cloud Applications. In Workshop on Hot Topics in Operating Systems (HOTOS ’23), June 22–24, 2023, Providence, RI, USA. ACM, New York, NY, USA, 8 pages. [https://doi.org/10.1145/3593856.3595909](https://doi.org/10.1145/3593856.3595909)

## 1 介绍

近年来，云计算出现了前所未有的增长。

编写和部署可扩展到数百万用户的分布式应用程序从未如此简单，这在很大程度上归功于 Kubernetes [25] 等框架，[7, 18, 31, 33, 40, 60] 等消息传递解决方案，以及数据格式如 [5,6, 23, 30]。使用这些技术时，普遍的做法是手动将您的应用程序拆分为可以独立部署的独立微服务。 

通过对各种基础设施团队的内部调查，我们发现大多数开发人员出于以下原因之一将他们的应用程序拆分为多个二进制包：

(1) 提升性能。单独的二进制包可以独立扩展，从而提高资源利用率。

(2) 提升容错能力。一个微服务的崩溃不会导致其他微服务崩溃，从而限制了错误的传播范围。 
 
(3) 改进抽象边界。微服务需要清晰明确的 API，并且代码纠缠的可能性会大大降低。
 
(4) 允许灵活的滚动发布。不同的二进制包可以以不同的速率发布，从而导致更敏捷的代码升级。 
  
然而，将应用程序拆分为可独立部署的微服务并非没有挑战，其中一些直接与收益相矛盾。

*   C1：影响性能。序列化数据并通过网络发送数据的开销越来越成为瓶颈 [72]。当开发人员过度拆分他们的应用程序时，这些开销也会增加 [55]。
*   C2：损害正确性。推断每个微服务的每个已部署版本之间的交互是极具挑战性的。在对八个广泛使用的系统的 100 多个灾难性故障进行的案例研究中，三分之二的故障是由系统的多个版本之间的交互引起的 [78]。
*   C3：很难管理。开发人员必须按照自己的发布计划管理不同的二进制包，而不是使用一个二进制文件来构建、测试和部署。如果在本地运行一个应用程序，同时需要执行端到端的集成测试，那可是一个不小的工程。
*   C4：API 冻结。一旦微服务建立了 API，就很难在不破坏使用该 API 的其他服务的情况下进行更改。遗留的 API 不得不长期存在，只能不停的在上面打补丁。
*   C5：降低应用程序的开发速度。当开发活动影响多个微服务的更改时，开发人员无法以原子方式实施和部署更改。

开发人员必须仔细计划规划发布时间表，已决定在何时跨微服务引入更改。

根据我们的经验，我们发现许多开发人员将上述挑战视为开展业务的必要部分，并且这个比例是压倒性的。

许多云原生公司实际上正在开发旨在缓解上述一些挑战的内部框架和流程，但这不会从根本上改变或完全消除它们。

例如，持续部署框架 [12, 22, 37] 简化了单个二进制包的构建、推送到生产环境的方式，但它们没有解决版本控制问题；如果它有提供这个能力的话，情况可能会更糟，因为代码将以更快的速度被发布并投入生产。

各种编程库 [13、27] 使创建和发现网络端点变得更加容易，但对简化应用程序管理没有任何帮助。

像 gRPC [18] 这样的网络协议和像 Protocol Buffers [30]这样的数据格式在不断改进，但仍然占据了应用程序执行成本的主要部分。

这些基于微服务的解决方案无法解决上述 C1-C5 的原因有两个。

第一个原因是他们都假设开发人员手动将他们的应用程序拆分为多个二进制包。这意味着应用程序的网络布局由应用程序开发人员预先确定。

此外，一旦确定，网络布局就会通过将网络代码添加到应用程序中而变得更加坚固（例如，网络端点、客户端/服务器存根、网络优化数据结构，如 [30] ）。

这意味着撤消或修改拆分变得更加困难，即使这样做是有意义的。

这隐含地促成了上述挑战 C1、C2 和 C4。

第二个原因是假设应用程序二进制包是单独（在某些情况下是连续的）发布到生产环境中。这使得对跨二进制协议进行更改变得更加困难。此外，它还引入了版本控制问题并强制使用更低效的数据格式，如[23、30]。这反过来又会导致上面列出的挑战 C1-C5。

在本文中，我们提出了一种不同的编写和部署分布式应用程序的方法，一种解决 C1-C5 问题的方法。

我们的编程方法包括三个核心原则：

*   (1) 以模块化的方式编写逻辑上划分为多个组件的单体应用程序。
*   (2) 利用运行时根据执行特征动态自动地将逻辑组件分配给物理进程。
*   (3) 以原子方式部署应用程序，防止应用程序的不同版本交互。

其他解决方案（例如 actor 系统）也尝试提高抽象度。但是，它们无法解决其中一项或多项挑战（第 7 节）。

尽管这些挑战和我们的提案是在服务型应用 (serving application) 的背景下讨论的，但我们相信我们的观察和解决方案具有广泛的用途。

## 2 提出的解决方案

我们提案的两个主要部分是 (1) 具有抽象的编程模型（programing model），允许开发人员编写仅关注业务逻辑的单一二进制模块化应用程序，(2) 用于构建、部署和优化这些应用程序的运行时（runtime）。

编程模型使开发人员能够将分布式应用程序编写为单个程序，其中代码被拆分为称为组件的模块化单元（第 3 节）。这类似于将应用程序拆分为微服务，除了微服务将逻辑和物理边界混为一谈。相反，我们的解决方案将两者分离：

**组件以基于应用程序业务逻辑的逻辑边界为中心，而运行时以基于应用程序性能的物理边界为中心（例如，两个组件应位于同一位置以提高性能）**。

这种解耦——连同边界可以自动更改的事实——解决了 C4。

通过将所有执行责任委托给运行时，我们的解决方案能够提供与微服务相同的优势，但性能更高，成本更低（解决 C1）。例如，运行时决定如何运行、放置、复制和缩放组件（第 4 节）。由于应用程序是原子部署的，因此运行时可以鸟瞰应用程序的执行情况，从而实现进一步的优化。例如，运行时可以使用自定义序列化和传输协议，利用所有参与者都以相同版本执行的事实。

将应用程序编写为单个二进制文件并以原子方式部署它还可以更轻松地推断其正确性（解决 C2）并使应用程序更易于管理（解决 C3）。我们的提案为开发人员提供了一个编程模型，使他们能够专注于应用程序业务逻辑，将部署复杂性委托给运行时（解决 C5）。最后，我们的提案支持未来的创新，例如分布式应用程序的自动化测试（第 5 节）。

## 3 编程模型

### 3.1 组件

我们提案的关键抽象是组件 (component)。组件是一种长期存在的、可复制的计算代理，类似于 actor [2]。

每个组件都实现一个接口（interface），与组件交互的唯一方法是调用其接口上的方法。组件可能由不同的操作系统进程托管（可能跨越多台机器）。组件方法调用在必要时变成远程过程调用，但如果调用者和被调用者组件在同一个进程中，则仍然是本地过程调用。

组件如 图-1 所示。示例应用程序包含三个组件：A、B 和 C。当部署应用程序时，运行时决定如何共同定位和复制组件。在此示例中，组件 A 和组件 B 位于同一个操作系统进程中，因此它们之间的方法调用作为常规方法调用执行。组件 C 不与任何其他组件位于同一位置，同时组件 C 被部署到了两台不同机器上，组件 C 之间的方法调用是通过跨网络 RPC 完成的。

![pic1-arch.png](https://cn.dubbo.apache.org/imgs/blog/2023/5/pic1-arch.png)

图-1：说明如何编写和部署组件。应用程序被编写为一组组件（左）并跨机器部署（右）。请注意，组件可以复制和放置在同一位置。

组件通常是长期存在的，但运行时可能会根据负载随时间增加或减少组件的副本数量。同样，组件副本可能会失败并重新启动。运行时还可以四处移动组件副本，例如，将两个交互非常多的组件放在同一个操作系统进程中，以便组件之间的通信在本地而不是通过网络完成。

### 3.2 接口

为了具体起见，我们在 Go 中提供了一个组件 API，尽管我们的想法与语言无关。图-2 给出了一个“Hello, World!” 应用程序。组件接口表示为 Go 接口，组件实现表示为实现这些接口的 Go 结构。

在图-2 中， `hello` 结构嵌入了 **Implements[ Hello]** 结构来表示它是 `Hello` 组件的实现。

**Init**初始化应用程序。**Get[Hello]** 将客户端返回给具有接口 `Hello` 的组件，必要时创建它。对 `hello.Greet` 的调用看起来像是常规方法调用，开发人员不需要关心任何序列化和远程过程调用相关内容。

![image.png](https://cn.dubbo.apache.org/imgs/blog/2023/5/pic2-hello-world.png)

图-2: “Hello, World!” 应用

## 4 运行时

### 4.1 概述

在编程模型之下是一个负责分发（distributing）和执行（executing）组件的运行时。运行时做出关于如何运行组件的所有高级决策。例如，它决定将哪些组件放在一起并进行多副本部署。运行时还负责底层细节，例如将组件运行到物理资源以及在组件失败时重新启动组件。最后，运行时负责执行原子滚动更新，确保一个应用程序版本中的组件永远不会与不同版本中的组件进行通信。

有许多方法可以实现运行时。本文的目的不是规定任何特定的实现。不过，重要的是要认识到运行时并没有什么神奇魔法。在本节的其余部分，我们将概述运行时的关键部分并揭开其内部工作原理的神秘面纱。

### 4.2 代码生成

运行时的首要职责是代码生成。通过检查一个项目中使用 **Implements[T]** 的相关源码调用，代码生成器即可计算出所有组件接口和实现的集合。然后它生成代码来编码和解码组件方法的参数。它还生成代码以将这些方法作为远程过程调用来执行。生成的代码将与开发人员的代码一起编译成一个二进制文件。

### 4.3 应用-运行时交互

根据我们的提案，应用程序不需要包含任何特定于其部署环境的代码，但由于它们最终必须运行并集成到特定环境中（例如在本地集群中跨机器或在公共云中跨区域运行)，为了支持这种集成，我们引入了一个 API（在表-1 中进行了部分概述），它将应用程序逻辑与部署环境的细节隔离开来。

![table1.png](https://cn.dubbo.apache.org/imgs/blog/2023/5/table1.png)

表-1：应用程序和运行时之间的示例 API。

API 的调用者是一个 `proclet`。每个应用程序二进制文件都会运行一个小型的、与环境无关的守护进程，称为 `proclet`，它在编译期间链接到二进制文件中。 proclet 管理正在运行的二进制文件中的组件:运行、启动、停止、在失败时重新启动这些组件等等。 API 的实现者是运行时，它负责所有控制平面操作。运行时决定 `proclet` 应该如何运行以及在何处运行。例如，多进程运行时可以运行子进程中的每个 `proclet`； SSH 运行时可以通过 SSH 运行 `proclet`；云运行时可以将 `proclet` 作为 Kubernetes pod [25、28] 运行。

具体而言，`proclet` 通过 Unix Pipeline 与运行时交互。例如，当构造一个 `proclet` 时，它会通过管道发送一条 `RegisterReplica` 消息，以将自己标记为活动和就绪。它定期发出 `ComponentsToHost` 请求以了解它应该运行哪些组件。如果组件调用不同组件的方法，`proclet` 会发出 `StartComponent` 请求以确保它已启动。

运行时以对部署环境有意义的方式实现这些 API。我们希望大多数运行时实现包含以下两部分：

*   (1) 一组通过 UNIX 管道与 proclet 直接通信的信封（Envelope）进程，以及
*   (2) 协调 proclet 执行的全局管理器（Global Manager）（参见图-3）。

![image.png](https://cn.dubbo.apache.org/imgs/blog/2023/5/pic3-runtime.png)

图-3：提案中的 Deployer 架构

信封（Envelope）作为 proclet 的父进程运行，并将 API 调用中继到管理器。管理器跨可用资源集（例如服务器、VM）启动信封和（间接）proclet。在应用程序的整个生命周期中，管理器与信封交互以收集运行组件的健康和负载信息；聚合组件导出的指标、日志和跟踪；并处理启动新组件的请求。管理器还发布特定于环境的 API（例如，谷歌云[16]、AWS [4]）更新流量分配并根据负载、健康状况和性能约束扩展和缩减组件。请注意，运行时实现控制平面（Golbal Manager）而不是数据平面，Proclet 直接相互通信。

### 4.4 原子滚动更新（Rollout）

开发人员不可避免地必须发布其应用程序的新版本。一种广泛使用的方法是执行滚动更新，其中部署中的机器一台一台地从旧版本更新到新版本。在滚动更新期间，运行不同版本代码的机器必须相互通信，这可能会导致失败。 [78]表明大多数更新失败是由这些跨版本交互引起的。 为了解决这些复杂性，我们提出了一种不同的方法。运行时确保应用程序版本以原子方式推出，这意味着所有组件通信都发生在应用程序的单个版本中。运行时逐渐将流量从旧版本转移到新版本，但是一旦用户请求转发到特定版本，它就会完全在该版本内处理。原子部署的一种流行实现是使用蓝/绿部署[9]。

## 5 启用创新

### 5.1 传输（Transport）、放置（Placement）和缩容（Scaling）

运行时可以鸟瞰应用程序执行，这为性能优化开辟了新途径。例如，我们的框架可以在组件之间构建一个细粒度的调用图，并用它来识别关键的路径路径、瓶颈组件、频繁交互型组件等。使用这些信息，运行时可以做出更智能的扩缩容、独立部署和组合部署决策。此外，由于序列化和传输机制对开发者透明（Code Generate 机制自动实现），运行时可以自由地优化它们。例如，对于网络瓶颈应用程序，运行时可能决定压缩网络上的消息，对于某些部署，传输可能会利用 RDMA [32] 等技术。

### 5.2 路由（Routing）

当请求以亲和力（affinity）路由时，某些组件的性能会大大提高。例如，考虑由基于磁盘的底层存储系统支持的内存缓存组件。当对相同键的请求被路由到相同的缓存副本时，缓存命中率和整体性能会提高。 Slicer [44]表明，许多应用程序可以从这种基于亲和力的路由中受益，并且当路由嵌入到应用程序本身时，路由效率最高[43]。我们的编程框架可以自然地扩展为包含路由 API。运行时还可以了解哪些方法从路由中获益最多并自动路由它们。

### 5.3 自动化测试（Automated Testing）

微服务架构被吹捧的好处之一是容错。这个想法是，如果应用中的一个服务组件失败，应用的部分功能可用性会降低，但整个应用仍然可用。这在理论上很棒，但在实践中它依赖于开发人员确保他们的应用对故障具有弹性，更重要的是，测试他们的故障处理逻辑是否正确。由于构建和运行不同的微服务、系统地失败和恢复它们以及检查正确行为的开销，测试尤其具有挑战性。结果，只有一小部分基于微服务的系统针对这种类型的容错进行了测试。根据我们的建议，运行端到端测试能带来的帮助是微不足道的。因为应用程序是用单一编程语言编写的单个二进制文件，所以端到端测试变成了简单的单元测试。这为自动化容错测试打开了大门，类似于混沌测试[47]、Jepsen 测试[14]和模型检查[62]。

### 5.4 有状态应用滚动更新（Rollout）

我们的建议确保一个应用程序版本中的组件永远不会与不同版本中的组件通信。这使开发人员更容易推理正确性。但是，如果应用程序更新持久存储系统（如数据库）中的状态，则应用程序的不同版本将通过它们读取和写入的数据间接影响彼此。这些跨版本交互是不可避免的——持久状态，根据定义，跨版本持续存在 —— 但一个悬而未决的问题是如何测试这些交互并及早发现错误以避免在推出期间出现灾难性故障。

### 5.5 讨论

请注意，本节讨论的领域中的创新并不是我们提案所独有的。对传输协议[63、64]、路由[44、65]、测试[45、75]、资源管理[57、67、

# 参考资料

https://cn.dubbo.apache.org/zh-cn/blog/2023/05/26/google-paper-%E9%9D%A2%E5%90%91%E4%BA%91%E6%97%B6%E4%BB%A3%E7%9A%84%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%96%B0%E6%A8%A1%E5%BC%8F/ 

* any list
{:toc}

