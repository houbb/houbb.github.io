---
layout: post
title:  java 基础篇-03-java 到底是值传递还是引用传递？
date:  2020-7-19 10:37:20 +0800
categories: [Java]
tags: [java, java-base, sf]
published: true
---

# 序言

这个问题实际上困扰了很多 java 开发者，有些人可能一直都没有弄懂。

如果较真起来，这里涉及到的知识其实还是比较多的，本文就以参考的各路文章做一个简单的总结。

# 形参与实参

## 定义

形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了

实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。

## 例子

```java
public static void func(int a){
    a=20;
    System.out.println(a);
}

public static void main(String[] args) {
    int a=10;//实参
    func(a);
}
```

int a=10;中的a在被调用之前就已经创建并初始化，在调用func方法时，他被当做参数传入，所以这个a是实参。

而func(int a)中的a只有在func被调用时它的生命周期才开始，而在func调用结束之后，它也随之被JVM释放掉，，所以这个a是形参。

# Java的数据类型

所谓数据类型，是编程语言中对内存的一种抽象表达方式，我们知道程序是由代码文件和静态资源组成，在程序被运行前，这些代码存在在硬盘里，程序开始运行，这些代码会被转成计算机能识别的内容放到内存中被执行。

因此**数据类型实质上是用来定义编程语言中相同类型的数据的存储形式，也就是决定了如何将代表这些值的位存储到计算机的内存中**。

## java 的数据类型

所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。

那么Java的数据类型有哪些？

### 基本类型

编程语言中内置的最小粒度的数据类型。

它包括四大类八种类型：
  
4种整数类型：byte、short、int、long

2种浮点数类型：float、double

1种字符类型：char

1种布尔类型：boolean
  
### 引用类型

引用也叫句柄，引用类型，是编程语言中定义的在句柄中存放着实际内容所在地址的地址值的一种数据形式。

它主要包括：
  
类

接口

数组

有了数据类型，JVM对程序数据的管理就规范化了，不同的数据类型，它的存储形式和位置是不一样的，要想知道JVM是怎么存储各种类型的数据，就得先了解JVM的内存划分以及每部分的职能。

# JVM 的划分及其职能

Java语言本身是不能操作内存的，它的一切都是交给JVM来管理和控制的，因此Java内存区域的划分也就是JVM的区域划分，在说JVM的内存划分之前，我们先来看一下Java程序的执行过程，如下图：

![image](https://user-images.githubusercontent.com/18375710/87866870-50cd8380-c9b9-11ea-8aad-5e79b8e84667.png)

## 数据区

有图可以看出：Java代码被编译器编译成字节码之后，JVM开辟一片内存空间（也叫运行时数据区），通过类加载器加到到运行时数据区来存储程序执行期间需要用到的数据和相关信息，在这个数据区中，它由以下几部分组成：

1. 虚拟机栈

2. 堆

3. 程序计数器

4. 方法区

5. 本地方法栈

我们接着来了解一下每部分的原理以及具体用来存储程序执行过程中的哪些数据。

## 虚拟机栈

虚拟机栈是Java方法执行的内存模型，栈中存放着栈帧，每个栈帧分别对应一个被调用的方法，方法的调用过程对应栈帧在虚拟机中入栈到出栈的过程。

栈是线程私有的，也就是线程之间的栈是隔离的；当程序中某个线程开始执行一个方法时就会相应的创建一个栈帧并且入栈（位于栈顶），在方法结束后，栈帧出栈。

下图表示了一个Java栈的模型以及栈帧的组成：

![image](https://user-images.githubusercontent.com/18375710/87866888-8bcfb700-c9b9-11ea-8699-98edfa905b5b.png)

栈帧:是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。 

每个栈帧中包括：

局部变量表: 用来存储方法中的局部变量（非静态变量、函数形参）。当变量为基本数据类型时，直接存储值，当变量为引用类型时，存储的是指向具体对象的引用。

操作数栈: Java虚拟机的解释执行引擎被称为"基于栈的执行引擎"，其中所指的栈就是指操作数栈。

指向运行时常量池的引用: 存储程序执行时可能用到常量的引用。

方法返回地址: 存储方法执行完成后的返回地址。

## 堆

堆是用来存储对象本身和数组的，在JVM中只有一个堆，因此，堆是被所有线程共享的。

## 方法区

方法区是一块所有线程共享的内存逻辑区域，在JVM中只有一个方法区，用来存储一些线程可共享的内容，它是线程安全的，多个线程同时访问方法区中同一个内容时，只能有一个线程装载该数据，其它线程只能等待。

方法区可存储的内容有：类的全路径名、类的直接超类的权全限定名、类的访问修饰符、类的类型（类或接口）、类的直接接口全限定名的有序列表、常量池（字段，方法信息，静态变量，类型引用（class））等。

## 本地方法栈

本地方法栈的功能和虚拟机栈是基本一致的，并且也是线程私有的，它们的区别在于虚拟机栈是为执行Java方法服务的，而本地方法栈是为执行本地方法服务的。

ps：什么是本地方法？为什么Java还要调用本地方法？

其实看 java 源码的时候，会有很多 native 的方法，比如数组的拷贝等等。这些都是基于 c 直接进行操作系统的相关操作。

## 程序计数器

线程私有的。

记录着当前线程所执行的字节码的行号指示器，在程序运行过程中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。

# 数据如何在内存中存储


从上面程序运行图我们可以看到，JVM在程序运行时的内存分配有几个地方：

- 堆

- 栈

- 静态方法区

- 常量区

相应地，每个存储区域都有自己的内存分配策略：

- 堆式

- 栈式

- 静态


我们已经知道：Java 中的数据类型有基本数据类型和引用数据类型，那么这些数据的存储都使用哪一种策略呢？

这里要分以下的情况进行探究

（1）基本数据类型的存储：

A. 基本数据类型的局部变量

B. 基本数据类型的成员变量

C. 基本数据类型的静态变量

（2）引用数据类型的存储

## 基本数据类型的存储

### A. 基本数据类型的局部变量

定义基本数据类型的局部变量以及数据都是直接存储在内存中的栈上，也就是前面说到的“虚拟机栈”，数据本身的值就是存储在栈空间里面。

![image](https://user-images.githubusercontent.com/18375710/87866948-68593c00-c9ba-11ea-98eb-b813f0532a65.png)

如上图，在方法内定义的变量直接存储在栈中，如

```
int age=50;
int weight=50;
int grade=6;
```

当我们写“int age=50；”，其实是分为两步的：

```
int age;//定义变量
age=50;//赋值
```

首先JVM创建一个名为age的变量，存于局部变量表中，然后去栈中查找是否存在有字面量值为50的内容，如果有就直接把age指向这个地址，如果没有，JVM会在栈中开辟一块空间来存储“50”这个内容，并且把age指向这个地址。

因此我们可以知道：我们声明并初始化基本数据类型的局部变量时，变量名以及字面量值都是存储在栈中，而且是真实的内容。

我们再来看“int weight=50;”，按照刚才的思路：字面量为50的内容在栈中已经存在，因此weight是直接指向这个地址的。

由此可见：栈中的数据在当前线程下是共享的。

那么如果再执行下面的代码呢？

```
weight=40；
```

当代码中重新给weight变量进行赋值时，JVM会去栈中寻找字面量为40的内容，发现没有，就会开辟一块内存空间存储40这个内容，并且把weight指向这个地址。

由此可知：

**基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存存新数据，并且把要重新赋值的局部变量的引用指向新数据所在地址。**

### B. 基本数据类型的成员变量

成员变量：顾名思义，就是在类体中定义的变量。

看下图：

![image](https://user-images.githubusercontent.com/18375710/87866989-faf9db00-c9ba-11ea-8ceb-46dd7ad8d52e.png)

我们看per的地址指向的是堆内存中的一块区域，我们来还原一下代码：

```java
public class Person {

    private int age;

    private String name;

    private int grade;

    //省略 getter/setter
}
```

调用部分：

```java
Person per = new Person();
```

同样是局部变量的age、name、grade却被存储到了堆中为per对象开辟的一块空间中。

因此可知：**基本数据类型的成员变量名和值都存储于堆中，其生命周期和对象的是一致的。**

### C. 基本数据类型的静态变量

前面提到方法区用来存储一些共享数据，因此**基本数据类型的静态变量名以及值存储于方法区的运行时常量池中，静态变量随类加载而加载，随类消失而消失。**

## 引用数据类型的存储

堆是用来存储对象本身和数组，而引用（句柄）存放的是实际内容的地址值，因此通过上面的程序运行图，也可以看出，当我们定义一个对象时

```java
Person per = new Person();
```

实际上，它也是有两个过程：

```java
Person per;  //定义变量
per = new Person(); //赋值
```

在执行Person per;时，JVM先在虚拟机栈中的变量表中开辟一块内存存放per变量，在执行per=new Person()时，JVM会创建一个Person类的实例对象并在堆中开辟一块内存存储这个实例，同时把实例的地址值赋值给per变量。

**对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。**

# 值传递和引用传递

前面已经介绍过形参和实参，也介绍了数据类型以及数据在内存中的存储形式，接下来，就是文章的主题：值传递和引用的传递。

## 值传递

在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。

### 例子

```java
public static void callByValue(int age, int grade) {
    System.out.println("param age: " + age);
    System.out.println("param grade: " + grade);
    age = -1;
    grade = -1;
    System.out.println("reset age: " + age);
    System.out.println("reset grade: " + grade);
}

public static void main(String[] args) {
    int age = 10;
    int grade = 3;
    callByValue(age, grade);
    System.out.println("main age: " + age);
    System.out.println("main grade: " + grade);
}
```

- 日志结果

```
param age: 10
param grade: 3
reset age: -1
reset grade: -1
main age: 10
main grade: 3
```

可见方法内虽然赋值了，但是值本身实际在 main() 中是没有变化的。

### 简单分析

实际上，age 和 grade 的改动，只是改变了当前栈帧（callByValue方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，mian方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出对应的值时，依然是初始化时的内容。

**值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。**

## 引用传递：

”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。

### 例子 1

```java
public static void changeName(Person person) {
    System.out.println("param name: " + person.getName());
    person.setName("我是张小龙");
    System.out.println("reset name: " + person.getName());
}

public static void main(String[] args) {
    Person person = new Person();
    person.setName("马化腾");
    changeName(person);
    System.out.println("main name: " + person.getName());
}
```

- 输出

```
param name: 马化腾
reset name: 我是张小龙
main name: 我是张小龙
```

你会发现名字确实被修改了？

那么我们可以直接说 java 是引用传递吗？

并不能，我们接着往下看。

### 例子 2

```java
public static void changeName(Person person) {
    System.out.println("param name: " + person.getName());
    person = new Person();  //加入这一行
    person.setName("我是张小龙");
    System.out.println("reset name: " + person.getName());
}

public static void main(String[] args) {
    Person person = new Person();
    person.setName("马化腾");
    changeName(person);
    System.out.println("main name: " + person.getName());
}
```

- 日志

```
param name: 马化腾
reset name: 我是张小龙
main name: 马化腾
```

看出什么问题了吗？

changeName 中对于对象的重新赋值，并没有改变 main 中的名称。为什么呢？


### 分析

按照上面讲到JVM内存模型可以知道，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到 main（）方法中的下列代码时

```java
Person person = new Person();
person.setName("马化腾");
person.setAge(1);

changeName(person);
```

JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：

![image](https://user-images.githubusercontent.com/18375710/87867287-fda9ff80-c9bd-11ea-8630-0617a480d1ed.png)

当执行 `changeName(person);` 时：

方法中包含这么一行：

```java
person = new Person();  //加入这一行
```

JVM需要在堆内另外开辟一块内存来存储 new Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：

**引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变。**


可以推出：实参也应该指向了新创建的person对象的地址，所以在执行 changeName 结束之后，最终输出的应该是后面创建的对象内容。

然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。

由此可见：**引用传递，在 Java 中并不存在。**

### 为什么第一个例子中值修改了呢？

但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？

这是因为：**无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身**。

![image](https://user-images.githubusercontent.com/18375710/87867316-5b3e4c00-c9be-11ea-8e38-cd29129075b0.png)

有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：

p和person都是指向同一个对象。

因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。

而在第二个例子中，当执行到new Person()之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：

p依旧是指向旧的对象，person指向新对象的地址。

所以此时对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系。

## 总结

因此可见：在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。

只是在传递过程中：

如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。

如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。

一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。


## 个人收获

这篇博客原博主整理的非常细致，其实网上有很多内容都是错误的，而且很多人只是停留在值不变所以是值传递。

或者很多人根本就不知道是值传递。

像我个人是从 c/c++ 开始学起的，所以知道引用传递；很多人如果从 java 学起，可能是不知道引用传递这个概念的。

要理解这个问题，需要对 jvm 有一定的理解，整个知识的论证过程也是循循善诱，值得学习！

# 参考资料

[关于值传递与引用传递](https://github.com/Snailclimb/JavaGuide/issues/12)

[这一次，彻底解决Java的值传递和引用传递](https://juejin.im/post/5bce68226fb9a05ce46a0476)

* any list
{:toc}