---
layout: post
title:  操作系统学习(8)内存分配
date:  2020-10-4 11:18:54 +0800
categories: [OS]
tags: [os, sf]
published: true
---

# 内存连续分配管理方式

连续分配方式，是指为一个用户程序分配一个连续的内存空间。它主要包括单一连续分配、固定分区分配和动态分区分配。

## 单一连续分配

内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户区是为用户提供的、除系统区之外的内存空间。

这种方式无需进行内存保护。

这种方式的优点是简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持。

缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。

## 固定分区分配

固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。

当有空闲分区时，便可以再从外存的后备作业队列中,选择适当大小的作业装入该分区，如此循环。

- 图 3-4  固定分区分配的两种方法

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/111357_721902be_508704.png)

固定分区分配在划分分区时，有两种不同的方法，如图3-4所示。

分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。

分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。

为便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，其中各表项包括每个分区的起始地址、大小及状态（是否已分配），如图3-5(a)所示。

当有用户程序要装入时，便检索该表，以找到合适的分区给予分配并将其状态置为”已分配”；未找到合适分区则拒绝为该用户程序分配内存。存储空间的分配情况如图3-5(b)所示。

这种分区方式存在两个问题：一是程序可能太大而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间；二是主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部有空间浪费，这种现象称为内部碎片。

固定分区是可用于多道程序设计最简单的存储分配，无外部碎片，但不能实现多进程共享一个主存区，所以存储空间利用率低。固定分区分配很少用于现在通用的操作系统中，但在某些用于控制多个相同对象的控制系统中仍发挥着一定的作用。

- 图3-5  固定分区说明表和内存分配情况

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/111810_4872b982_508704.png)

## 动态分区分配

动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。

这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。

因此系统中分区的大小和数目是可变的。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/112112_5463c70f_508704.png)

如图3-6所示，系统有64MB内存空间，其中低8MB固定分配给操作系统，其余为用户可用内存。

开始时装入前三个进程，在它们分别分配到所需空间后，内存只剩下4MB，进程4无法装入。

在某个时刻，内存中没有一个就绪进程，CPU出现空闲，操作系统就换出进程2，换入进程4。

由于进程4比进程2小，这样在主存中就产生了一个6MB的内存块。之后CPU又出现空闲，而主存无法容纳进程2,操作系统就换出进程1，换入进程2。

动态分区在开始分配时是很好的，但是之后会导致内存中出现许多小的内存块。

随着时间的推移，内存中会产生越来越多的碎片（图3-6中最后的4MB和中间的6MB，且随着进程的换入/换出，很可能会出现更多更小的内存块)，内存的利用率随之下降。这些小的内存块称为外部碎片，指在所有分区外的存储空间会变成越来越多的碎片，这与固定分区中的内部碎片正好相对。

克服外部碎片可以通过紧凑（Compaction)技术来解决，就是操作系统不时地对进程进行移动和整理。

但是这需要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于Windows系统中的磁盘整理程序，只不过后者是对外存空间的紧凑。

### 分配策略

在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略，考虑以下几种算法：

首次适应(First  Fit)算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。

最佳适应(Best  Fit)算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。

最坏适应(Worst  Fit)算法：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。

邻近适应(Next  Fit)算法：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从上次查找结束的位置开始继续查找。

在这几种方法中，首次适应算法不仅是最简单的，而且通常也是最好和最快的。

在UNIX 系统的最初版本中，就是使用首次适应算法为进程分配内存空间，其中使用数组的数据结构 (而非链表）来实现。

不过，首次适应算法会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。

邻近适应算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间（因为在一遍扫描中，内存前面部分使用后再释放时，不会参与分配)，分裂成小碎片。它通常比首次适应算法的结果要差。

最佳适应算法虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，它会产生最多的外部碎片。

最坏适应算法与最佳适应算法相反，选择最大的可用块，这看起来最不容易产生碎片，但是却把最大的连续内存划分开，会很快导致没有可用的大的内存块，因此性能也非常差。

### 实验对比

Kunth和Shore分别就前三种方法对内存空间的利用情况做了模拟实验，结果表明：

**首次适应算法可能比最佳适应法效果好，而它们两者一定比最大适应法效果好。**

另外注意,在算法实现时,分配操作中最佳适应法和最大适应法需要对可用块进行排序或遍历查找，而首次适应法和邻近适应法只需要简单查找；

回收操作中，当回收的块与原来的空闲块相邻时（有三种相邻的情况，比较复杂)，需要将这些块合并。

在算法实现时，使用数组或链表进行管理。除了内存的利用率，这里的算法开销也是操作系统设计需要考虑的一个因素。

- 表 3-1 三种内存分区管理方式的比较

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/113327_878eb169_508704.png)

以上三种内存分区管理方法有一共同特点，即用户进程（或作业）在主存中都是连续存放的。

这里对它们进行比较和总结，见表3-1。

# 内存非连续分配管理方式

非连续分配允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定分为分页存储管理方式和分段存储管理方式。

分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。

下面介绍基本分页存储管理方式。

## 基本分页存储管理方式

固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。

我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。

每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。

分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。

但它又有本质的不同点：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。

这样，**进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片（也称页内碎片）**。

### 1) 分页存储的几个基本概念

①页面和页面大小。进程中的块称为页(Page)，内存中的块称为页框（Page Frame，或页帧）。外存也以同样的单位进行划分，直接称为块(Block)。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。

为方便地址转换，页面大小应是2的整数幂。同时页面大小应该适中，如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页内碎片增大，降低内存的利用率。所以页面的大小应该适中，考虑到耷间效率和时间效率的权衡。

②地址结构。分页存储管理的逻辑地址结构如图3-7所示。

- 图 3-7 分页存储管理的地址结构

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/114128_2a51c6b2_508704.png)

地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量W。地址长度为32 位，其中0~11位为页内地址，即每页大小为4KB；12~31位为页号，地址空间最多允许有220页。

③页表。为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。

在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。

可见，页表的作用是**实现从页号到物理块号的地址映射**，如图3-8所示。

- 图 3-8  页表的作用

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/114221_b6994f49_508704.png)

### 2) 基本地址变换机构

地址变换机构的任务是将逻辑地址转换为内存中物理地址，地址变换是借助于页表实现的。图3-9给出了分页存储管理系统中的地址变换机构。

- 图 3-9  分页存储管理的地址变换机构

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/114437_09985e7d_508704.png)

在系统中通常设置一个页表寄存器(PTR)，存放页表在内存的始址F和页表长度M。

进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，才将页表始址和长度存入页表寄存器。设页面大小为L，逻辑地址A到物理地址E的变换过程如下：

1. 计算页号P(P=A/L)和页内偏移量W (W=A%L)。

2. 比较页号P和页表长度M，若P >= M，则产生越界中断，否则继续执行。

3. 页表中页号P对应的页表项地址 = 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为物理块号。

4. 计算E=b*L+W，用得到的物理地址E去访问内存。

以上整个地址变换过程均是由硬件自动完成的。

### 例子

例如，若页面大小L为1K字节，页号2对应的物理块为b=8，计算逻辑地址A=2500 的物理地址E的过程如下：P=2500/1K=2，W=2500%1K=452，查找得到页号2对应的物理块的块号为 8，E=8*1024+452=8644。

下面讨论分页管理方式存在的两个主要问题：

（1）每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低；

（2）每个进程引入了页表，用于存储映射机制，页表不能太大，否则内存利用率会降低。

### 3) 具有快表的地址变换机构

由上面介绍的地址变换过程可知，若页表全部放在内存中，则存取一个数据或一条指令至少要访问两次内存：一次是访问页表，确定所存取的数据或指令的物理地址，第二次才根据该地址存取数据或指令。

显然，这种方法比通常执行指令的速度慢了一半。

为此，在地址变换机构中增设了一个具有并行查找能力的高速缓冲存储器——快表，又称联想寄存器(TLB)，用来存放当前访问的若干页表项，以加速地址变换的过程。

与此对应，主存中的页表也常称为慢表，配有快表的地址变换机构如图3-10所示。

- 图 3-10 具有快表的地址变换机构

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/114835_c1f1ff9a_508704.png "屏幕截图.png")

在具有快表的分页机制中，地址的变换过程：

1. CPU给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。

2. 如果找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。

3. 如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。

注意：有些处理机设计为快表和慢表同时查找，如果在快表中查找成功则终止慢表的查找。

一般快表的命中率可以达到90%以上，这样，分页带来的速度损失就降低到10%以下。

快表的有效性是基于著名的局部性原理，这在后面的虚拟内存中将会具体讨论。

### 4) 两级页表

第二个问题：由于引入了分页管理，进程在执行时不需要将所有页调入内存页框中，而只要将保存有映射关系的页表调入内存中即可。但是我们仍然需要考虑页表的大小。

以32 位逻辑地址空间、页面大小4KB、页表项大小4B为例，若要实现进程对全部逻辑地址空间的映射，则每个进程需要220，约100万个页表项。也就是说，每个进程仅页表这一项就需要4MB主存空间，这显然是不切实际的。

而即便不考虑对全部逻辑地址空间进行映射的情况，一个逻辑地址空间稍大的进程，其页表大小也可能是过大的。以一个40MB的进程为例，页表项共40KB,如果将所有页表项内容保存在内存中，那么需要10个内存页框来保存整个页表。整个进程大小约为1万个页面，而实际执行时只需要几十个页面进入内存页框就可以运行，但如果要求10个页面大小的页表必须全部进入内存，这相对实际执行时的几十个进程页面的大小来说，肯定是降低了内存利用率的；从另一方面来说，这10页的页表项也并不需要同时保存在内存中，因为大多数情况下，映射所需要的页表项都在页表的同一个页面中。

将页表映射的思想进一步延伸，就可以得到二级分页：将页表的10页空间也进行地址映射，建立上一级页表，用于存储页表的映射关系。这里对页表的10个页面进行映射只需要10个页表项，所以上一级页表只需要1页就足够（可以存储210=1024个页表项）。在进程执行时，只需要将这1页的上一级页表调入内存即可，进程的页表和进程本身的页面，可以在后面的执行中再i周入内存。

如图3-11所示，这是Intel处理器80x86系列的硬件分页的地址转换过程。在32位系统中，全部32位逻辑地址空间可以分为220(4GB/4KB)个页面。这些页面可以再进一步建立顶级页表，需要210个顶级页表项进行索引，这正好是一页的大小，所以建立二级页表即可。

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/115311_c0468741_508704.png)

举例，32位系统中进程分页的工作过程：假定内核已经给一个正在运行的进程分配的逻辑地址空间是0x20000000到0x2003FFFF，这个空间由64个页面组成。在进程运行时，我们不需要知道全部这些页的页框的物理地址，很可能其中很多页还不在主存中。这里我们只注意在进程运行到某一页时，硬件是如何计算得到这一页的页框的物理地址即可。现在进程需要读逻辑地址0x20021406中的字节内容，这个逻辑地址按如下进行处理：

```
逻辑地址： 0x20021406 (0010 0000 0000 0010 0001 0100 0000 0110 B)
顶级页表字段：0x80 (00 1000 0000 B)
二级页表字段：0x21 (00 0010 0001B)
页内偏移量字段：0x406  (0100 0000 0110 B)
```

顶级页表字段的0x80用于选择顶级页表的第0x80表项，此表项指向和该进程的页相关的二级页表；二级页表字段0x21用于选择二级页表的第0x21表项，此表项指向包含所需页的页框；最后的页内偏移量字段0x406用于在目标页框中读取偏移量为0x406中的字节。

这是32位系统下比较实际的一个例子。

看似较为复杂的例子，有助于比较深入地理解，希望读者能自己动手计算一遍转换过程。

建立多级页表的目的在于建立索引，这样不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项，而建立索引的要求是最高一级页表项不超过一页的大小。

在64位操作系统中，页表的划分则需要重新考虑，这是很多教材和辅导书中的常见题目，但是很多都给出了错误的分析，需要注意。

我们假设仍然釆用4KB页面大小。偏移量字段12位，假设页表项大小为8B。

这样，其上一级分页时，每个页框只能存储29(4KB/8B)个页表项，而不再是210个，所以上一级页表字段为9位。后面同理继续分页。64=12+9+9+9+9+9+7，所以需6级分页才能实现索引。很多书中仍然按4B页表项分析，虽然同样得出6级分页的结果，但显然是错误的。

这里给出两个实际的64位操作系统的分页级别（注意：里面没有使用全部64位寻址，不过由于地址字节对齐的设计考虑，仍然使用8B大小的页表项），理解了表3-2中的分级方式，相信对多级分页就非常清楚了。

- 表3-2 两种系统的分级方式

| 平台	   | 页面大小	| 寻址位数	 | 分页级数 |	具体分级 |
|:---|:---|:---|:---|:---|
| Alpha	   | 8KB	 |        43	|        3	     |13+10+10+10 |
| X86_64	| 4 KB	|     48	    |    4	     |12+9+9+9+9 |


# 基本分段存储管理方式

分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明；

而分段管理方式的提出则是**考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要**。

## 1) 分段。

段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的）。

其逻辑地址由段号S与段内偏移量W两部分组成。

在图3-12中，段号为16位，段内偏移量为16位，则一个作业最多可有216=65536个段，最大段长为64KB。

- 图 3-12  分段系统中的逻辑地址结构

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/120403_097c7825_508704.png "屏幕截图.png")

在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在髙级程序设计语言中，这个工作由编译程序完成。

## 2) 段表。

每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个段表项对应进程的一个段，段表项记录该段在内存中的起始地址和段的长度。

段表的内容如图3-13所示。

- 图 3-13  段表项

```
| 段号 | 段长| 本段在主存的起始地址 |
```

在配置了段表后，执行中的进程可通过查找段表，找到每个段所对应的内存区。

可见，段表用于实现从逻辑段到物理内存区的映射，如图3-14所示。

- 图 3-14 利用段表实现地址映射

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/120624_497b8d2c_508704.png)

## 3) 地址变换机构。

分段系统的地址变换过程如图3-15所示。

为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。其从逻辑地址A到物理地址E之间的地址变换过程如下：

1. 从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。
2. 比较段号S和段表长度M，若S多M，则产生越界中断，否则继续执行。

3. 段表中段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量>=C，则产生越界中断，否则继续执行。

4. 取出段表项中该段的起始地址b，计算 E = b + W，用得到的物理地址E去访问内存。

- 图3-15  分段系统的地址变换过程

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/120711_eca509c8_508704.png)

## 4) 段的共享与保护。

在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。

当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。不能修改的代码称为纯代码或可重入代码（它不属于临界资源)，这样的代码和不能修改的数据是可以共享的，而可修改的代码和数据则不能共享。

与分页管理类似，分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保护。

地址越界保护是利用段表寄存器中的段表长度与逻辑地址中的段号比较，若段号大于段表长度则产生越界中断；再利用段表项中的段长和逻辑地址中的段内位移进行比较，若段内位移大于段长，也会产生越界中断。

# 段页式管理方式

页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。

如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。

在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。

对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位，如图3-16所示。

- 图3-16  段页式管理方式

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/121012_416e26e1_508704.png)

在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量，如图3-17 所示。

```
| 段号S | 页号P | 页内偏移量 W |
```

为了实现地址变换，系统为每个进程建立一张段表，而每个分段有一张页表。

段表表项中至少包括段号、页表长度和页表起始地址，页表表项中至少包括页号和块号。此外，系统中还应有一个段表寄存器，指出作业的段表起始地址和段表长度。

注意：在一个进程中，段表只有一个，而页表可能有多个。

在进行地址变换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。

如图3-18所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。

- 图3-18  段页式系统的地址变换机构

![输入图片说明](https://images.gitee.com/uploads/images/2020/1005/121236_3dadd711_508704.png)



# 参考资料

[操作系统的基本概念](http://c.biancheng.net/cpp/html/2579.html)

https://lgwain.gitbooks.io/os/content/unit11.html

* any list
{:toc}