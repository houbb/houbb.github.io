---
layout: post
title: privilege-08-PKCE（Proof Key for Code Exchange）
date: 2024-08-04 21:01:55 +0800
categories: [Design]
tags: [design, privilege, sh]
published: true
---


# chat

## 详细介绍一下 PKCE（Proof Key for Code Exchange）

PKCE（Proof Key for Code Exchange）是一种安全机制，用于增强OAuth 2.0授权流程的安全性，特别是在公共客户端（如移动设备或单页面应用程序）上。

PKCE是为了解决在这些环境下客户端密钥可能无法安全存储的问题而设计的。

以下是PKCE的关键概念和组成部分：

1. **授权码授权类型**：PKCE主要用于OAuth 2.0的授权码授权类型（Authorization Code Grant）。

2. **一次性代码验证器**：在PKCE流程中，客户端首先生成一个随机的代码验证器（code verifier），并将其传递给授权服务器以请求授权码。

3. **授权码请求**：客户端在请求授权码时，会同时发送一个代码挑战（code challenge）和代码挑战方法（code challenge method）。代码挑战是代码验证器的哈希值，而代码挑战方法通常使用SHA-256算法。

4. **交换授权码**：用户授权后，授权服务器会返回一个授权码。客户端随后使用这个授权码请求访问令牌（access token）。

5. **访问令牌请求**：在请求访问令牌时，客户端需要再次发送代码验证器。这确保了请求访问令牌的实体是最初请求授权码的同一实体。

6. **验证代码验证器**：授权服务器接收到访问令牌请求后，会验证代码验证器是否与之前请求授权码时接收的代码挑战匹配。如果匹配，授权服务器将发放访问令牌。

7. **安全性**：PKCE机制通过使用一次性的代码验证器和代码挑战，减少了授权码被拦截和重用的风险。

8. **无状态特性**：PKCE不要求授权服务器存储客户端密钥，因为每次请求都会附带代码验证器，这使得授权服务器可以是无状态的。

9. **适用场景**：PKCE特别适用于那些无法安全存储客户端密钥的场景，例如在用户的设备上运行的应用程序。

10. **标准支持**：PKCE被定义在RFC 7636中，是OAuth 2.0的正式扩展。

PKCE的工作流程如下：

1. 客户端生成一个代码验证器（`code_verifier`），并使用安全的方法（如SHA-256）生成其哈希值，得到代码挑战（`code_challenge`）。

2. 客户端向授权服务器请求授权码，附带`code_challenge`和`code_challenge_method`（通常是"S256"）。

3. 用户同意授权后，授权服务器返回授权码给客户端。

4. 客户端使用授权码、`code_verifier`和客户端凭据向授权服务器请求访问令牌。

5. 授权服务器验证`code_verifier`是否与之前接收的`code_challenge`匹配。如果验证成功，授权服务器发放访问令牌。

通过PKCE，即使在客户端密钥可能被泄露的情况下，也能保护OAuth 2.0流程的安全性。

## 除了 PKCE，还有哪些 OAuth 2.0 的安全机制可以提高授权流程的安全性？

除了PKCE，OAuth 2.0 还提供了其他一些安全机制来提高授权流程的安全性：

1. **State参数**：在OAuth 2.0的授权码模式中，客户端在请求授权时会发送一个`state`参数，服务器在重定向时会将这个参数原样返回。这可以用来防御CSRF攻击，确保请求的来源是可信的。

2. **Redirect URI白名单**：在授权服务器上配置Redirect URI白名单，只允许客户端在这些URI中进行重定向，这可以防止开放重定向攻击。

3. **Scope校验**：授权服务器需要验证请求的作用域（scope）是否与授权请求中的作用域一致，以防止攻击者在授权过程中添加额外的作用域来获取更多的权限。

4. **HTTPS使用**：OAuth 2.0 强烈建议使用HTTPS来保护客户端与授权服务器之间的通信，以防止中间人攻击。

5. **Client ID和Client Secret的绑定关系校验**：授权服务器需要严格校验`client_id`和`auth_code`的绑定关系，以防止授权码被其他用户窃取后申请到访问令牌。

6. **跨站图片或XSS漏洞防护**：除了OAuth 2.0本身的安全机制外，还需要防护可能结合XSS等漏洞的攻击，确保OAuth流程的安全性。

7. **令牌的短时效性**：OAuth 2.0提供的访问令牌（access token）通常具有较短的有效期，这减少了令牌被盗用的风险。

8. **刷新令牌（Refresh Token）**：OAuth 2.0 允许使用刷新令牌来获取新的访问令牌，而无需用户重新授权，这增加了灵活性并减少了用户需要频繁登录的不便。

9. **授权类型（Grant Types）**：OAuth 2.0定义了多种授权类型，如授权码授权、密码授权、客户端凭据授权等，适应不同的使用场景并提供相应的安全措施。

10. **使用OAuth 2.0的安全最佳实践**：例如，对于纯前端应用，可以使用implicit模式，但对于有后端的应用，则推荐使用authorization code模式，并在后端服务器之间进行token的交换，以避免敏感信息泄露。

通过这些安全机制，OAuth 2.0 能够在多种应用场景中提供安全、灵活的授权服务。


* any list
{:toc}