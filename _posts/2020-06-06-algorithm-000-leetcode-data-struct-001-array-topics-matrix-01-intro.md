---
layout: post
title:  【leetcode】力扣矩阵 matrix -01-入门介绍
date:  2020-6-8 15:13:08 +0800
categories: [Algorithm]
tags: [algorithm, data-struct, matrix, leetcode]
published: true
---

# 开源地址

为了便于大家学习，所有实现均已开源。欢迎 fork + star~

> [https://github.com/houbb/leetcode](https://github.com/houbb/leetcode)

# 详细介绍一下力扣矩阵

“力扣矩阵”这个说法可能是你指代 LeetCode（力扣）中与 **矩阵相关的算法题**，这种类型的题目在刷题中很常见，主要考察二维数组的遍历、状态转移、路径搜索、动态规划等技巧。

下面我将详细介绍：

---

## 🧩 力扣矩阵题型分类总览

| 类型       | 说明                 | 典型例题                         |
| -------- | ------------------ | ---------------------------- |
| 遍历类      | 按行、按列、对角线、螺旋等方式遍历  | 54 螺旋矩阵、498 对角线遍历            |
| 搜索类      | DFS / BFS 遍历路径、连通块 | 200 岛屿数量、695 最大岛屿面积          |
| 路径类      | 从左上到右下的最短路径、最大路径   | 64 最小路径和、62 不同路径             |
| 动态规划     | 依赖前状态来更新当前状态       | 64 最小路径和、221 最大正方形           |
| 模拟类      | 需要模拟某种操作或规律        | 59 螺旋矩阵 II、73 矩阵置零           |
| 前缀和 / 差分 | 快速计算子矩阵和           | 304 二维区域和检索、1094 拼车          |
| 状态压缩     | 将矩阵转为位图进行优化        | 980 不同路径 III、1349 参加考试的最大学生数 |

---

## 🧠 常用基础知识

### ✅ 二维数组声明 & 遍历

```java
int[][] matrix = new int[m][n];

// 行优先遍历
for (int i = 0; i < m; i++) {
    for (int j = 0; j < n; j++) {
        System.out.println(matrix[i][j]);
    }
}
```

---

### ✅ 常见方向数组（上下左右、八方向）

```java
// 上下左右
int[][] directions = {{-1,0}, {1,0}, {0,-1}, {0,1}};

// 八个方向（对角线）
int[][] directions8 = {
    {-1,-1}, {-1,0}, {-1,1},
    { 0,-1},        { 0,1},
    { 1,-1}, { 1,0}, { 1,1}
};
```

---

## 💡 重点题型详解

### 1️⃣ 螺旋遍历类

#### 示例：LeetCode 54 - 螺旋矩阵

```text
输入：
[
 [1, 2, 3],
 [4, 5, 6],
 [7, 8, 9]
]

输出：[1,2,3,6,9,8,7,4,5]
```

🧠 思路：

* 用四个边界：`top`, `bottom`, `left`, `right`
* 每次按顺时针走一圈，收缩边界

---

### 2️⃣ 搜索连通块类

#### 示例：LeetCode 200 - 岛屿数量

```text
输入：
[
 ["1","1","0","0"],
 ["1","0","0","1"],
 ["0","0","1","1"]
]

输出：3
```

🧠 思路：

* 遍历每个点，遇到 “1” 就 DFS/BFS，把连通的 “1” 都淹掉
* 遍历中统计启动次数即为岛屿数

---

### 3️⃣ 最短路径类（BFS）

#### 示例：LeetCode 1091 - 二进制矩阵中的最短路径

* 起点 (0,0)，终点 (n-1,n-1)，八方向移动

🧠 思路：

* BFS 层序遍历，找到最短路径
* 维护访问数组避免死循环

---

### 4️⃣ 最小路径和类（动态规划）

#### 示例：LeetCode 64 - 最小路径和

```text
输入：
[
 [1,3,1],
 [1,5,1],
 [4,2,1]
]
输出：7
```

🧠 思路：

* 状态定义：dp\[i]\[j] 为到达 (i,j) 的最小路径和
* 转移方程：`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`

---

### 5️⃣ 模拟类

#### 示例：LeetCode 73 - 矩阵置零

```text
如果某个元素为 0，则其所在行列都变成 0
```

🧠 思路：

* 先记录所有需要置零的行和列
* 再二次遍历将对应行列置零

---

### 6️⃣ 前缀和 / 差分类

#### 示例：LeetCode 304 - 二维区域和检索

🧠 思路：

* 构建二维前缀和数组 preSum\[i]\[j]
* 任意子矩阵和 = 右下 - 上方 - 左边 + 左上

---

### 7️⃣ 状态压缩类

#### 示例：LeetCode 1349 - 参加考试的最大学生数

🧠 思路：

* 每一行可能的坐法可以用 bitmask 表示
* 状态转移时需要判断两行之间是否冲突
* 用 `dp[row][state]` 表示第 row 行状态为 state 时的最大人数

---

## 📚 推荐刷题顺序（由浅入深）

| 阶段    | 推荐题目编号          |
| ----- | --------------- |
| 入门遍历  | 54、59、498       |
| 简单 DP | 62、63、64、120    |
| 中等搜索  | 200、695、733、542 |
| 高阶 DP | 221、85、1277     |
| 前缀和   | 304、1314        |
| 状态压缩  | 1349、980        |

---

## 🧰 常见技巧小结

| 技巧         | 用途             |
| ---------- | -------------- |
| 标记 visited | DFS/BFS 防止重复访问 |
| 多方向遍历      | 搜索类题目必备        |
| 动态规划       | 优化搜索，避免重复计算    |
| 状态压缩       | 在矩阵规模大时减少空间复杂度 |
| 二维前缀和      | 快速求子矩阵和        |
| 滑动窗口       | 图像处理或热力图类题目    |

# 小结

希望本文对你有帮助，如果有其他想法的话，也可以评论区和大家分享哦。

各位极客的点赞收藏转发，是老马持续写作的最大动力！

感兴趣的小伙伴可以关注一波，精彩内容，不容错过。

# 参考资料

* any list
{:toc}