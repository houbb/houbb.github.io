---
layout: post
title:  Hash
date:  2018-05-30 09:57:55 +0800
categories: [Algorithm]
tags: [algorithm, hash]
published: true
---

# Hash 算法

散列表（Hash table，也叫哈希表），是依据关键码值(Key value)而直接进行訪问的数据结构。

也就是说，它通过把关键码值映射到表中一个位置来訪问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

## 基础概念

比方我们存储 70 个元素，但我们可能为这 70 个元素申请了 100 个元素的空间。

`70/100=0.7`，这个数字称为**负载因子**。

我们之所以这样做，也是为了“高速存取”的目的。

我们基于一种结果尽可能随机平均分布的固定函数H为每一个元素安排存储位置，这样就能够避免遍历性质的线性搜索，以达到高速存取。

可是因为此随机性，也必定导致一个问题就是冲突。

所谓冲突，即两个元素通过散列函数H得到的地址同样，那么这两个元素称为“同义词”。

这类似于 70 个人去一个有 100 个椅子的饭店吃饭。散列函数的计算结果是一个存储单位地址，每一个存储单位称为“桶”。

设一个散列表有 m 个桶，则散列函数的值域应为`[0,m-1]`。

## 冲突

解决冲突是一个复杂问题。冲突主要取决于：

（1）散列函数，一个好的散列函数的值应尽可能平均分布。

（2）处理冲突方法。

（3）负载因子的大小。太大不一定就好，并且浪费空间严重，负载因子和散列函数是联动的。

为此，有很多 hash 算法为解决这些问题而生。

# 优秀的 hash 算法

## 特点

一个好的哈希函数必须具备以下两点特性：

- 一个好的哈希函数应该是可逆的。

对于哈希函数输入值 x 和输出值 y，如果存在 f(x) = y，就一定存在 g(y) = x。

说白了，就是哈希函数可以将某一个值x转换成一个key，也可以把这个key还原回成x。

具有可逆性的哈希函数可以从根本上消除哈希过程中的冲突(collisions)。

- 一个好的哈希函数应该容易造成雪崩效应。

这里的雪崩效应是从比特位的角度出发的，它指的是，输入值1bit位的变化会造成输出值1/2的bit位发生变化。

哈希函数应只负责将输入值尽量均匀的分布在某一空间，而不管实际的物理内存是否可以容纳该空间。

我们可以将放置哈希结果的物理内存块的大小设置成2的n次方的形式。

这条特性的主要目的是使得哈希结果更为离散均匀。

## 可逆性

- 简单例子

以下式子都是可逆的：

```
x + 常数 = y;
x - 常数 = y;
x ^ 常数 = y;
~x = y;
x * 常数 =y;
```

- 个人理解

我觉得这部分应该是数学概念上的可逆性。

[反函数-百度百科](https://baike.baidu.com/item/%E5%8F%8D%E5%87%BD%E6%95%B0)

一般地，设函数 y=f(x)(x∈A) 的值域是 C，若找得到一个函数 g(y) 在每一处 g(y) 都等于 x，这样的函数 x= g(y)(y∈C) 叫做函数 y=f(x)(x∈A) 的反函数，
记作 y=f^(-1)(x) 。

反函数 `y=f^(-1)(x)` 的定义域、值域分别是函数y=f(x)的值域、定义域。最具有代表性的反函数就是对数函数与指数函数。

一般地，如果 x 与 y 关于某种对应关系 f(x) 相对应，y=f(x)，则 y=f(x) 的反函数为 x=f(y)。

**存在反函数(默认为单值函数）的条件是原函数必须是一一对应的（不一定是整个数域内的）**。

## 雪崩效应

雪崩效应之前也讲过，说白了，就是输入数据1bit位的变化会导致输出数据N bit位的变化，这个N是大于等于1/2输出数据长度的。我们还是从简单的运算说起。

备注：b 代表二进制

- 加减运算

加减运算很容易引起雪崩响应，这很容易理解，例如

```
1111b + 1b = 10000b
```

or

```
1000b - 1b = 111b
```

- 位移运算

取反运算也很容易产生雪崩效应，例如(00001111)2  << 2 = (00111100)2。

```
00001111b << 2 = 00111100b
```

- 乘除运算

乘除运算的本质就是位移与加减法的组合，所以也是可以一起雪崩效应的。

- 取反、异或运算

取反和异或运算也很容易产生雪崩效应，如

```
~1111b =0000b
```

and 

```
1101b ^ 1010b = 0111b
```

# 常见 hash 算法

## 32 bit MixFunction

这个函数都是由我们上面讨论的一些基本的式子，之所以让采用自身赋值（即 f(key) = key ）的原因是为了传递可逆性与雪崩效应。

```c
/* Thomas Wang's32 bit Mix Function */
unsigned intdictIntHashFunction(unsigned int key)
{
    key += ~(key << 15);
    key ^= (key >> 10);
    key += (key << 3);
    key ^= (key >> 6);
    key += ~(key << 11);
    key ^= (key >> 16);
    return key;
}
```

## 64 bit Mix Functions

这是 redis 源码中的一个指纹生成函数，它会根据 dict 结构体的当前状态生成一个标识，
如果之后该结构体的内容发生变化，其指纹也会发生变化。

```java
/* A fingerprintis a 64 bit number that represents the state of the dictionary
 * at a given time, it's just a few dictproperties xored together.
 * When an unsafe iterator is initialized, weget the dict fingerprint, and check
 * the fingerprint again when the iterator isreleased.
 * If the two fingerprints are different itmeans that the user of the iterator
 * performed forbidden operations against thedictionary while iterating. */
long longdictFingerprint(dict *d) {
    long long integers[6], hash = 0;
    int j;
    //将dict结构体中的几个状态放入到数组中，以便后面应用到64 bit MixFunctions中。
    //dict结构体其实就是一个hash表的实现，而这些状态其实就是第一、第二哈希表的表地址、表大小与
    //已用条目的数量
    integers[0] = (long) d->ht[0].table;
    integers[1] = d->ht[0].size;
    integers[2] = d->ht[0].used;
    integers[3] = (long) d->ht[1].table;
    integers[4] = d->ht[1].size;
    integers[5] = d->ht[1].used;
 
    /* We hash N integers by summing everysuccessive integer with the integer
     * hashing of the previous sum. Basically:
     *
     * Result =hash(hash(hash(int1)+int2)+int3) ...
     *
     * This way the same set of integers in adifferent order will (likely) hash
     * to a different number. */
    //利用64 bit Mix Functions，将这些状态信息混合到hash中，组成最后的指纹，如果这些状态中有一个
    //出现变化，可以通过一个算法逆推出该状态变化之前的值。例如，d->ht[0].size发生变化，则我们可
    //以通过hash和其他的几个状态，逆推出d->ht[0].size的最初值。
    for (j = 0; j < 6; j++) {
        hash += integers[j];
        /* For the hashing step we use TomasWang's 64 bit integer hash. */
        hash = (~hash) + (hash << 21); //hash = (hash << 21) - hash - 1;
        hash = hash ^ (hash >> 24);
        hash = (hash + (hash << 3)) +(hash << 8); // hash * 265
        hash = hash ^ (hash >> 14);
        hash = (hash + (hash << 2)) +(hash << 4); // hash * 21
        hash = hash ^ (hash >> 28);
        hash = hash + (hash << 31);
    }
    return hash;
}
```

## MurmurHash2

MurmurHash是一种很出名的非加密型哈希函数，适用于一般的哈希检索操作。

目前有三个版本（MurmurHash1、MurmurHash2、MurmurHash3）。

- 算法思想

该算法的基本思想就是把 key 分成 n 组，每组 4 个字符，把这 4 个字符看成是一个 uint_32，进行 n 次运算，
得到一个 h，然会在对 h 进行处理，得到一个相对离散的哈希结果。

```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * This is a very fast, non-cryptographic hash suitable for general hash-based
 * lookup. See http://murmurhash.googlepages.com/ for more details.
 * <p/>
 * <p>
 * The C version of MurmurHash 2.0 found at that site was ported to Java by
 * Andrzej Bialecki (ab at getopt org).
 * </p>
 */
public class MurmurHash {
    
    private static final String UTF_8 = "UTF-8";

    public static long hash64A(byte[] data, int seed) {
        return hash64A(ByteBuffer.wrap(data), seed);
    }

    public static long hash64A(ByteBuffer buf, int seed) {
        ByteOrder byteOrder = buf.order();
        buf.order(ByteOrder.LITTLE_ENDIAN);

        long m = 0xc6a4a7935bd1e995L;
        int r = 47;

        long h = seed ^ (buf.remaining() * m);

        long k;
        while (buf.remaining() >= 8) {
            k = buf.getLong();

            k *= m;
            k ^= k >>> r;
            k *= m;

            h ^= k;
            h *= m;
        }

        if (buf.remaining() > 0) {
            ByteBuffer finish = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN);
            // for big-endian version, do this first:
            // finish.position(8-buf.remaining());
            finish.put(buf).rewind();
            h ^= finish.getLong();
            h *= m;
        }

        h ^= h >>> r;
        h *= m;
        h ^= h >>> r;

        buf.order(byteOrder);
        return h;
    }

    public long hash(byte[] key) {
        return hash64A(key, 0x1234ABCD);
    }

    public long hash(String key) {
        return hash(encode(key));
    }

    private byte[] encode(String data) {
        try {
            return data.getBytes(UTF_8);
        } catch (UnsupportedEncodingException e) {
            throw new IllegalArgumentException(e);
        }
    }
}
```

# djb hash

djb 哈希算法很简单，只有几行代码，其功能与 MurmurHash 类似，都是将字符串转换为 hash 值，下面是它的代码：

```c
/* And a caseinsensitive hash function (based on djb hash) */
unsigned int dictGenCaseHashFunction(constunsigned char *buf, int len) {
    unsigned int hash = (unsignedint)dict_hash_function_seed;
 
    while (len--)
        hash = ((hash << 5) + hash) +(tolower(*buf++)); /* hash * 33 + c */
    return hash;
}
```

# 参考资料

- hash 算法

http://web.archive.org/web/20071223173210/http://www.concentric.net/~Ttwang/tech/inthash.htm

https://segmentfault.com/a/1190000010990136

https://blog.csdn.net/jasper_xulei/article/details/18364313

https://www.cnblogs.com/hzorac/p/5399042.html

https://www.jianshu.com/p/32faad2d711f

http://blog.jobbole.com/106733/

https://blog.csdn.net/tanggao1314/article/details/51457585

- 反函数

[反函数定理](https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%87%BD%E6%95%B0%E5%AE%9A%E7%90%86)

https://blog.csdn.net/u010182633/article/details/64501915


- 感知 Hash 算法

https://blog.csdn.net/whuhan2013/article/details/50993146

* any list
{:toc}