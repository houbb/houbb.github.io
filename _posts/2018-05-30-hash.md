---
layout: post
title:  Hash
date:  2018-05-30 09:57:55 +0800
categories: [Algorithm]
tags: [algorithm, hash]
published: true
---

# Hash 算法

散列表（Hash table，也叫哈希表），是依据关键码值(Key value)而直接进行訪问的数据结构。

也就是说，它通过把关键码值映射到表中一个位置来訪问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

## 基础概念

比方我们存储 70 个元素，但我们可能为这 70 个元素申请了 100 个元素的空间。

`70/100=0.7`，这个数字称为**负载因子**。

我们之所以这样做，也是为了“高速存取”的目的。

我们基于一种结果尽可能随机平均分布的固定函数H为每一个元素安排存储位置，这样就能够避免遍历性质的线性搜索，以达到高速存取。

可是因为此随机性，也必定导致一个问题就是冲突。

所谓冲突，即两个元素通过散列函数H得到的地址同样，那么这两个元素称为“同义词”。

这类似于 70 个人去一个有 100 个椅子的饭店吃饭。散列函数的计算结果是一个存储单位地址，每一个存储单位称为“桶”。

设一个散列表有 m 个桶，则散列函数的值域应为`[0,m-1]`。

## 冲突

解决冲突是一个复杂问题。冲突主要取决于：

（1）散列函数，一个好的散列函数的值应尽可能平均分布。

（2）处理冲突方法。

（3）负载因子的大小。太大不一定就好，并且浪费空间严重，负载因子和散列函数是联动的。

为此，有很多 hash 算法为解决这些问题而生。

# hash 的介绍

- 参考

[The State of Hashing Algorithms — The Why, The How, and The Future](https://medium.com/zkcapital/the-state-of-hashing-algorithms-the-why-the-how-and-the-future-b21d5c0440de)

## Why

在学习区块链时，新来者听到的关键字之一是哈希和哈希算法的概念，对于安全性来说，哈希算法似乎无处不在。运行一个分散的网络和共识机器，比如通过p2p连接数万个节点的比特币(Bitcoin)或Ethereum (Ethereum)网络，既需要“信任”，也需要验证效率。

也就是说，这些系统需要以一种紧凑的格式对信息进行编码，以便其参与者能够安全、快速地进行验证。

比特币和Ethereum所处理的主要原语是块的概念，这是一个包含交易、时间戳和其他重要元数据的数据结构。
它们安全性的一个关键部分是能够将有关网络全局状态的大量信息压缩为一个短消息标准，如果需要的话，可以有效地验证这个标准，称为哈希。

从密码存储到文件验证系统，密码哈希到处都在使用。

**基本思想是使用确定性算法，它接受一个输入，每次生成一个固定长度的字符串。也就是说，使用相同的输入总是会得到相同的输出。**

决定论不仅对哈希很重要，而且单个位在不同输入之间的变化也会产生完全不同的哈希。

哈希算法的一个问题是不可避免的冲突。也就是说，哈希是一个固定长度的字符串这一事实意味着，对于我们能想象到的每一个输入，都有可能产生相同的哈希值。碰撞是坏的。这意味着，如果攻击者能够根据需要创建冲突，则攻击者可以将恶意文件或数据传递为具有正确、适当的散列并伪装成合法的。

一个好的哈希函数的目标是使攻击者很难找到生成相同哈希值的输入的方法计算哈希的效率不应该太高，因为这使得人为计算冲突对攻击者来说更容易。

哈希算法需要抵抗“前图像攻击”。也就是说，给定一个hash，计算retrace所采取的确定步骤来重现创建hash的值(即pre-image)应该非常困难。

```
Given s= hash(x), finding x should be near impossible.
```

综上所述，“好的”散列算法具有以下3个特性:

- 在输入中更改一个位应该会产生雪崩效应，并导致完全不同的散列

- 碰撞的概率应该很低吗

- 在某种程度上，不牺牲碰撞阻力的效率

# Breaking Hashes

最初的散列算法标准之一是MD5散列，它广泛用于文件完整性验证(校验和)，并在web应用程序数据库中存储散列密码。

它的功能非常简单，因为它为每个输入输出一个固定的128位字符串，并且在几轮之间使用简单的单向操作来计算它的确定性输出。

它的短输出长度和操作的简单性使得MD5非常容易被破坏，并且容易受到所谓的生日攻击(birthday attack)。

## birthday attack

你听说过这样一个事实吗?

如果你把23个人放在一个房间里，有50%的几率其中两个人同一天生日?把房间里的数字提高到70，你有99.9%的机会。

这源于我们所说的鸽子洞原理，这个原理大概是说，给100只鸽子和99个盒子把它们放进去，必须装满，一个盒子会共用2只鸽子。

也就是说，固定的输出约束意味着存在固定的排列程度，在此基础上可以找到碰撞。

实际上，MD5的抗碰撞能力非常弱，一个简单的2.4GHz奔腾处理器可以在几秒钟内计算出人工哈希碰撞。

此外，在当前web的早期，它的广泛使用已经在网上创建了大量泄漏的MD5预映像，只需对它们的散列进行简单的谷歌搜索就可以找到这些映像。

# Diversity and Evolution of Hashing Algorithms

## SHA1 & SHA2

NSA(是的，那个NSA)一直是哈希算法标准的先驱，他们最初提出的安全哈希算法(SHA1)创造了160位固定长度的输出。

不幸的是，SHA1仅仅通过增加输出长度、单向操作的数量和这些单向操作的复杂性改进了MD5，但是对于尝试不同攻击向量的更强大的机器，它没有提供任何基本的改进。

那么我们怎样才能做得更好呢?

## SHA3

2006年，美国国家标准与技术研究院(NIST)发布了一项竞赛，希望找到一种可以替代SHA2的产品，这种产品在内部结构上与SHA2有本质区别，从而成为一种标准。

因此，SHA3诞生于一种名为KECCAK(发音为ketch-ak)的哈希算法。

尽管有了这个名字，SHA3内部还是有很大的不同，它采用了一种被称为海绵结构的机制，这种机制使用随机排列来吸收和输出数据，
同时作为随机性的来源，为哈希算法的未来输入提供数据。

SHA3维护一个内部状态，其中包含更多与输出相关的信息，这使得它能够克服以前算法的局限性。NIST在2015年成为标准。

## Hashing and Proof of Work

当将哈希算法集成到区块链协议中时，更老的比特币都选择了SHA256，而Ethereum使用的是经过修改的SHA3 (KECCAK256)来证明其工作算法。
然而，使用工作证明为区块链选择哈希函数的一个重要质量是计算上述哈希的效率。

比特币SHA256的实现可以通过被称为应用专用集成电路(或asic)的专用硬件来特别高效地计算。

关于在挖掘池中使用asic以及它们如何使协议趋向于集中计算，已经写了很多。

也就是说，工作证明鼓励计算效率高的计算机组聚合到池中，并增加我们所表示的“哈希能力”，即机器每隔一段时间可以计算的哈希数的度量。

Ethereum，选择了一个被称为KECCAK256的改良SHA3。

此外，Ethereum的工作证明算法Dagger-Hashimoto在硬件上是难以计算的内存。

## 比特币为什么选择 double SHA256

比特币使用SHA256进行数据哈希的方式很有趣，因为它在协议中对算法进行了两次迭代。

注意，这不是针对生日攻击的对策，因为很明显，如果hash(x) = hash(y)，那么hash(x)) = hash(y)。

相反，双SHA256用于减轻长度扩展攻击。

从本质上讲，这种攻击涉及到恶意的参与者，他们知道哈希输入的长度，可以通过向哈希值附加一个秘密字符串来欺骗哈希函数，使其开始其内部状态的某个部分。
SHA256是SHA2算法家族中的一员，它受到了这个问题的困扰，比特币通过计算两次哈希来减轻这个问题。

## Ethereum 2.0 and BLAKE

SHA3并不是NIST 2006年哈希竞赛的唯一突破。尽管SHA3赢了，一个被称为BLAKE的算法也紧随其后。
对于Ethereum 2.0的分片实现来说，更高效的哈希几乎是一个特性需求，也是研究团队非常重视的问题。
与KECCAK256相比，BLAKE2b哈希算法在保持高度安全性的同时，其出色的效率得到了广泛的探索。

在现代CPU上，计算BLAKE2b实际上比KECCAK快3倍。

# Moving Forward: The Future of Hashing Algorithms

似乎无论我们做什么，我们要么

(1)增加了内部哈希操作的复杂性，要么

(2)增加了哈希输出的长度，希望攻击者的计算机不能足够快地有效地计算冲突。

为了保证网络的安全，我们依赖于单向操作的前图像的模糊性。

也就是说，哈希算法的安全目标是使任何人尽可能难以找到两个哈希到相同输出的值，尽管可能存在无数次的冲突。

## 量子计算的未来呢?哈希算法安全吗?

简而言之，目前的理解是，哈希算法将经得起时间和量子计算的考验。

量子计算能够打破的是那些由精确的技巧和RSA加密等理论建立起来的严格的、基本的数学结构的问题。另一方面，哈希算法的内部结构不那么正式。

量子计算机的确提高了非结构化问题(如哈希)的计算速度，但最终，它们还是会像今天的计算机一样，强行发起攻击。

不管我们为协议选择什么算法，很明显我们正走向一个计算效率更高的未来，我们必须用我们最好的判断力来选择适合这项工作的工具，以及那些有望经得起时间考验的工具。

# 优秀的 hash 算法

## 特点

一个好的哈希函数必须具备以下两点特性：

- 一个好的哈希函数应该是可逆的。

对于哈希函数输入值 x 和输出值 y，如果存在 f(x) = y，就一定存在 g(y) = x。

说白了，就是哈希函数可以将某一个值x转换成一个key，也可以把这个key还原回成x。

具有可逆性的哈希函数可以从根本上消除哈希过程中的冲突(collisions)。

- 一个好的哈希函数应该容易造成雪崩效应。

这里的雪崩效应是从比特位的角度出发的，它指的是，输入值1bit位的变化会造成输出值1/2的bit位发生变化。

哈希函数应只负责将输入值尽量均匀的分布在某一空间，而不管实际的物理内存是否可以容纳该空间。

我们可以将放置哈希结果的物理内存块的大小设置成2的n次方的形式。

这条特性的主要目的是使得哈希结果更为离散均匀。

## 可逆性

- 简单例子

以下式子都是可逆的：

```
x + 常数 = y;
x - 常数 = y;
x ^ 常数 = y;
~x = y;
x * 常数 =y;
```

- 个人理解

我觉得这部分应该是数学概念上的可逆性。

[反函数-百度百科](https://baike.baidu.com/item/%E5%8F%8D%E5%87%BD%E6%95%B0)

一般地，设函数 y=f(x)(x∈A) 的值域是 C，若找得到一个函数 g(y) 在每一处 g(y) 都等于 x，这样的函数 x= g(y)(y∈C) 叫做函数 y=f(x)(x∈A) 的反函数，
记作 y=f^(-1)(x) 。

反函数 `y=f^(-1)(x)` 的定义域、值域分别是函数y=f(x)的值域、定义域。最具有代表性的反函数就是对数函数与指数函数。

一般地，如果 x 与 y 关于某种对应关系 f(x) 相对应，y=f(x)，则 y=f(x) 的反函数为 x=f(y)。

**存在反函数(默认为单值函数）的条件是原函数必须是一一对应的（不一定是整个数域内的）**。

## 雪崩效应

雪崩效应之前也讲过，说白了，就是输入数据1bit位的变化会导致输出数据N bit位的变化，这个N是大于等于1/2输出数据长度的。我们还是从简单的运算说起。

备注：b 代表二进制

- 加减运算

加减运算很容易引起雪崩响应，这很容易理解，例如

```
1111b + 1b = 10000b
```

or

```
1000b - 1b = 111b
```

- 位移运算

取反运算也很容易产生雪崩效应，例如(00001111)2  << 2 = (00111100)2。

```
00001111b << 2 = 00111100b
```

- 乘除运算

乘除运算的本质就是位移与加减法的组合，所以也是可以一起雪崩效应的。

- 取反、异或运算

取反和异或运算也很容易产生雪崩效应，如

```
~1111b =0000b
```

and 

```
1101b ^ 1010b = 0111b
```

# 常见 hash 算法

## 32 bit MixFunction

这个函数都是由我们上面讨论的一些基本的式子，之所以让采用自身赋值（即 f(key) = key ）的原因是为了传递可逆性与雪崩效应。

```c
/* Thomas Wang's32 bit Mix Function */
unsigned intdictIntHashFunction(unsigned int key)
{
    key += ~(key << 15);
    key ^= (key >> 10);
    key += (key << 3);
    key ^= (key >> 6);
    key += ~(key << 11);
    key ^= (key >> 16);
    return key;
}
```

## 64 bit Mix Functions

这是 redis 源码中的一个指纹生成函数，它会根据 dict 结构体的当前状态生成一个标识，
如果之后该结构体的内容发生变化，其指纹也会发生变化。

```java
/* A fingerprintis a 64 bit number that represents the state of the dictionary
 * at a given time, it's just a few dictproperties xored together.
 * When an unsafe iterator is initialized, weget the dict fingerprint, and check
 * the fingerprint again when the iterator isreleased.
 * If the two fingerprints are different itmeans that the user of the iterator
 * performed forbidden operations against thedictionary while iterating. */
long longdictFingerprint(dict *d) {
    long long integers[6], hash = 0;
    int j;
    //将dict结构体中的几个状态放入到数组中，以便后面应用到64 bit MixFunctions中。
    //dict结构体其实就是一个hash表的实现，而这些状态其实就是第一、第二哈希表的表地址、表大小与
    //已用条目的数量
    integers[0] = (long) d->ht[0].table;
    integers[1] = d->ht[0].size;
    integers[2] = d->ht[0].used;
    integers[3] = (long) d->ht[1].table;
    integers[4] = d->ht[1].size;
    integers[5] = d->ht[1].used;
 
    /* We hash N integers by summing everysuccessive integer with the integer
     * hashing of the previous sum. Basically:
     *
     * Result =hash(hash(hash(int1)+int2)+int3) ...
     *
     * This way the same set of integers in adifferent order will (likely) hash
     * to a different number. */
    //利用64 bit Mix Functions，将这些状态信息混合到hash中，组成最后的指纹，如果这些状态中有一个
    //出现变化，可以通过一个算法逆推出该状态变化之前的值。例如，d->ht[0].size发生变化，则我们可
    //以通过hash和其他的几个状态，逆推出d->ht[0].size的最初值。
    for (j = 0; j < 6; j++) {
        hash += integers[j];
        /* For the hashing step we use TomasWang's 64 bit integer hash. */
        hash = (~hash) + (hash << 21); //hash = (hash << 21) - hash - 1;
        hash = hash ^ (hash >> 24);
        hash = (hash + (hash << 3)) +(hash << 8); // hash * 265
        hash = hash ^ (hash >> 14);
        hash = (hash + (hash << 2)) +(hash << 4); // hash * 21
        hash = hash ^ (hash >> 28);
        hash = hash + (hash << 31);
    }
    return hash;
}
```

## MurmurHash2

MurmurHash是一种很出名的非加密型哈希函数，适用于一般的哈希检索操作。

目前有三个版本（MurmurHash1、MurmurHash2、MurmurHash3）。

- 算法思想

该算法的基本思想就是把 key 分成 n 组，每组 4 个字符，把这 4 个字符看成是一个 uint_32，进行 n 次运算，
得到一个 h，然会在对 h 进行处理，得到一个相对离散的哈希结果。

```java
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * This is a very fast, non-cryptographic hash suitable for general hash-based
 * lookup. See http://murmurhash.googlepages.com/ for more details.
 * <p/>
 * <p>
 * The C version of MurmurHash 2.0 found at that site was ported to Java by
 * Andrzej Bialecki (ab at getopt org).
 * </p>
 */
public class MurmurHash {
    
    private static final String UTF_8 = "UTF-8";

    public static long hash64A(byte[] data, int seed) {
        return hash64A(ByteBuffer.wrap(data), seed);
    }

    public static long hash64A(ByteBuffer buf, int seed) {
        ByteOrder byteOrder = buf.order();
        buf.order(ByteOrder.LITTLE_ENDIAN);

        long m = 0xc6a4a7935bd1e995L;
        int r = 47;

        long h = seed ^ (buf.remaining() * m);

        long k;
        while (buf.remaining() >= 8) {
            k = buf.getLong();

            k *= m;
            k ^= k >>> r;
            k *= m;

            h ^= k;
            h *= m;
        }

        if (buf.remaining() > 0) {
            ByteBuffer finish = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN);
            // for big-endian version, do this first:
            // finish.position(8-buf.remaining());
            finish.put(buf).rewind();
            h ^= finish.getLong();
            h *= m;
        }

        h ^= h >>> r;
        h *= m;
        h ^= h >>> r;

        buf.order(byteOrder);
        return h;
    }

    public long hash(byte[] key) {
        return hash64A(key, 0x1234ABCD);
    }

    public long hash(String key) {
        return hash(encode(key));
    }

    private byte[] encode(String data) {
        try {
            return data.getBytes(UTF_8);
        } catch (UnsupportedEncodingException e) {
            throw new IllegalArgumentException(e);
        }
    }
}
```

# djb hash

djb 哈希算法很简单，只有几行代码，其功能与 MurmurHash 类似，都是将字符串转换为 hash 值，下面是它的代码：

```c
/* And a caseinsensitive hash function (based on djb hash) */
unsigned int dictGenCaseHashFunction(constunsigned char *buf, int len) {
    unsigned int hash = (unsignedint)dict_hash_function_seed;
 
    while (len--)
        hash = ((hash << 5) + hash) +(tolower(*buf++)); /* hash * 33 + c */
    return hash;
}
```

# 参考资料

- hash 算法

http://web.archive.org/web/20071223173210/http://www.concentric.net/~Ttwang/tech/inthash.htm

https://segmentfault.com/a/1190000010990136

https://blog.csdn.net/jasper_xulei/article/details/18364313

https://www.cnblogs.com/hzorac/p/5399042.html

https://www.jianshu.com/p/32faad2d711f

http://blog.jobbole.com/106733/

https://blog.csdn.net/tanggao1314/article/details/51457585

- 反函数

[反函数定理](https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%87%BD%E6%95%B0%E5%AE%9A%E7%90%86)

https://blog.csdn.net/u010182633/article/details/64501915


- 感知 Hash 算法

https://blog.csdn.net/whuhan2013/article/details/50993146

* any list
{:toc}