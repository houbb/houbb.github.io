---
layout: post
title:  test mutation-00-变异测试概览
date:  2016-04-26 14:10:52 +0800
categories: [Test]
tags: [java, test]
published: true
---

# 拓展阅读

[test 系统学习-04-test converate 测试覆盖率 jacoco 原理介绍](https://houbb.github.io/2018/06/23/test-04-test-converage)

[test 系统学习-05-test jacoco 测试覆盖率与 idea 插件](https://houbb.github.io/2018/06/23/test-05-jacoco-idea-plugin)

[test 系统学习-06-test jacoco](https://houbb.github.io/2018/06/23/test-06-jacoco-overview)

[SonarQube](https://houbb.github.io/2016/10/14/sonarQube)

[Docker learn-29-docker 安装 sonarQube with mysql](https://houbb.github.io/2019/12/18/docker-learn-29-install-devops-sonar)

[Ubuntu Sonar](https://houbb.github.io/2018/08/14/ubuntu-sonar)



# chat

## 突变测试是什么？

突变测试是一种软件测试方法，其目的是评估测试套件对于代码变化的敏感性和有效性。

在突变测试中，测试代码的一部分（通常是通过引入故意的代码变化）被修改，然后运行测试套件来检查是否有测试用例能够检测到这些变化。如果测试套件能够发现变化，说明测试用例足够强大，能够捕捉到代码的变动；如果测试用例未能检测到变化，说明测试套件可能存在不足，需要进一步完善。

突变测试的核心思想是通过模拟代码中的错误变化，来评估测试用例的质量。这种方法有助于发现测试用例中的缺陷，提高测试套件的可靠性。

突变测试是一种动态分析方法，它不仅关注代码覆盖率，还着眼于测试用例是否能够捕捉到潜在的错误。

突变测试的基本步骤包括：

1. **变异：** 对源代码进行故意的变异操作，例如改变条件语句、修改运算符、删除或插入代码等。每一次变异都代表一个可能的错误情况。

2. **运行测试套件：** 使用变异后的代码运行测试套件。测试套件包含了一系列测试用例，用于验证程序的正确性。

3. **检测变异是否被杀死：** 如果测试套件能够检测到变异，即测试用例能够发现引入的错误，这个变异就被称为“被杀死”（killed）。如果测试套件未能检测到变异，即测试用例未能发现引入的错误，这个变异就被称为“存活”（alive）。

4. **生成报告：** 生成突变测试的报告，其中记录了每个变异的状态（被杀死或存活）、测试用例的执行情况以及其他相关信息。

突变测试的优势在于它可以帮助开发人员评估测试套件的质量，并指导他们改进测试用例以提高代码覆盖率和错误检测率。突变测试通常用于衡量测试套件对于软件代码的健壮性，尤其是在复杂系统中，它可以帮助发现潜在的、被遗漏的错误。


## PIT 变异测试是对常规的测试用例能力增强吗？和常规的 junit 的关系是什么？

是的，PIT的变异测试旨在增强常规测试用例的能力。变异测试通过在源代码中引入故意的变异，模拟潜在的错误情况，然后运行测试套件来检测这些变异。

如果测试用例能够发现引入的错误（即杀死变异），则说明测试用例具有足够的能力，能够捕获代码中的潜在问题。

如果测试用例未能检测到变异（即变异存活），则可能表示测试用例不足以捕捉到代码的某些错误情况，从而提供了有关测试覆盖不足的信息。

与常规的JUnit测试框架关系如下：

1. **JUnit测试用例：**
   - JUnit是一种常规的单元测试框架，用于编写和执行单元测试。开发人员使用JUnit编写测试用例来验证代码的正确性。
   - JUnit测试用例在常规情况下可能无法覆盖到所有潜在的错误情况，因为它们通常是基于预期输出的。变异测试的目的是通过引入潜在的错误情况，挑战并提高测试用例的质量。

2. **PIT变异测试：**
   - PIT是一个变异测试框架，与JUnit结合使用，用于增强测试用例的能力。PIT通过引入各种类型的变异，如修改条件语句、算术运算符等，来模拟可能的错误。
   - PIT执行变异测试，将测试用例应用于变异后的代码，并生成有关测试覆盖、变异存活/死亡等的详细报告。

3. **增强测试能力：**
   - 通过PIT的变异测试，开发人员能够识别测试用例的弱点，即那些不能捕获到的错误情况。这样，他们可以根据报告的信息来改进和完善测试用例，以提高测试覆盖率和质量。
   - 变异测试的结果可以指导开发人员了解测试用例对代码的哪些部分覆盖不足，从而提高代码的鲁棒性。

总体而言，PIT变异测试与JUnit紧密配合，帮助开发人员挑战和完善他们的测试用例，提高代码的测试覆盖率和质量。

## junit 中我们经常为测试编写断言，变异测试的话是如何确认断言，以及结果的正确性的？

在变异测试中，确认断言和结果的正确性是关键的一步。

由于**变异测试的目的是检查测试用例是否足够强大，能够捕捉引入的变异，因此需要一种机制来验证测试用例是否在变异的情况下能够正确地检测到错误**。

PITest（PIT）框架在变异测试中通过以下方式来确认断言和结果的正确性：

1. **变异测试报告：** PIT生成详细的变异测试报告，其中包含了每个变异的执行情况、测试用例的覆盖情况、变异是否被“杀死”等信息。

2. **被杀死的变异（Killed Mutants）：** 在变异测试中，如果测试用例能够检测到引入的错误（变异），则该变异被称为被杀死。变异测试报告会明确列出哪些变异被杀死，即测试用例能够成功地捕捉到变异并产生失败。

3. **存活的变异（Surviving Mutants）：** 如果测试用例未能检测到变异，该变异被称为存活。存活的变异表示测试用例在这种情况下可能不足以发现潜在问题。变异测试报告也会明确列出哪些变异存活。

4. **AssertionError捕获：** 当测试用例中的断言失败时，PIT将捕获AssertionError异常，将其视为成功的变异被杀死。这表明测试用例能够发现引入的错误。

5. **报告中的详细信息：** 变异测试报告通常会提供关于测试用例执行、变异被杀死或存活的详细信息。这包括哪些断言失败、哪些变异被检测到等。

通过分析变异测试报告，开发人员可以清晰地了解哪些测试用例成功地检测到了变异，以及哪些测试用例未能捕捉到潜在的问题。

这种信息有助于改进测试用例，使其更加健壮和全面。

## PIT 生成变异测试的原理是什么？

PIT（PITest）生成变异测试的原理涉及引入人为的变异（mutations）来模拟潜在的错误情况，然后运行测试套件来检测这些变异。以下是PIT生成变异测试的基本原理：

1. **选择变异点：** PIT首先选择源代码中的变异点，这些点是将被修改的代码位置。变异点可以是各种不同的地方，例如条件语句、循环、算术运算符、方法调用等。

2. **应用变异：** 在选择的变异点上，PIT引入不同类型的变异。变异的方式可以是修改条件语句的关系运算符、改变算术运算符、插入删除代码等。每一次变异都代表一种可能的错误情况。

3. **生成变异后的代码：** 引入变异后，PIT生成变异后的代码。这是一个经过修改的代码版本，其中包含了一种或多种变异。

4. **运行测试套件：** 对于每个变异后的代码版本，PIT运行测试套件。测试套件包含了一系列的测试用例，用于验证程序的正确性。

5. **检测变异的存活或死亡：** 如果测试用例能够发现引入的错误（变异），则该变异被称为“被杀死”（killed）。如果测试用例未能检测到变异，该变异被称为“存活”（survived）。变异测试的目标是尽可能多地杀死变异。

6. **生成变异测试报告：** 最终，PIT生成详细的变异测试报告，其中包含有关每个变异的执行情况、测试用例的覆盖情况、变异是否被杀死或存活等信息。

通过变异测试报告，开发人员可以清晰地了解测试用例对于引入的变异的检测能力。报告中详细列出了哪些变异被检测到，哪些存活，以及测试用例的覆盖情况。这种信息有助于开发人员改进测试用例，提高测试覆盖率和质量。


## PIT 和 fuzz test 思想有什么区别？

PIT（PITest）和模糊测试（Fuzz Testing）是两种不同的测试方法，它们的思想和目标有一些区别。

### PIT (PITest) 变异测试：

1. **目标：**
   - PIT的主要目标是评估测试用例的质量，检查测试用例是否足够强大，能够捕捉代码中的潜在问题。
   - PIT通过引入人为的变异，模拟潜在的错误情况，然后运行测试套件来检测这些变异。

2. **变异引入：**
   - PIT通过修改源代码引入变异。这些变异可以包括修改条件语句、改变算术运算符、删除或插入代码等。

3. **目的：**
   - 目的是找到那些能够“杀死”变异的测试用例，即能够成功检测到引入的错误。

4. **用例改进：**
   - 结果可以帮助开发人员了解测试用例的不足之处，从而改进测试用例，提高代码的鲁棒性和质量。

### 模糊测试（Fuzz Testing）：

1. **目标：**
   - 模糊测试的主要目标是发现应用程序或系统中的安全漏洞、软件缺陷或异常行为。
   - 模糊测试通过提供具有随机、异常或非预期输入的测试数据，来测试目标系统的稳定性和健壮性。

2. **变异引入：**
   - 模糊测试通过引入随机、异常或不同寻常的输入来变异测试数据。这些输入可能包括不规范的数据、大量的数据、非法输入等。

3. **目的：**
   - 目的是观察系统对于不同类型的输入如何响应，并发现潜在的安全漏洞或软件错误。

4. **用例改进：**
   - 结果可以用于改进系统对于不同输入的处理，提高系统的鲁棒性和安全性。

### 主要区别：

- **领域和目标：**
  - PIT主要关注测试用例对于代码的质量，通过变异测试来评估测试的健壮性。
  - 模糊测试主要关注发现系统中的异常行为，通过提供随机或不寻常的输入来测试系统的健壮性和安全性。

- **输入变异方式：**
  - PIT通过修改源代码引入变异。
  - 模糊测试通过提供不同类型的输入来变异测试数据。

- **发现的问题类型：**
  - PIT主要发现测试用例是否足够强大，能够捕捉到代码中的潜在问题。
  - 模糊测试主要发现系统的安全漏洞、软件缺陷或异常行为。

虽然PIT和模糊测试有不同的目标，但它们都是用于提高软件系统的质量和鲁棒性的测试方法。在一些情况下，可以结合使用这两种方法以更全面地测试和改进软件。

## PIT 变异测试，还有其他类似的开源吗？

PIT（Pitest）是一个用于Java项目的变异测试工具，它用于测试代码的质量和覆盖率。

变异测试通过对源代码进行故意的修改，生成变异体，然后运行测试来检测是否有测试用例能够捕捉到这些变异体，从而评估测试用例的质量。

除了PIT之外，还有一些其他类似的开源变异测试工具。以下是一些常见的变异测试工具：

https://github.com/vmzakharov/mutate-test-kata

https://github.com/broadinstitute/mutect

https://github.com/jeffoffutt/muJava

# 参考资料

* any list
{:toc}