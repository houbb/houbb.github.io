---
layout: post
title: 从零开始的数据结构与算法-02-如何系统有效的学习数据结构与算法？
date:  2020-6-8 15:13:08 +0800
categories: [Algorithm]
tags: [algorithm, data-struct, topics, sf]
published: true
---

# 一、思维的转变，刷题不是目的

| 常见刷题思维     | 高效刷题思维      |
| ---------- | ----------- |
| 追求刷题数量     | 追求“知识模型”的构建 |
| 题型记不住、技巧忘了 | 把题归类、构建知识图谱 |
| 做过就忘、感觉无序  | 有计划、有归档、有复盘 |

# 二、对知识系统的分类

**推荐专题划分顺序：**

```
1. 数组 / 双指针 / 滑动窗口
2. 栈与队列（括号匹配、单调栈）
3. 哈希表（Two Sum, 频次统计）
4. 字符串处理（KMP，字符串哈希）
5. 二分查找（左闭右开/开闭边界）
6. 链表（反转、环检测）
7. 树（前中后序 + DFS / BFS）
8. 回溯算法（组合、排列、数独）
9. 动态规划（01背包、区间DP、状态压缩）
10. 贪心策略（区间调度、跳跃游戏）
11. 并查集、图论（DFS/BFS/Dijkstra/Kruskal）
```

# 三、每个专题该怎么学习？

## 1. **建立模式卡片**：

为每个模式创建一张知识卡片，包含：
     * **核心思想**（用一句话概括）
     * **适用场景**（什么问题能用它？）
     * **经典模板代码**（精简版）
     * **关键变种/难点**（如 DP 的状态定义、初始化）
     * **关联模式**（如 BFS 和最短路径问题）
   * **可视化连接**：用思维导图/XMind 连接相关模式（如：看到“子数组和” -> 想到前缀和、滑动窗口）。

## 2. **深度优先，而非广度优先**：

   * **选定一个模式**（如滑动窗口），**集中火力刷透**（10-15题）。
   * **刷题步骤**：
     * 先做**最经典题**（力扣官方/高频题）。
     * 再做**变种题**（条件变化、限制变化）。
     * 最后做**融合题**（结合其他模式，如滑动窗口+哈希）。
   * **目标**：彻底理解该模式的边界、陷阱和适用性。

# 四、学以致用：连接理论与价值 （提升价值感）

1. **关联实际应用场景**（解决“学这有什么用？”）：
   * **滑动窗口**：实时监控系统（如1分钟请求数限制）、网络流量控制。
   * **Trie树**：搜索引擎自动补全、输入法候选词。
   * **并查集**：社交网络好友关系、游戏地图连通性检测。
   * **拓扑排序**：任务调度、课程安排、依赖管理（如npm包安装）。
   * **LRU Cache**：数据库缓存、浏览器缓存策略。
   * **布隆过滤器**：Redis防止缓存穿透、邮件垃圾过滤。
   * **学习资源**：《编程珠玑》《算法设计手册》中的案例，或直接看**Redis/LevelDB等开源项目源码**。

2. **参与能落地的项目**：
   * **用算法解决实际问题**：如：
     * 写个小工具自动整理文档（字符串算法）。
     * 优化个人网站的图片加载策略（缓存算法）。
     * 分析股票数据（动态规划解最佳买卖时机）。
   * **贡献开源项目**：参与需要算法优化的项目（如Apache基金会项目）。

3. **参加有意义的竞赛/活动**：
   * **Kaggle（数据科学）**：大量真实数据集，需优化算法。
   * **Google Hash Code（团队编程赛）**：解决接近工业界规模的问题。
   * **公司内部黑客马拉松**：用算法解决业务痛点（如路径优化、推荐策略）。


# 五：输出作品集：输出倒逼输入

费曼学习法简化版本：文章，到个人博客+各个技术平台（总结+解答，以教代学）

可视化：针对每一种解法，对应的可视化效果？个人博客可以比较直接的放在下面？

源码开源：解题源码，保留每一种解法+思路===》github/gitee

总结拓展（知识的关联性，不是零散的）：将这个系列的题目放在一起学习，而不是零散的学习。

工具（模块化、可以复用）：类似 sdk hutool。工具，和解题过程不同，强调的是===可拓展性，复用性强。大部分以接口的形式呈现。

学以致用：有什么用？解决生活中的实际问题，可以是解决方案，最好设计方案+源码。

技术生态：以算法+数据结构===》对应的生态到底是什么？

# 总结

老马主要把刷题分为三个部分：

1）个人专题系列学习博客笔记，最好包含每一种解法的可视化过程

2）刷题的解题源码，到 github/gitee

3) 根据这个方法，整理一个 leetcode-toolkit 算法工具包，包含数据结构+算法

4）学习致用，边学边用。


# chat

## 如何系统的学习？

疑问：

> 力扣算法每次感觉都要从头刷题 很容易忘记。全是零碎的知识点，如何系统，有效，高效的刷题学习。最好可以学有所用，加深应用，提升价值

这是个很典型、很真实的刷题困境：
**“刷了很多题，但过段时间又忘记，感觉像打水漂。”**
这其实说明你已经进入了一个更高层次：你不满足于“做对题”，而是想**系统化知识、提升能力、用得出来。**

下面我将从几个方面给你设计一套**系统 + 高效 + 可沉淀 + 有价值提升的刷题学习策略：**

---

## 🧠 一、转变刷题目标：从“做题”到“构建认知体系”

| 常见刷题思维     | 高效刷题思维      |
| ---------- | ----------- |
| 追求刷题数量     | 追求“知识模型”的构建 |
| 题型记不住、技巧忘了 | 把题归类、构建知识图谱 |
| 做过就忘、感觉无序  | 有计划、有归档、有复盘 |

### ✅ 建议：明确一个**主线目标**

比如：

* **找工作** → 高频面试题（字节、阿里、LeetCode Top 100）
* **提升算法功底** → 算法专题+数据结构深度理解
* **项目/场景运用** → 图、搜索、贪心、DP 等真实应用拆解

---

## 🗂️ 二、刷题思路：系统化、结构化分阶段

### 🔵 第一阶段：构建知识树（夯实基本功）

> 用专题 + 模板 + 高频例题 的方式打基础

**推荐专题划分顺序：**

```
1. 数组 / 双指针 / 滑动窗口
2. 栈与队列（括号匹配、单调栈）
3. 哈希表（Two Sum, 频次统计）
4. 字符串处理（KMP，字符串哈希）
5. 二分查找（左闭右开/开闭边界）
6. 链表（反转、环检测）
7. 树（前中后序 + DFS / BFS）
8. 回溯算法（组合、排列、数独）
9. 动态规划（01背包、区间DP、状态压缩）
10. 贪心策略（区间调度、跳跃游戏）
11. 并查集、图论（DFS/BFS/Dijkstra/Kruskal）
```

> 每个专题准备：

* 一个**模板总结**
* 5\~10个典型例题（用错法+正解方式来理解）
* 错题集（记录你错过的思维点）

---

### 🟠 第二阶段：题目归类 + 巩固迁移

**方法**：构建自己的**题型知识库 + 思维模式**

* 把所有题整理进 notion/obsidian/有道笔记等工具
* 每道题总结：

  * 解法分类（暴力？优化？贪心？）
  * 思路关键词（前缀和 + 哈希 + 双指针）
  * 解题模板（是否可以模板化）
  * 易错点（哪一步是关键）
  * 类似题目推荐

✅ **目的是为了“归纳思维模型”而不是“记住题解”**

---

### 🟢 第三阶段：反复复习 + 模拟实战 + 场景应用

* 每 1\~2 周安排一次**模拟面试**（限时、无提示）
* 复盘错题，更新“错题笔记”和“题型树”
* 尝试讲题、写文章、录视频（越讲越懂）
* 在项目中尝试用算法优化业务逻辑（比如路径规划、推荐排序、文本相似度）

---

## 🧰 三、工具建议：让刷题变“有沉淀”

| 工具                | 用法                  |
| ----------------- | ------------------- |
| Notion/Obsidian   | 建立算法知识库/错题本/专题笔记    |
| LeetCode 题单功能     | 分类刷题 + 收藏错题         |
| GitHub + Markdown | 建立自己的刷题笔记项目（可当简历作品） |
| Typora / Logseq   | 可本地存储笔记，做结构化梳理      |
| 视频讲题              | 模拟面试、讲给别人听能加深理解     |

---

## 🧪 四、用得出来，价值才会提升

1. **项目里用算法**

   * 举例：某推荐系统 → 使用堆排序/滑动窗口做热度筛选
   * 后端服务限流 → 使用滑动窗口算法实现令牌桶

2. **面试中脱颖而出**

   * 面试官更关注“思路”而不是“做对”
   * 你能讲清楚题型归类、思维演化路径，就能加分

3. **输出沉淀为内容/作品集**

   * 形成自己的「算法笔记项目」/「面试笔记」/「讲题视频」
   * 这是对外展示价值的最好方式（对内也是二次学习）

---

## 🧭 五、每日/每周计划推荐

### 🗓️ 每日计划（60\~90 分钟）：

* 📚 20min：复习昨日错题 / 回顾一个专题
* 🧠 40min：新做 1\~2 道题（重点题精做）
* ✍️ 30min：总结、笔记、错题集更新

### 📆 每周计划：

* 周一\~周五：专题精刷 + 总结
* 周末：模拟实战 + 复盘 + 总结本周心得

---

## 🧩 六、建议关注的资源

* **《代码随想录》**（基础+图解+思维模型）
* **《Labuladong 的算法小抄》**（DP和套路非常系统）
* **YouTube/B站讲题博主**：程序员鱼皮、小林 coding、AcWing
* **LeetCode 题单**：剑指 Offer、Top 100、热题 HOT 100

---

## 🎯 最后一条核心建议

> **别追求题目数量，而是追求认知体系的质量。**

当你能做到：

* 遇到一个题能迅速判断题型
* 能讲出多种解法思路的优劣
* 能从项目中看到算法的影子

你就已经从“刷题者”成长为“算法工程师”了。

---

需要我帮你设计一份你的**个人刷题计划表**或**专题刷题路线图**吗？可以根据你当前水平和目标来定制。

## DS

我完全理解你的困扰！刷题时感觉知识零散、学了就忘、缺乏体系感，这是非常普遍的问题。关键在于**转变刷题策略，从“数量驱动”变为“体系驱动”和“深度驱动”**。以下是我为你设计的系统性高效刷题方案，结合认知科学和实战经验，助你学有所用：

---

### **一、构建知识体系：告别零散，建立“算法地图”**（核心基础）
1. **按“算法模式/思想”分类，而非题目标签**：
   * **核心模式**：双指针、滑动窗口、二分查找、BFS/DFS、回溯、递归、分治、动态规划（DP）、贪心、拓扑排序、前缀和、单调栈、并查集、位运算、Trie树等。
   * **建立模式卡片**：为每个模式创建一张知识卡片，包含：
     * **核心思想**（用一句话概括）
     * **适用场景**（什么问题能用它？）
     * **经典模板代码**（精简版）
     * **关键变种/难点**（如 DP 的状态定义、初始化）
     * **关联模式**（如 BFS 和最短路径问题）
   * **可视化连接**：用思维导图/XMind 连接相关模式（如：看到“子数组和” -> 想到前缀和、滑动窗口）。

2. **深度优先，而非广度优先**：
   * **选定一个模式**（如滑动窗口），**集中火力刷透**（10-15题）。
   * **刷题步骤**：
     * 先做**最经典题**（力扣官方/高频题）。
     * 再做**变种题**（条件变化、限制变化）。
     * 最后做**融合题**（结合其他模式，如滑动窗口+哈希）。
   * **目标**：彻底理解该模式的边界、陷阱和适用性。

---

### **二、高效刷题法：对抗遗忘，深度加工**（执行策略）
1. **“三刷五问”法**（取代盲目重复）：
   * **一刷**：独立思考 -> 卡壳不超过20分钟 -> 看题解**核心思路**（非代码！）。
   * **二刷**（隔天）：**独立写出完整代码**，关注边界和效率。
   * **三刷**（1周后）：**快速写出最优解**，并口述解题逻辑。
   * **五问自己**：
     * 为什么用这个算法/数据结构？
     * 时间和空间复杂度是多少？能否优化？
     * 有哪些易错点（边界、初始化）？
     * 题目有哪些变种？还能怎么考？
     * 实际工程中哪里可能用到它？（如 LRU Cache 用哈希+双向链表）

2. **间隔重复 + 主动回忆**（科学记忆）：
   * 用 **Anki/Notion 闪卡**记录经典题、易错点、模式总结。
   * 设置复习周期（1天、3天、1周、2周...），**逼自己回忆解题思路**而非直接看答案。
   * **手写伪代码** > 直接敲代码（强化逻辑记忆）。

3. **从“解题”到“教题”**（费曼学习法）：
   * 尝试给他人（或假想的听众）讲解一道题。
   * 录制解题视频或写题解博客（如GitHub/Gitee）。
   * **教是最好的学**：讲不通的地方就是你的知识盲点。

---

### **三、学以致用：连接理论与价值**（提升价值感）
1. **关联实际应用场景**（解决“学这有什么用？”）：
   * **滑动窗口**：实时监控系统（如1分钟请求数限制）、网络流量控制。
   * **Trie树**：搜索引擎自动补全、输入法候选词。
   * **并查集**：社交网络好友关系、游戏地图连通性检测。
   * **拓扑排序**：任务调度、课程安排、依赖管理（如npm包安装）。
   * **LRU Cache**：数据库缓存、浏览器缓存策略。
   * **布隆过滤器**：Redis防止缓存穿透、邮件垃圾过滤。
   * **学习资源**：《编程珠玑》《算法设计手册》中的案例，或直接看**Redis/LevelDB等开源项目源码**。

2. **参与能落地的项目**：
   * **用算法解决实际问题**：如：
     * 写个小工具自动整理文档（字符串算法）。
     * 优化个人网站的图片加载策略（缓存算法）。
     * 分析股票数据（动态规划解最佳买卖时机）。
   * **贡献开源项目**：参与需要算法优化的项目（如Apache基金会项目）。

3. **参加有意义的竞赛/活动**：
   * **Kaggle（数据科学）**：大量真实数据集，需优化算法。
   * **Google Hash Code（团队编程赛）**：解决接近工业界规模的问题。
   * **公司内部黑客马拉松**：用算法解决业务痛点（如路径优化、推荐策略）。

---

### **四、高效工具链：自动化辅助**
| **工具类型**       | **推荐工具**                     | **用途**                                  |
|---------------------|----------------------------------|------------------------------------------|
| **知识管理**        | Notion/Obsidian/Anki            | 建立互联知识库，制作复习闪卡              |
| **刷题计划**        | LeetCode Study Plan/自制甘特图   | 跟踪进度，避免随机刷题                    |
| **代码可视化**      | Python Tutor/LeetCode动画        | 直观理解代码执行过程                      |
| **复杂度分析**      | Big O Cheat Sheet (速查表)       | 快速评估解法优劣                          |
| **项目实践平台**    | GitHub/GitLab, Replit            | 落地算法项目，积累作品集                  |

---

### **五、关键心态调整**
1. **接受遗忘是正常的**：大脑不是硬盘，**通过体系索引+刻意回忆提取**才能深化记忆。
2. **追求“模式识别”而非“背题”**：面试官常考变种题，死记答案必挂。
3. **20%核心算法解决80%问题**：优先精通：**双指针、二分、DFS/BFS、回溯、DP、哈希、堆、树遍历**。
4. **定期“返工”**：每月回顾知识框架，**删除过时笔记，补充新感悟**。

> **终极心法**：刷题不是目的，而是**训练“问题抽象能力”和“算法设计直觉”**。当你拿到新题能快速定位模式、调整模板、避开陷阱时，你就完成了从“刷题者”到“问题解决者”的蜕变。

**最后赠言**：真正的算法高手不是记住1000道题，而是能用20种核心思想优雅解决1000种问题。你现在感觉的零散，终将在体系建成时化为掌控感。坚持下去，每一步思考都在重塑你的大脑！



* any list
{:toc}