---
layout: post
title:  【leetcode】力扣刷题技巧之对数器，如果没有OJ（在线判题系统）怎么办？如何保障本地代码的正确性
date:  2020-6-8 15:13:08 +0800
categories: [Algorithm]
tags: [algorithm, tips, leetcode]
published: true
---

## 什么是对数器？

对数器，本质上是一种用于验证算法正确性的测试工具和调试方法。 

它的核心思想是：

1.  有一个你想测试的目标算法 `A`：这个算法通常是你新设计的、优化的、或者相对复杂、你对其正确性没有十足把握的算法（比如一个高效的排序算法、一个巧妙的动态规划解法）。
2.  有一个绝对正确（但可能低效、简单、暴力）的算法 `B`：这个算法是作为“标杆”或“正确答案生成器”存在的。它的正确性很容易被验证，或者本身就是公认正确的（比如使用系统库函数 `sort()` 进行排序，或者一个显而易见的暴力解法）。
3.  生成大量随机测试数据：编写一个函数，能够产生各种可能情况下的随机输入数据（包括边界条件、极端情况）。
4.  用算法 A 和算法 B 分别处理同一份随机输入数据。
5.  比较两个算法的输出结果：如果对于大量的随机输入，算法 A 和算法 B 的输出结果都完全一致，那么我们就可以在很高的置信度下认为算法 A 是正确的。

### 为什么叫“对数器”？

“对数”在这里的含义是 “对比”、“校验”。它不直接涉及数学上的对数运算，而是强调通过对比两个算法（目标算法和基准算法） 的输出结果来验证正确性。你可以把它理解为一个“结果对比器”或“正确性校验器”。

## 为什么需要对数器？（解决的问题）

1.  验证复杂算法的正确性： 对于逻辑复杂、边界条件多的算法（如动态规划、贪心、高级数据结构操作），仅靠有限的几个测试用例（手写的或题目给定的）很难覆盖所有情况，容易遗漏边界 Bug。对数器通过海量随机测试大大提高覆盖率。
2.  调试困难： 当算法在某个复杂输入下出错时，定位 Bug 非常困难。对数器可以：
    *   自动缩小问题规模：通过记录导致出错的随机输入，你可以获得一个（可能很小的）复现用例，极大方便调试。
    *   提供“正确答案”：你知道对于这个出错的输入，基准算法 `B` 的输出是什么，这为调试提供了明确的目标。
3.  测试“黑盒”算法： 如果你在实现一个算法，但对其内部原理不是很清晰（比如根据论文或思路实现），对数器是验证其正确性的可靠手段。
4.  替代 OJ（在线判题系统）的本地测试： 在提交代码到 OJ 前，先用对数器进行充分测试，避免多次“Wrong Answer”罚时。特别是当 OJ 不返回具体出错用例时，对数器是本地调试的唯一有效手段。
5.  验证算法优化后的正确性： 当你对一个已有算法进行优化（如空间优化、剪枝）时，对数器可以确保优化没有引入新的错误，结果与原算法一致。

## 对数器的实现步骤（核心流程）

1.  实现目标算法 `A`： 你需要验证正确性的那个算法。
2.  实现绝对正确的基准算法 `B`：
    *   可以是暴力解法（Brute Force）。
    *   可以是调用语言内置的、公认正确的库函数（如 `Arrays.sort()`, `Math.max()` 等）。
    *   可以是一个逻辑极其简单、易于验证正确性的简单实现。
    *   关键： 你必须对 `B` 的正确性有 100% 的信心。
3.  实现随机测试数据生成器：
    *   使用随机数生成器（如 `Random`）。
    *   生成的测试数据需要覆盖各种情况：
        *   一般情况： 普通、常见的输入。
        *   边界情况： 空输入、最小规模输入、最大规模输入（如果可行）、临界值。
        *   极端情况： 数据全相同、数据完全逆序、数据范围极大/极小、包含特殊值（如负数、零）。
        *   随机多样： 数据规模、数据值随机变化。
    *   关键： 数据生成器要尽可能模拟真实或可能遇到的所有输入模式。
4.  实现测试主逻辑：
    *   循环多次（例如几万、几十万次，取决于算法复杂度和数据规模）。
    *   在每次循环中：
        1.  调用数据生成器，生成一份随机输入数据 `input`。
        2.  复制 `input` (如果需要，避免 `A` 和 `B` 修改原始输入影响对方)。
        3.  用算法 `A` 处理一份 `input`，得到结果 `resultA`。
        4.  用算法 `B` 处理另一份（或复制后的）`input`，得到结果 `resultB`。
        5.  比较 `resultA` 和 `resultB`。
            *   如果一致，继续下一次循环。
            *   如果不一致！
                *   立即打印或记录出错的输入数据 `input`。
                *   打印 `resultA` 和 `resultB`。
                *   终止测试（或根据需求记录错误并继续测试更多用例）。
5.  分析结果：
    *   如果跑了大量测试（比如 10 万次）都没有出错，基本可以认为 `A` 正确。
    *   如果出现不一致，恭喜你找到了 Bug！利用打印出的错误输入 `input`、`resultA`、`resultB`，开始调试算法 `A`。

## 关键要素与注意事项

1.  基准算法 `B` 的正确性是基石： 如果 `B` 本身有错，那么所有测试都是无效的。选择最简单、最可靠的实现作为 `B`。
2.  随机数据生成器的质量至关重要：
    *   它决定了测试的覆盖率和发现 Bug 的能力。
    *   一定要包含各种边界和极端情况。不能只生成“友好”的数据。
    *   考虑数据规模：小规模用于快速测试和调试，大规模用于压力测试和发现隐藏问题。
3.  比较结果的逻辑要严谨： 比较 `resultA` 和 `resultB` 时，要根据算法功能决定是比单个值、整个数组、还是复杂对象。确保比较逻辑本身正确无误（例如，比较数组是否相等要用 `Arrays.equals()` 而不是 `==`）。
4.  复制输入数据（如果需要）： 如果算法 `A` 或 `B` 会修改输入数据（如原地排序），那么在将同一份输入传给 `A` 和 `B` 之前，必须先复制一份，确保它们处理的是初始状态相同的独立数据。
5.  大量测试： 次数太少不足以暴露概率性 Bug 或只在特定模式输入下出现的 Bug。通常需要成千上万次测试才能有较高置信度。
6.  自动化： 整个过程（生成数据、运行 A/B、比较结果）必须完全自动化，才能高效地进行海量测试。

## 一个简单示例（验证自定义排序算法）

假设你实现了一个自定义的快速排序 `myQuickSort(int[] arr)`。

1.  目标算法 `A`： `myQuickSort(int[] arr)` (你的快速排序实现，可能包含 Bug)。
2.  基准算法 `B`： `Arrays.sort(int[] arr)` (JDK 提供的、公认正确的排序)。
3.  随机数据生成器：
    ```java
    public int[] generateRandomArray(int maxSize, int maxValue) {
        Random rand = new Random();
        int size = rand.nextInt(maxSize + 1); // [0, maxSize]
        int[] arr = new int[size];
        for (int i = 0; i < size; i++) {
            // 生成正负随机数
            arr[i] = rand.nextInt(maxValue + 1) - rand.nextInt(maxValue + 1);
        }
        return arr;
    }
    ```
4.  测试主逻辑：
    ```java
    public static void main(String[] args) {
        int testTimes = 50000;
        int maxSize = 100;
        int maxValue = 100;
        boolean succeed = true;

        for (int i = 0; i < testTimes; i++) {
            int[] arr1 = generateRandomArray(maxSize, maxValue);
            int[] arr2 = Arrays.copyOf(arr1, arr1.length); // 复制一份原始数据

            myQuickSort(arr1);      // 用你的算法排序
            Arrays.sort(arr2);       // 用正确算法排序

            // 比较两个排序结果是否完全相同
            if (!Arrays.equals(arr1, arr2)) {
                succeed = false;
                // 打印出错的信息以便调试
                System.out.println("Error Case:");
                System.out.println("Original: " + Arrays.toString(arr2)); // arr2 是原始数据的拷贝，但被 Arrays.sort 排序了？这里逻辑有点歧义
                // 更清晰的打印：
                System.out.println("My Sorted: " + Arrays.toString(arr1));
                System.out.println("Correct Sorted: " + Arrays.toString(arr2));
                break; // 发现错误立即退出
            }
        }
        System.out.println(succeed ? "Nice! Algorithm A seems correct." : "Fucking Bug Found!");
    }
    ```
    *注意：上面注释处指出了一个小歧义。`arr2` 是原始数据的拷贝，但紧接着就被 `Arrays.sort(arr2)` 修改了。所以打印 "Original" 时其实打印的是排序后的 `arr2`。为了清晰打印原始输入，应该在复制后立即保存一份原始数据的拷贝用于打印：*
    ```java
    int[] arrOriginal = Arrays.copyOf(arr1, arr1.length); // 保存原始数据用于打印
    ... // 排序 arr1 和 arr2
    if (!Arrays.equals(arr1, arr2)) {
        ...
        System.out.println("Original: " + Arrays.toString(arrOriginal));
        ...
    }
    ```

## 总结

对数器是算法学习和工程实践中极其重要且实用的技巧。

它利用随机测试和结果对比，极大地提高了验证算法正确性的效率和可靠性，是定位和修复算法 Bug 的利器。

掌握并习惯使用对数器，将显著提升你的算法开发效率和代码质量。

务必在你实现每一个非平凡算法时，都使用对数器进行验证！

# 参考资料

https://leetcode.cn/problems/hanota-lcci/description/?envType=problem-list-v2&envId=recursion

* any list
{:toc}