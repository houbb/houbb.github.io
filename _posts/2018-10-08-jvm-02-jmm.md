---
layout: post
title: JVM-02-JMM 运行时内存模型
date:  2018-10-08 07:19:52 +0800
categories: [Java]
tags: [sql, java, jdbc, sf]
published: true
---

# 运行时内存模型

![运行时内存模型](https://raw.githubusercontent.com/houbb/resource/master/img/java/jmm/2018-07-26-runtime-data.png)

相关内容参见 [java 运行时内存模型](https://houbb.github.io/2018/07/26/jmm-02-data-struct)

## 直接内存

- 特征

直接内存并非 JVMS 定义的标准 Java 运行时内存。

直接内存区域是全局共享的内存区域。

直接内存区域可以进行自动内存管理(GC)，但机制并不完善。

本机的 Native 堆(直接内存) 不受 JVM 堆内存大小限制。

可能出现 OutOfMemoryError 异常。

- nio

JDK1.4 加入了新的 NIO 机制，目的是防止 Java 堆 和 Native 堆之间往复的数据复制带来的性能损耗，此后 NIO 可以使用 Native 的方式直接在 Native 堆分配内存。

NIO的Buffer提供了一个可以不经过JVM内存直接访问系统物理内存的类——DirectBuffer。 

DirectBuffer类继承自ByteBuffer，但和普通的ByteBuffer不同，普通的ByteBuffer仍在JVM堆上分配内存，其最大内存受到最大堆内存的限制；

而DirectBuffer直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制。

- 注意

DirectBuffer并没有真正向OS申请分配内存，其最终还是通过调用 Unsafe 的 allocateMemory() 来进行内存分配。

不过JVM对Direct Memory可申请的大小也有限制，可用 `-XX:MaxDirectMemorySize=1M` 设置，这部分内存不受JVM垃圾回收管理。

直接内存的读写操作比普通Buffer快，但它的创建、销毁比普通Buffer慢。

因此直接内存使用于需要大内存空间且频繁访问的场合，不适用于频繁申请释放内存的场合。


# JVM 内存结构

Java 虚拟机的内存空间分为 5 个部分：

- 程序计数器

- Java 虚拟机栈

- 本地方法栈

- 堆

- 方法区

![内存结构](https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/jvm-memory-structure.jpg)

JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。

元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。

不过元空间与永久代之间最大的区别在于：**元数据空间并不在虚拟机中，而是使用本地内存**。

# 程序计数器（PC 寄存器）

## 程序计数器的定义

程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为Undefined。

## 程序计数器的作用

字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。

在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。

## 程序计数器的特点

- 是一块较小的内存空间。

- 线程私有，每条线程都有自己的程序计数器。

- 生命周期：随着线程的创建而创建，随着线程的结束而销毁。

- 是唯一一个不会出现OutOfMemoryError的内存区域。

# Java 虚拟机栈（Java 栈）

## Java 虚拟机栈的定义

Java 虚拟机栈是描述 Java 方法运行过程的内存模型。

Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：

- 局部变量表

- 操作数栈

- 动态链接

- 方法出口信息

- ......

![虚拟机栈的定义](https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/jvm-stack.jpg)

## 压栈出栈过程

当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。

Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。

只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。

方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。

如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。

由于 Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。

## Java 虚拟机栈的特点

局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。

Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。

（1）StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。

（2）OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。

Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。

出现 StackOverFlowError 时，内存空间可能还有很多。


# 本地方法栈（C 栈）

## 本地方法栈的定义

本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。

它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。

## 栈帧变化过程

本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。

方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。

如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。

# 堆

## 堆的定义

堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。

## 堆的特点

- 线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。

- 在虚拟机启动时创建。

- 是垃圾回收的主要场所。

- 进一步可分为：新生代（Eden 区：From Survior，To Survivor）、老年代。

不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。

堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。

Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。

# 方法区

## 方法区的定义

Java 虚拟机规范中定义方法区是堆的一个逻辑部分。

方法区存放以下信息：

- 已经被虚拟机加载的类信息

- 常量

- 静态变量

- 即时编译器编译后的代码

## 方法区的特点

- 线程共享。 

方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。

- 永久代。 

方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。

- 内存回收效率低。 

方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。

- Java 虚拟机规范对方法区的要求比较宽松。 

和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。

## 运行时常量池

方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。

当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。

而且在运行期间，可以向常量池中添加新的常量。

如 String 类的 intern() 方法就能在运行期间向常量池中添加字符串常量。

# 直接内存（堆外内存）

直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。

## 操作直接内存

在 NIO 中引入了一种基于通道和缓冲的 IO 方式。

它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的DirectByteBuffer对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。

直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。

## 直接内存与堆内存比较

- 直接内存申请空间耗费更高的性能

- 直接内存读取 IO 的性能要优于普通的堆内存。

- 直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO

- 堆内存作用链：本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO

服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。


# 参考资料

《深入理解 jvm》

[Java直接内存与堆内存](https://www.cnblogs.com/z-sm/p/6235157.html)

[Java-内存之直接内存](https://mritd.me/2016/03/22/Java-%E5%86%85%E5%AD%98%E4%B9%8B%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/)

[HotSpot 虚拟机对象的创建过和对象的内存结构](https://blog.csdn.net/zhaoyw2008/article/details/9278865)

[HotSpot虚拟机对象揭秘之对象的创建过程探究](https://blog.csdn.net/GFJ0814/article/details/51182618)

[深入理解JVM(二)——揭开HotSpot对象创建的奥秘](https://blog.csdn.net/u010425776/article/details/51190801)

[JVM 内存结构](https://doocs.github.io/jvm/#/docs/01-jvm-memory-structure)

* any list
{:toc}