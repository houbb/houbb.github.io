---
layout: post
title: JVM-02-JMM HotSpot 创建对象
date:  2018-10-08 07:19:52 +0800
categories: [Java]
tags: [sql, java, jdbc, sf]
published: true
excerpt: JVM 学习笔记之 Java 内存模型和 HotSpot 创建对象过程
---

# 运行时内存模型

![运行时内存模型](https://raw.githubusercontent.com/houbb/resource/master/img/java/jmm/2018-07-26-runtime-data.png)

相关内容参见 [java 运行时内存模型](https://houbb.github.io/2018/07/26/jmm-02-data-struct)

## 直接内存

- 特征

直接内存并非 JVMS 定义的标准 Java 运行时内存。

直接内存区域是全局共享的内存区域。

直接内存区域可以进行自动内存管理(GC)，但机制并不完善。

本机的 Native 堆(直接内存) 不受 JVM 堆内存大小限制。

可能出现 OutOfMemoryError 异常。

- nio

JDK1.4 加入了新的 NIO 机制，目的是防止 Java 堆 和 Native 堆之间往复的数据复制带来的性能损耗，此后 NIO 可以使用 Native 的方式直接在 Native 堆分配内存。

NIO的Buffer提供了一个可以不经过JVM内存直接访问系统物理内存的类——DirectBuffer。 

DirectBuffer类继承自ByteBuffer，但和普通的ByteBuffer不同，普通的ByteBuffer仍在JVM堆上分配内存，其最大内存受到最大堆内存的限制；

而DirectBuffer直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制。

- 注意

DirectBuffer并没有真正向OS申请分配内存，其最终还是通过调用 Unsafe 的 allocateMemory() 来进行内存分配。

不过JVM对Direct Memory可申请的大小也有限制，可用 `-XX:MaxDirectMemorySize=1M` 设置，这部分内存不受JVM垃圾回收管理。

直接内存的读写操作比普通Buffer快，但它的创建、销毁比普通Buffer慢。

因此直接内存使用于需要大内存空间且频繁访问的场合，不适用于频繁申请释放内存的场合。

# HotSpot 虚拟机对象的解密

## 对象的创建过程

当虚拟机遇到一条含有new的指令时，会进行一系列对象创建的操作：

1、检查常量池中是否有即将要创建的这个对象所属的类的符号引用；

若常量池中没有这个类的符号引用，说明这个类还没有被定义！抛出ClassNotFoundException；

若常量池中有这个类的符号引用，则进行下一步工作；

2、进而检查这个符号引用所代表的类是否已经被JVM加载；

若该类还没有被加载，就找该类的class文件，并加载进方法区；若该类已经被JVM加载，则准备为对象分配内存；

3、根据方法区中该类的信息确定该类所需的内存大小； 

一个对象所需的内存大小是在这个对象所属类被定义完就能确定的。且一个类所生产的所有对象的内存大小是一样的。

JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小。

4、从堆中划分一块对应大小的内存空间给新的对象； 

分配堆中内存有两种方式：

4.1、指针碰撞 

如果JVM的垃圾收集器采用复制算法或标记-整理算法，那么堆中空闲内存是完整的区域，并且空闲内存和已使用内存之间由一个指针标记。

那么当为一个对象分配内存时，只需移动指针即可。因此，这种在完整空闲区域上通过移动指针来分配内存的方式就叫做“指针碰撞”。

4.2、空闲列表 

如果JVM的垃圾收集器采用标记-清除算法，那么堆中空闲区域和已使用区域交错，因此需要用一张“空闲列表”来记录堆中哪些区域是空闲区域，从而在创建对象的时候根据这张“空闲列表”找到空闲区域，并分配内存。 

综上所述：JVM究竟采用哪种内存分配方法，取决于它使用了何种垃圾收集器。

5、为对象中的成员变量赋上初始值(默认初始化)；

6、设置对象头中的信息；

7、调用对象的构造函数进行初始化 

此时，整个对象的创建过程就完成了。

## 并发处理

在分配的时候，由于创建对象的频率比较高，然而操作的都是同一个堆，肯定是线程不安全的，因此，需要同步处理
 
同步处理的方式有两种:
  
a.采用CAS配上失败重试保证更新操作原子性（个人理解就是，分配完了找一下，看看有哪些更新操作失败了，再重新分配一次）

b.把内存分配的动作按照线程划分在不同空间上进行，即就是每个线程在java堆中预先分配一小块的内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有在TLAB用完并重新分配的时候，才需要重锁定java堆

# 对象的内存模型

一个对象从逻辑角度看，它由成员变量和成员函数构成，从物理角度来看，对象是存储在堆中的一串二进制数，这串二进制数的组织结构如下。

对象在内存中分为三个部分：

- 对象头

- 实例数据

- 对齐补充

## 对象头

对象头中记录了对象在运行过程中所需要使用的一些数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

此外，对象头中可能还包含类型指针。通过该指针能确定这个对象所属哪个类。

此外，如果对象是一个数组，那么对象头中还要包含数组长度。

- HotSpot 虚拟机对象头 Mark Word

HotSpot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。

| 存储内容	                |         标志位   | 状态 |
|:---|:---|:---|
| 对象哈希码、对象分代年龄	        |   01	   |  未锁定 |
| 指向锁记录的指针	            |      00	   | 轻量级锁定 |
| 指向重量级锁的指针	           |       10 | 膨胀（重量级锁定 |
| 空，不需要记录信息	           |       11 | GC标记 |
| 偏向线程ID、偏向时间戳、对象分代年龄	 | 01 |    可偏向 |

## 实例数据

实力数据部分就是成员变量的值，其中包含父类的成员变量和本类的成员变量。

## 对齐补充

用于确保对象的总长度为 8 字节的整数倍。 

HotSpot要求对象的总长度必须是8字节的整数倍。由于对象头一定是8字节的整数倍，但实例数据部分的长度是任意的，因此需要对齐补充字段确保整个对象的总长度为8的整数倍。

# 对象的访问

我们知道，引用类型的变量中存放的是一个地址，那么根据地址类型的不同，对象有不同的访问方式：

## 句柄访问方式 

堆中需要有一块叫做“句柄池”的内存空间，用于存放所有对象的地址和所有对象所属类的类信息。 

引用类型的变量存放的是该对象在句柄池中的地址。

访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址再访问对象。

## 直接指针访问方式 

引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。 

但对象所在的内存空间中需要额外的策略存储对象所属的类信息的地址。

HotSpot采用直接指针方式访问对象，因为它只需一次寻址操作，从而性能比句柄访问方式快一倍。

但它需要额外的策略存储对象在方法区中类信息的地址。

# 参考资料

《深入理解 jvm》

[Java直接内存与堆内存](https://www.cnblogs.com/z-sm/p/6235157.html)

[Java-内存之直接内存](https://mritd.me/2016/03/22/Java-%E5%86%85%E5%AD%98%E4%B9%8B%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/)

[HotSpot 虚拟机对象的创建过和对象的内存结构](https://blog.csdn.net/zhaoyw2008/article/details/9278865)

[HotSpot虚拟机对象揭秘之对象的创建过程探究](https://blog.csdn.net/GFJ0814/article/details/51182618)

[深入理解JVM(二)——揭开HotSpot对象创建的奥秘](https://blog.csdn.net/u010425776/article/details/51190801)

* any list
{:toc}