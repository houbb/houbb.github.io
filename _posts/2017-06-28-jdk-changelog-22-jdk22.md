---
layout: post
title: jdk 变更日志-22-jdk22
date:  2017-06-28 23:15:43 +0800
categories: [Java]
tags: [jdk, java]
published: true
---

# 拓展阅读

[Java Functional java 函数式编程](https://houbb.github.io/2017/06/29/java-functional)

[Java Lambda](https://houbb.github.io/2017/06/28/java-lambda)

# jdk22 有哪些新特性

JDK 22 引入了一系列新特性，这些特性增强了 Java 平台的能力，包括语言的新特性、API 的改进、性能提升以及工具的增强。

以下是 JDK 22 中的一些主要新特性：

1. **外部函数和内存 API（Foreign Function & Memory API）**：JEP 454，这个特性旨在简化 Java 程序与本地代码和数据的互操作，提供了一种更安全和高效的方式来调用本地库。

2. **向量 API（Vector API）**：JEP 460，第七轮孵化，这个特性允许开发者表达向量计算，这些计算可以在运行时编译为特定 CPU 架构上的最佳向量指令。

3. **流聚合器（Gatherer API）**：JEP 461，预览特性，提供了一个更灵活的 API 来处理流，允许开发者插入自定义的操作符。

4. **结构化并发（Structured Concurrency）**：JEP 462，第二轮预览，这个特性通过将相关任务组视为单个工作单元来简化并发编程。

5. **作用域值（Scoped Values）**：JEP 464，第二轮预览，这个特性允许在线程内部和线程之间共享不可变数据。

6. **字符串模板（String Templates）**：JEP 459，第二轮预览，提供了一种新的字符串字面量，支持嵌入式表达式。

7. **未命名变量和模式（Unnamed Variables & Patterns）**：JEP 456，这个特性允许在模式匹配中使用未命名的变量和模式，提高了代码的可读性。

8. **隐式声明类和实例主方法（Implicitly Declared Classes and Instance Main Methods）**：JEP 463，第二轮预览，允许开发者编写更简洁的类和实例 `main` 方法。

9. **G1 的区域固定（Regional Pinning for G1）**：JEP 423，通过在 G1 垃圾回收器中实现区域固定来减少延迟。

10. **启动多文件源代码程序（Launch Multi-File Source-Code Programs）**：JEP 458，允许用户直接运行由多个 Java 源代码文件组成的程序，无需先进行编译。

11. **Markdown 文档注释（Markdown Documentation Comments）**：JEP 467，提议支持以 Markdown 格式编写 Javadoc 文档注释。

12. **类文件 API（Class-File API）**：JEP 466，第二轮预览，提供 API 来解析、生成和转换 Java 类文件。

这些特性展示了 Java 平台的持续进步，旨在提高开发者的生产力，增强程序性能，并简化与本地代码的互操作。

# 详细介绍 JDK 22 外部函数和内存 API

JDK 22 引入了外部函数和内存 API（通常称为 Project Panama 的一部分），这是一个重要的特性，它允许 Java 程序安全且高效地与 Java 运行时环境之外的代码和数据进行互操作。这个特性在 JDK 17 作为孵化特性首次引入，并在 JDK 18、JDK 19、JDK 20、JDK 21 中作为预览特性不断演进，最终在 JDK 22 中成为正式特性。

以下是 JDK 22 中外部函数和内存 API 的一些关键特性：

1. **安全互操作**：API 旨在提供一种比 Java Native Interface (JNI) 更安全的方法来调用本地库和操作非 JVM 管理的内存。

2. **简化的 FFI**：外部函数和内存 API 旨在简化 Java 与本地代码之间的互操作，减少 JNI 带来的复杂性和风险。

3. **内存操作**：API 提供了对非 JVM 管理内存的访问，允许 Java 代码分配、访问和操作本地内存。

4. **外部函数调用**：开发者可以使用这个 API 调用用 C 或其他语言编写的本地函数，直接从 Java 代码中。

5. **动态链接**：API 支持动态链接本地库，无需在 JVM 启动时指定所有本地库。

6. **资源类型**：引入了资源类型的概念，这些资源在作用域结束时自动被清理，减少了内存泄漏和其他资源管理问题。

7. **方法句柄**：API 使用方法句柄来表示和调用外部函数，这使得调用过程更加自然和高效。

8. **正式特性**：作为正式特性，外部函数和内存 API 允许开发者在生产环境中使用这个 API，并期望它在 JDK 的未来版本中保持稳定。

9. **示例代码**：
   ```java
   // 假设已经加载了某个本地库，并且库中有一个名为 "compute" 的函数
   MethodHandle computeHandle = lookup().find("compute");
   int result = (int) computeHandle.invokeExact(arg1, arg2);
   ```

10. **与 JNI 的关系**：FFM API 旨在最终取代 JNI，提供一种更安全和高效的方式来处理 Java 与本地代码的互操作。

11. **未来发展**：随着 JDK 的发展，外部函数和内存 API 预计将在未来版本中继续得到增强和改进。

# 详细介绍 JDK 22 向量 API

JDK 22 中的向量 API（Vector API）是一个重要的特性，它在 JDK 22 中作为第七轮孵化版引入。这个 API 提供了一种表达方式，让开发者能够利用现代 CPU 架构的 SIMD（单指令多数据）指令集进行高效的向量计算。以下是 JDK 22 中向量 API 的一些关键特性：

1. **高效性能**：向量 API 允许开发者编写可以在运行时编译为特定 CPU 架构上最佳向量指令的代码，从而实现优于等效标量计算的性能。

2. **平台无关性**：向量 API 提供了一种与平台无关的方式来表达向量计算，使得开发者可以编写一次代码，然后在支持的 CPU 架构上运行，以利用硬件加速。

3. **安全性**：与直接使用 SIMD 指令相比，向量 API 提供了更高级别的抽象，减少了因错误使用硬件指令而带来的风险。

4. **表达能力**：向量 API 提供了丰富的表达能力，允许开发者以声明式的方式编写复杂的向量运算。

5. **内存段操作**：向量 API 增强了对 `MemorySegment` 的操作，允许从 `MemorySegment` 加载和存储向量，这与外部函数和内存 API 的预览定义相一致。

6. **错误修复和性能增强**：在 JDK 22 中，向量 API 包括了错误修复和性能增强，例如支持使用任何原始元素类型的数组支持的堆 `MemorySegments` 进行向量访问，而以前仅限于由字节数组支持的堆 `MemorySegment`。

7. **孵化阶段**：作为孵化 API，向量 API 允许开发者尝试这个 API 并提供反馈，以便进一步的开发和改进。

8. **未来发展**：随着 JDK 的发展，向量 API 预计将逐渐趋于稳定，并在未来版本中成为正式特性，从而为 Java 程序提供更广泛的硬件加速能力。

# 详细介绍 JDK 22 流聚合器 API

JDK 22 引入了流聚合器（Stream Gatherers）API 作为预览特性，这是 Java 语言的一个新特性，旨在增强流（Stream）API 的功能，提供一种更灵活和强大的方式处理集合和流。流聚合器 API 是 Project Amber 的一部分，该项目致力于改进 Java 语言的某些方面。

以下是 JDK 22 中流聚合器 API 的一些关键特性：

1. **增强流操作**：流聚合器 API 引入了一种新的流操作，允许开发者以声明式的方式对集合进行更复杂的操作。

2. **简化集合处理**：通过流聚合器，可以更简洁地表达某些集合操作，减少中间集合的创建，提高代码的可读性和性能。

3. **预览特性**：作为预览特性，流聚合器 API 允许开发者提前尝试这个 API，并为 JDK 的未来版本提供反馈。

4. **与现有流 API 的兼容性**：流聚合器 API 与现有的 Java 流 API 兼容，可以作为现有流操作的补充。

5. **示例代码**：
   ```java
   // 假设有一个 Stream 的实例 stream
   Gatherer.builder()
           .addAll(stream)
           .resultCollector(/* 收集器 */)
           .build()
           .gathering();
   ```
   使用流聚合器可以以更灵活的方式处理流中的元素。

6. **JDK 22 中的位置**：流聚合器 API 作为 JDK 22 的一部分，允许开发者直接在标准 Java 应用程序中作为预览特性使用。

7. **未来发展**：随着 JDK 的发展，流聚合器 API 预计将在 JDK 的未来版本中根据开发者的反馈进行改进，并可能最终成为正式特性。

# 详细介绍 JDK 22 结构化并发

JDK 22 中的结构化并发（Structured Concurrency）是 Java 语言的一个预览特性，旨在简化和改进多线程程序的编写和管理。结构化并发通过将相关的并发任务组织为一个工作单元，从而简化错误处理、取消操作，并提高程序的可靠性和可观测性。

以下是 JDK 22 中结构化并发的一些关键特性：

1. **工作单元**：结构化并发将相关的并发任务（如线程或异步任务）组织为一个工作单元，这些任务作为一个整体被管理，便于集中处理取消和异常。

2. **错误传播**：如果工作单元中的一个任务失败，结构化并发可以自动取消同一工作单元中的其他任务，并将异常传播到父任务，简化了错误处理。

3. **作用域**：结构化并发通常与一个特定的代码块或作用域关联，任务的生命周期被限制在这个作用域内。

4. **取消操作**：结构化并发提供了一种机制，允许在不需要时取消整个工作单元中的所有任务。

5. **资源管理**：它与作用域结合，可以确保在作用域结束时自动释放资源，减少了资源泄露的风险。

6. **安全性**：结构化并发通过限制任务的执行范围，减少了并发编程中的许多常见错误，如死锁和竞态条件。

7. **与虚拟线程的协同**：结构化并发与虚拟线程紧密结合，使得在大量并发执行时，资源管理和错误处理更加高效。

8. **异步编程**：结构化并发也适用于异步编程模式，可以与 CompletableFuture 或其他异步 API 结合使用。

9. **预览特性**：在 JDK 22 中，结构化并发作为一个预览特性，允许开发者尝试这个 API 并提供反馈。

10. **示例代码**：
    ```java
    StructuredTaskScope scope = StructuredTaskScope.open();
    try {
        scope.spawn(() -> {
            // 这里是并发任务的代码
        });
        // 可以继续执行其他工作单元外的代码
    } finally {
        scope.close();
    }
    ```
    使用 `StructuredTaskScope` 可以定义一个结构化并发的作用域，并使用 `spawn` 方法来启动并发任务。

11. **资源清理**：在作用域结束时，所有启动的任务都将被取消，并且相关的资源将被清理。

12. **未来发展**：结构化并发预计将继续发展，并在 JDK 的未来版本中提供更稳定的 API。

# 详细介绍 JDK 22 作用域值

在 JDK 22 中，作用域值（Scoped Values）作为一个预览特性被引入，这是 Java 并发编程的一个重要补充。作用域值允许在线程内部和线程之间共享不可变数据，提供了一种优于传统 `ThreadLocal` 变量的新方式，特别是在大量使用虚拟线程时。

以下是 JDK 22 中作用域值的一些关键特性：

1. **不可变性**：作用域值是不可变的，这意味着一旦创建，它的值就不能被更改。这提供了线程安全性，因为不可变对象不需要额外的同步措施。

2. **作用域限制**：作用域值的访问受限于其声明的作用域，通常是一个代码块或方法调用栈。这限制了变量的可见性和生命周期，减少了作用域错误的风险。

3. **简化线程间共享**：与传统的线程局部变量（`ThreadLocal`）相比，作用域值提供了一种更简洁和更安全的方式来共享数据。它们允许在大型程序中的组件之间高效地共享数据，而无需通过方法参数传递。

4. **易于使用**：作用域值的 API 设计简单直观，易于理解和使用。开发者可以快速地声明和使用作用域值，而无需深入了解底层的并发机制。

5. **与虚拟线程的协同**：作用域值与 JDK 22 中的另一个特性——虚拟线程（Virtual Threads）——紧密集成。虚拟线程是轻量级的线程，适合编写高吞吐量的并发应用程序。

6. **性能优势**：由于作用域值的不可变性和作用域限制，它们在多线程环境中的性能通常优于传统的线程安全技术，如同步块或锁。

7. **预览特性**：作为预览特性，作用域值还处于早期开发阶段，可能会在未来的 JDK 版本中进行改进和优化。

8. **使用示例**：
   ```java
   final static ScopedValue<String> message = new ScopedValue<>();
   message.run(() -> {
       // 在这里访问或修改 message 的值
       String value = message.get();
       // ...
   });
   ```
   使用 `ScopedValue` 可以声明一个作用域值，并使用 `run` 方法来在特定作用域内访问或修改它的值。

# 详细介绍 JDK 22 字符串模板

JDK 22 引入了字符串模板（String Templates）作为第二轮预览特性，这是 Java 语言的一个新特性，旨在提供一种更简洁和高效的方式来构建字符串。字符串模板允许开发者使用类似于格式化字符串字面量的方式来创建字符串，同时保持了字符串的不可变性。

以下是 JDK 22 中字符串模板的一些关键特性：

1. **预览特性**：字符串模板在 JDK 22 中作为第二轮预览特性引入，这意味着它还在开发中，并且可能会根据用户反馈进行改进。

2. **简洁的语法**：字符串模板提供了一种新的字符串字面量语法，允许开发者在字符串中直接嵌入表达式，从而减少了字符串拼接的复杂性。

3. **类型安全**：字符串模板在编译时进行类型检查，确保嵌入的表达式与预期的字符串格式兼容，提高了代码的安全性。

4. **性能优化**：字符串模板的设计考虑了性能，它通过优化字符串的构建过程，减少了内存分配和字符串连接操作，提高了运行效率。

5. **格式化能力**：字符串模板支持格式化操作，允许开发者指定数字、日期等的格式，提供了与 `String.format` 类似的功能。

6. **使用示例**：
   ```java
   String name = "World";
   String greeting = `Hello, ${name}!`; // 使用字符串模板构建字符串
   ```

7. **与现有字符串处理的兼容性**：字符串模板设计为与现有的字符串处理方式兼容，使得开发者可以逐步采用这一新特性，而不是完全重写现有代码。

8. **未来发展**：作为预览特性，字符串模板预计在未来的 JDK 版本中会根据开发者的反馈进行调整，并可能在将来成为正式特性。

9. **JDK 22 中的位置**：字符串模板作为 JDK 22 的一部分，可以通过 Java 的字符串字面量直接使用。

# 详细介绍 JDK 22 未命名变量和模式

在 JDK 22 中，未命名变量和模式作为一个新特性被引入，旨在简化 Java 语言中的模式匹配和变量声明。这个特性通过引入新的语法结构，允许开发者在模式匹配和变量声明中忽略某些不需要的值，从而提高代码的可读性和简洁性。

以下是 JDK 22 中未命名变量和模式的一些关键特性：

1. **简化代码**：通过使用下划线 `_` 作为未命名模式或变量，开发者可以忽略在模式匹配中不需要的值，减少代码的冗余。

2. **提高可读性**：未命名模式和变量的使用使得代码更加直观，开发者可以更清晰地表达他们的意图，即某些值在当前上下文中是不必要的。

3. **减少模板代码**：在处理包含多个元素的数据结构时，如果某些元素不需要被单独处理，未命名模式和变量可以减少模板代码的编写。

4. **新特性**：这是 JDK 22 中引入的一个新特性，它体现了 Java 语言对简化编程模型的持续关注。

5. **示例代码**：
   ```java
   Object obj = ...;
   if (obj instanceof String _ || obj instanceof Integer _) {
       // 在这里，我们不关心具体的 String 或 Integer 值
   }
   ```

   在这个例子中，模式匹配使用了下划线 `_` 来表示开发者不关心 `String` 或 `Integer` 的具体值。

6. **与现有代码的兼容性**：尽管未命名模式和变量是一个新特性，但它设计为与现有的 Java 代码兼容，这意味着现有的代码可以在不做修改的情况下继续工作。

7. **未来发展**：随着 JDK 的发展，未命名模式和变量预计将在 JDK 的未来版本中根据开发者的反馈进行改进，并可能最终成为正式特性。

# 详细介绍 JDK 22 隐式声明类和实例主方法

在 JDK 22 中，隐式声明类和实例 `main` 方法作为一个预览特性被引入，旨在简化 Java 程序的编写，特别是在创建小型工具或快速原型时。这个特性允许开发者在不显式定义类的情况下编写 `main` 方法，从而减少样板代码并使程序入口点更加直观。

以下是 JDK 22 中隐式声明类和实例 `main` 方法的一些关键特性：

1. **简化程序入口**：开发者可以直接在源文件中编写 `main` 方法，而不需要创建一个单独的类来封装它。

2. **减少样板代码**：隐式声明类的特性避免了编写重复的类定义代码，这在处理小型程序或脚本时非常有用。

3. **易于理解和使用**：对于 Java 初学者来说，隐式声明类和 `main` 方法的引入降低了学习曲线，使得他们可以更快地开始编写简单的 Java 程序。

4. **预览特性**：作为预览特性，隐式声明类和实例 `main` 方法在 JDK 22 中引入，这意味着它还在开发中，并且可能会根据用户反馈进行改进。

5. **示例代码**：
   ```java
   public static void main(String[] args) {
       // 程序逻辑
   }
   ```
   在这个示例中，`main` 方法直接出现在源文件中，没有被包裹在一个类定义中。

6. **与现有代码的兼容性**：尽管隐式声明类和实例 `main` 方法是一个新特性，但它设计为与现有的 Java 代码兼容，这意味着现有的类定义和 `main` 方法的使用不受影响。

7. **未来发展**：随着 JDK 的发展，隐式声明类和实例 `main` 方法预计将在 JDK 的未来版本中成为正式特性，从而成为 Java 程序员在编写简单程序时的一个有用工具。

# 详细介绍 JDK 22 G1 的区域固定

JDK 22 引入了 G1 垃圾收集器的区域固定（Region Pinning）特性，这是通过 JEP 423 实现的。这项特性旨在减少垃圾回收（Garbage Collection，GC）的延迟，特别是在与 Java 本地接口（JNI）关键区域交互时。

以下是 JDK 22 中 G1 区域固定的一些关键特性：

1. **减少 GC 延迟**：通过实现区域固定，G1 垃圾收集器在 JNI 关键区域期间不需要完全禁用，从而减少了停顿时间。

2. **改善 JNI 互操作性**：JNI 关键区域是 Java 代码与非托管代码（如 C 或 C++）交互的点。在这些点上，GC 通常会被禁用以避免对象移动，这可能导致性能问题。区域固定允许在这些关键区域中安全地进行垃圾回收。

3. **内存区域固定**：G1 垃圾收集器可以固定包含关键对象的内存区域，这样即使在进行垃圾回收时，这些区域也不会被清理或移动。

4. **计数机制**：区域固定通过在每个区域中维护关键对象的计数来实现，在获取关键对象时增加计数，在释放时减少，以此来决定是否固定区域。

5. **提高性能**：这种机制确保了关键对象不会被移动，同时避免了完全禁用 GC，显著降低了延迟，提高了应用程序的性能。

6. **潜在风险**：虽然区域固定带来了性能上的改进，但也存在潜在风险，如如果应用程序同时固定多个区域，可能会导致堆内存耗尽。不过，从已经实现了类似机制的 Shenandoah GC 来看，这种风险是可控的。

7. **技术增强**：JEP 423 为 OpenJDK 的 G1 垃圾回收器引入了重大的技术增强，改进了 JVM 在与非托管语言发生互操作时的垃圾回收处理。

8. **Java 垃圾回收机制的进步**：这项新特性代表了 Java 垃圾回收机制的重大进步，解决了与 JNI 关键区域相关的延迟问题。

9. **JDK 22 的一部分**：作为 JDK 22 的一部分，区域固定特性通过减少 GC 停顿时间，提升了 Java 应用的性能，尤其是在涉及大量 JNI 交互的场景中。

# 详细介绍 JDK 22 启动多文件源代码程序

JDK 22 引入了一个新特性，允许开发者直接从命令行启动由多个 Java 源代码文件组成的程序，而无需先将它们编译成类文件。这个特性由 JEP 458 实现，它提供了一种更简单快捷的方式来运行和测试小型的 Java 程序，特别是对于教育、快速原型开发和临时脚本编写等场景。

以下是 JDK 22 中启动多文件源代码程序特性的一些关键点：

1. **简化编译过程**：开发者可以直接运行多个源文件组成的程序，无需单独编译每个文件并运行生成的类文件。

2. **提高效率**：这个特性使得从编写代码到程序运行的周期更短，特别适合快速迭代和测试。

3. **命令行支持**：通过在命令行中使用 `java` 命令，可以直接启动包含多个源文件的程序。

4. **适用场景**：这个特性特别适合小型项目和学习 Java 的初学者，因为它减少了配置构建工具的复杂性。

5. **示例代码**：
   ```shell
   java MyProgram.java OtherFile.java
   ```
   在这个例子中，`MyProgram.java` 和 `OtherFile.java` 是程序的源代码文件，可以直接通过 `java` 命令运行。

6. **与构建工具的互补**：虽然这个特性简化了小型程序的运行，但对于大型项目，构建工具如 Maven 或 Gradle 仍然是必需的。

7. **JDK 22 的一部分**：作为 JDK 22 的一部分，这个特性体现了 Java 平台对开发者体验的持续关注和改进。

8. **未来发展**：预计这个特性将在未来 Java 版本中继续存在，并可能根据开发者的反馈进行改进。


# 详细介绍 JDK 22 Markdown 文档注释

JDK 22 引入了一个新的特性，即 Markdown 文档注释，这是通过 JEP 467 实现的。这个特性建议允许 JavaDoc 文档注释以 Markdown 格式编写，而不仅仅是 HTML 和 JavaDoc `@` 标记的混合体。以下是 JDK 22 中 Markdown 文档注释的一些关键特性：

1. **易于编写和阅读**：Markdown 是一种轻量级的标记语言，它以易读易写而闻名。引入 Markdown 将使文档注释在源代码形式下更易于编写和阅读。

2. **保留现有功能**：现有的 HTML 和 JavaDoc 标记不会被弃用，Markdown 注释将作为另一种可选的方式来增强文档的可读性。

3. **兼容性**：为了向下兼容，现有的 `/** ... */` 注释语法仍然有效。新的 Markdown 注释使用 `///` 开头，以区分传统的 JavaDoc 注释。

4. **增强的链接支持**：在 Markdown 文档注释中，提供了一种扩展的 Markdown 引用链接形式，允许方便地链接到 API 中的其他元素。

5. **JavaDoc 标签支持**：JavaDoc 标签，包括内联标签如 `{@inheritDoc}` 和块标签如 `@param` 和 `@return`，都可以在 Markdown 文档注释中使用。

6. **未来工作**：JEP 467 还提到了一些未来的工作方向，比如可能将一些 Markdown 标题自动转换为相应的 JavaDoc 标签。

7. **风险和假设**：实施该特性时使用了第三方库 commonmark-java 来将 Markdown 转换为 HTML。如果该库不再维护，OpenJDK 社区可能需要维护该库的分支或寻找替代方案。

8. **语法细节**：为了处理 Markdown 中重要的空白字符，文档注释的内容会根据特定的规则进行处理，以确保 Markdown 的格式和意图被正确解析。

9. **渲染和呈现**：`javadoc` 工具将 Markdown 注释渲染为 HTML，同时保留了链接和其他 JavaDoc 功能。

10. **社区反馈**：JEP 467 是基于社区反馈和对 Java 文档实践的观察而提出的，目的是改善开发者编写和维护文档的体验。

# 详细介绍 JDK 22 类文件 API

JDK 22 引入了类文件 API（Class-File API），这是通过 JEP 457 实现的一个预览特性。这个 API 提供了一套工具，用于解析、生成和转换 Java 类文件。以下是 JDK 22 中类文件 API 的一些关键特性：

1. **预览特性**：类文件 API 在 JDK 22 中作为预览特性提供，允许开发者提前尝试这个 API，并为 JDK 的未来版本提供反馈。

2. **简化类文件操作**：该 API 旨在简化与类文件的交互，提供一种标准化和简化的方式来处理类文件。

3. **不可变对象**：类文件 API 将类文件实体（如字段、方法、属性和字节码指令）视为不可变对象，这有助于在类文件转换时可靠地进行共享。

4. **树形结构**：API 采用树形结构来反映类文件的层次结构，支持用户驱动的导航以进行高效地解析。

5. **延迟解析**：类文件 API 强调解析过程的延迟性，即只会处理满足用户需求所需的类文件，这提高了效率。

6. **模式解析**：该 API 引入了使用模式解析类文件的新方法，与基于访问者的旧方式（如 ASM 库）有所不同，支持更直接和更简洁的表达式。

7. **元素、构建器和转换**：类文件 API 包含三个主要的抽象：元素（类文件组件的不可变描述）、构建器（用于构造类文件的特定构建方法）和转换（在构建过程中修改元素的函数）。

8. **替代 ASM**：类文件 API 最初将作为 JDK 中 Java 字节码操作和分析框架 ASM 的内部替代品，并计划将其作为公共 API 开放。

9. **使用示例**：
   ```java
   ClassFile cf = ClassFile.of();
   ClassModel classModel = cf.parse(bytes);
   byte[] newBytes = cf.transform(classModel, (classBuilder, ce) -> {
       // 转换逻辑
   });
   ```
   在这个示例中，开发者可以使用类文件 API 来解析和转换类文件。

10. **未来发展**：Java 语言架构师 Brian Goetz 描述了 ASM 是一个“带有大量遗留包袱的旧代码库”，并提供了关于类文件 API 如何发展并最终取代 ASM 的背景信息。

* any list
{:toc}