---
layout: post
title: java 变更日志-22-jdk22
date:  2017-06-28 23:15:43 +0800
categories: [Java]
tags: [jdk, java]
published: true
---

# 拓展阅读

[Java Functional java 函数式编程](https://houbb.github.io/2017/06/29/java-functional)

[Java Lambda](https://houbb.github.io/2017/06/28/java-lambda)


# 新功能：Java 22

JDK 22 提供了12项显著的增强功能，足以获得它们自己的JDK增强提案（JEPs），其中包括七个预览功能和一个孵化器功能。

它们涵盖了Java语言、其API、性能以及JDK中包含的工具的改进。

### 1) 语言改进

#### 未命名变量和模式 - JEP 456

当需要但未使用变量声明或嵌套模式时，提高可读性。两者都由下划线字符表示。

**价值：**

- 捕捉开发人员意图，使得给定的绑定或lambda参数未使用，并强制执行该属性以清晰程序并减少错误的机会。
- 通过识别必须声明但未使用的变量（例如，在catch子句中）提高所有代码的可维护性。
- 允许在单个case标签中出现多个模式，如果它们都没有声明任何模式变量。
- 通过省略不必要的嵌套类型模式，提高记录模式的可读性。

#### 1.1) 语言预览

##### 在super（...）之前的语句 [预览] - JEP 447

在构造函数中，允许在显式构造函数调用之前出现不引用正在创建的实例的语句。

**价值：**

- 给予开发人员更大的自由度，以表达构造函数的行为，使得当前必须被分解为辅助静态方法、辅助中间构造函数或构造函数参数的逻辑更自然地放置。
- 保留现有保证，即构造函数在类实例化期间按自上而下的顺序运行，确保子类构造函数中的代码不能干扰超类实例化。
- 不需要对Java虚拟机进行任何更改。此Java语言功能仅依赖于JVM当前验证和执行构造函数内显式构造函数调用之前的代码的能力。

##### 字符串模板（第二预览）- JEP 459

字符串模板通过将字面文本与嵌入式表达式和模板处理器结合，产生专门的结果，补充了Java现有的字符串字面值和文本块。

**价值：**

- 通过轻松表达包含在运行时计算的值的字符串，简化Java程序的编写。
- 提高混合文本和表达式的可读性，无论文本是否适合单个源行（如字符串字面值）或跨越几个源行（如文本块）。
- 通过支持验证和转换模板及其嵌入式表达式的值，增强从用户提供的值组合字符串并将其传递给其他系统（例如，为数据库构建查询）的Java程序的安全性。
- 保留灵活性，允许Java库定义字符串模板中使用的格式化语法。
- 简化接受非Java语言（例如SQL、XML和JSON）编写的字符串的API的使用。
- 无需经过中间字符串表示，即可从字面文本和嵌入式表达式计算非字符串值。

##### 隐式声明的类和实例主方法（第二预览）- JEP 463

学生可以编写他们的第一个Java程序，无需理解为大型程序设计的语言特性。学生可以为单类程序编写简化的声明，然后根据他们的技能增长无缝扩展他们的程序。

**价值：**

- 为了加速Java学习：
  - 提供流畅的Java编程入门，以便教师可以逐步引入概念。
  - 帮助学生以简洁的方式编写基本程序，并随着他们的技能增长而逐步增长他们的代码。
  - 减少编写简单程序（如脚本和命令行实用程序）的仪式。
- 不引入Java语言的单独初学者方言。
- 不引入单独的初学者工具链；学生程序应使用编译和运行任何Java程序的相同工具编译和运行。


### 2) 库

#### 外部函数和内存API - JEP 454

允许Java程序与Java运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即JVM之外的代码），并安全地访问外部内存（即JVM未管理的内存），该API使Java程序能够调用本地库并处理本地数据，而不会像JNI那样脆弱和危险。

**价值：**

- **生产力** — 用简洁、可读和纯Java的API替换本地方法和Java Native Interface (JNI)的脆弱机制。
- **性能** — 提供访问外部函数和内存的开销，与或更好于JNI和sun.misc.Unsafe相当。
- **广泛的平台支持** — 在JVM运行的每个平台上启用本地库的发现和调用。
- **统一性** — 提供操作结构化和非结构化数据的方法，在多种内存（例如，本地内存、持久内存和托管堆内存）中，数据大小不受限制。
- **健全性** — 保证没有使用后释放的错误，即使内存在多个线程中分配和释放。
- **完整性** — 允许程序执行与本地代码和数据不安全的操作，但默认警告用户此类操作。

#### 2.1) 库预览和孵化器

##### 类文件API（预览）- JEP 457

提供了一个标准API，用于解析、生成和转换Java类文件。

**价值：**

- API允许依赖它的框架和程序自动支持最新的JDK中的最新类文件，以便能够快速、容易地采纳具有在类文件中表示的新语言和VM特性。

##### 流收集器（预览）- JEP 461

增强了Stream API以支持自定义中间操作。这将允许流管道以不容易使用现有内置中间操作实现的方式转换数据。

**价值：**

- 通过使流中常见的自定义操作更加灵活和富有表现力，提高开发人员的生产力和代码可读性。尽可能地，允许中间操作操作无限大小的流。

##### 结构化并发（第二预览）- JEP 462

简化了并发编程。结构化并发将在不同线程中运行的相关任务组视为一个工作单元，从而简化错误处理和取消，提高可靠性，并增强可观察性。

**价值：**

- 通过提倡可以消除由于取消和关闭引起的常见风险的编程风格，简化并发代码的开发，并改进并发代码的可观察性。

##### 作用域值（第二预览）- JEP 464

在和跨线程之间有效共享不可变数据。

**价值：**

- **易用性** — 提供一种编程模型，以在线程内和与子线程共享数据，简化对数据流的推理。
- **可理解性** — 使共享数据的生命周期从代码的语法结构中可见。
- **健壮性** — 确保调用者共享的数据只能由合法的被调用者检索。
- **性能** — 将共享数据视为不可变的，以允许大量线程共享，并启用运行时优化。

##### 向量API（第七孵化器）- JEP 460

一个API，用于表达可靠地在支持的CPU架构上运行时编译为最佳向量指令的向量计算，从而实现与等效标量计算相比的优越性能。

这个JEP建议在JDK 22中重新孵化API，在JDK 21相对于API中进行了小的增强。实现包括错误修复和性能增强。我们包括以下值得注意的更改：

- **支持**使用任何原始元素类型数组支持的堆MemorySegments进行向量访问。先前的访问限制为由字节数组支持的堆MemorySegments。

**价值：**

- 提供一个清晰、简洁的API，能够清晰、简洁地表达由循环组成的向量操作序列，可能带有控制流。
- API旨在是CPU架构不可知的，支持支持向量指令的多个架构的实现。
- 在x64和AArch64架构上提供可靠的运行时编译和性能。
- 与Project Valhalla对齐。

### 3) 性能

#### G1区域固定 - JEP 423

通过在G1中实现区域固定来减少延迟，使得在Java Native Interface (JNI)关键区域期间无需禁用垃圾收集。

**价值：**

- **提高开发人员生产力** — 消除Java线程在使用JNI时需要等待G1 GC操作完成的需求。

### 4) 工具

#### 启动多文件源代码程序 - JEP 458

允许用户运行作为多个Java源代码文件提供的程序，而无需首先对其进行编译。

**价值：**

- **提高开发人员生产力** — 使从小程序到大程序的过渡更加逐步，使开发人员能够选择是否以及何时去麻烦配置构建工具。

**注意**：预览功能是Java SE平台的完全指定和完全实现的语言或VM功能，但是它们是不稳定的。它们在JDK功能发布中可用，以便基于实际用途获取开发人员的反馈，然后在未来的发布中变为永久性的。这也为工具供应商提供了在它们被最终确定为Java SE标准之前支持功能的机会。

**孵化器模块中的API**将非最终API和非最终工具交到开发人员和用户手中，以收集反馈，最终提高Java平台的质量。

除了JEPs中描述的变化，发布说明中还列出了许多对许多应用程序开发人员和系统管理员感兴趣的较小的更新。这些包括废弃的过时API和先前已废弃的API的移除。

**Java 22发布说明的一些关键更新**：

- 向keytool和jarsigner添加额外的算法。
- 垃圾收集器吞吐量改进，特别是与“young”垃圾相关的部分。
- 更好的系统模块描述符的版本报告。
- 为本地代码改进的“等待”处理选项。
- Unicode Common Locale Data Repository已更新到版本44。
- 从字节码加载的类型的类型注解支持。
- ForkJoinPool和ForJoinTasks现在可以更好地处理不可中断的任务。
- 配置客户端与服务器TLS连接属性的额外灵活性。
- 改进的本地内存跟踪，包括报告峰值使用量。

**最后**，像所有功能发布一样，JDK 22包括数百个性能、稳定性和安全性更新，包括适应底层操作系统和固件更新以及标准。

用户和应用程序开发人员通常从这些更改中受益，而不会注意到它们。

### 常数特性：可预测性

JDK 22是按时通过六个月的发布周期交付的第13个功能发布。这种可预测性允许开发人员轻松管理他们对创新的采纳，因为有一系列预期的改进。

Java的提升性能、稳定性和安全性的能力使其继续成为世界上最受欢迎的编程语言。

Oracle不会为JDK 22提供长期支持；我们将在2024年9月之前提供更新，届时它将被Oracle JDK 23所替代。

![](https://gitee.com/houbinbin/imgbed/raw/master/img/20240426094145.png)

**Java 22，共同**

与以前的版本一样，Java 22庆祝了OpenJDK社区中许多个人和组织的贡献 — 我们一起构建Java！

**JDK 22修复比率**

多年来，JDK发布的变化速度基本保持不变，但在六个月的周期下，交付生产就绪的功能和改进的速度大大增加。

与过去的主要发布相比，每隔几年进行数万次修复并交付近百个JEP（JDK增强提案），现在改进是在更易于管理和可预测的六个月计划中的更精简的功能发布中进行的。这些变化从重大的新功能到小的增强，到例行维护、错误修复和文档改进都有。每个更改都在JDK Bug系统中的单个问题的单个提交中表示。

在Java 11到Java 22的GA时间，标记为已修复的26,447个JIRA问题中，有18,842个是由Oracle员工完成的，而有7,605个是由个人开发人员和其他组织的开发人员贡献的。通过检查这些问题并整理来自受让方的组织数据，得到了以下Java贡献开发的组织赞助图表：

![](https://gitee.com/houbinbin/imgbed/raw/master/img/20240426094221.png)

在Java 22中，标记为已修复的2,251个JIRA问题中，有1,554个由Oracle完成，而697个由Java社区的其他成员贡献。

![](https://gitee.com/houbinbin/imgbed/raw/master/img/20240426094352.png)

Oracle想要感谢来自以下组织的开发人员，包括Amazon、ARM、Google、华为、IBM、Intel、ISCAS、Microsoft、Red Hat、Rivos、SAP和腾讯，因为他们的显著贡献。我们也很感谢来自Bellsoft Data Dog和Loongson等较小组织以及独立开发人员的贡献，他们共同贡献了Java 22中7%的修复。

此外，通过OpenJDK Quality Outreach计划，我们想要感谢以下FOSS项目，他们为早期访问构建的Java 22提供了出色的测试反馈，帮助提高了发布的质量：

- Apache Syncope（Francesco Chicchiriccò）
- Apache Tomcat（Mark Thomas）
- ApprovalTests.Java（Lars Eckart）
- AssertJ（Stefano Cordio）
- Avaje（Josiah Noel）
- Jetty（Simone Bordet）
- MyBatis（Iwao Ave）
- Parallel Collectors（Grzegorz Piwowarek）
- RxJava（David Karnok）

**资源**

Java继续是当今技术趋势的第一编程语言。正如Java 22的及时交付改进所展示的，通过持续的深思熟虑的规划和生态系统参与，Java平台为现代开发和云增长做好了准备。

继续通过以下方式保持与新闻和更新的同步：

- 访问[Dev.java](https://dev.java)（Oracle专门用于提升您的Java知识和社区参与的门户）。
- 访问[Inside.java](https://inside.java)（Oracle的Java团队的新闻和观点）。
- 听[Inside.java podcasts](https://inside.java/podcasts)（为Java开发人员提供的由Oracle直接带给您的音频节目。对话将讨论语言、JVM、OpenJDK、平台安全性、像Loom和Panama这样的创新项目，以及各种中间内容）。
- 观看[Inside.java Newscasts](https://inside.java/newscasts)（一个视频节目，将Inside.java podcast扩展为视频格式）。
- 观看[Java on YouTube](https://www.youtube.com/user/officialoracletechnet)（Oracle的相关Java视频集合，帮助您提高Java专业知识）。
- 观看[JEP Café](https://www.oracle.com/java/technologies/javase/jep-cafe.html)（Oracle对流行JDK增强提案的技术探索）。
- 观看[Sip of Java](https://www.oracle.com/java/sip-of-java.html)（Oracle的1分钟短视频，介绍了一些鲜为人知的Java增强功能，提供性能、稳定性和安全性的改进）。
- 加入[OpenJDK邮件列表](https://mail.openjdk.java.net/mailman/listinfo)（了解您最喜欢的OpenJDK项目的进展）。
- 关注[OpenJDK和Java on X](https://openjdk.java.net/social/)（提供关于Java持续演变的更新和新闻的社交流）。
- 订阅[Inside Java Newsletter](https://inside.java/newsletter)（Oracle每月出版，总结了Oracle的许多关键Java技术和社区更新）。



------------------------------------------------------------------------------------------------------------


# jdk22 有哪些新特性

JDK 22 引入了一系列新特性，这些特性增强了 Java 平台的能力，包括语言的新特性、API 的改进、性能提升以及工具的增强。

以下是 JDK 22 中的一些主要新特性：

1. **外部函数和内存 API（Foreign Function & Memory API）**：JEP 454，这个特性旨在简化 Java 程序与本地代码和数据的互操作，提供了一种更安全和高效的方式来调用本地库。

2. **向量 API（Vector API）**：JEP 460，第七轮孵化，这个特性允许开发者表达向量计算，这些计算可以在运行时编译为特定 CPU 架构上的最佳向量指令。

3. **流聚合器（Gatherer API）**：JEP 461，预览特性，提供了一个更灵活的 API 来处理流，允许开发者插入自定义的操作符。

4. **结构化并发（Structured Concurrency）**：JEP 462，第二轮预览，这个特性通过将相关任务组视为单个工作单元来简化并发编程。

5. **作用域值（Scoped Values）**：JEP 464，第二轮预览，这个特性允许在线程内部和线程之间共享不可变数据。

6. **字符串模板（String Templates）**：JEP 459，第二轮预览，提供了一种新的字符串字面量，支持嵌入式表达式。

7. **未命名变量和模式（Unnamed Variables & Patterns）**：JEP 456，这个特性允许在模式匹配中使用未命名的变量和模式，提高了代码的可读性。

8. **隐式声明类和实例主方法（Implicitly Declared Classes and Instance Main Methods）**：JEP 463，第二轮预览，允许开发者编写更简洁的类和实例 `main` 方法。

9. **G1 的区域固定（Regional Pinning for G1）**：JEP 423，通过在 G1 垃圾回收器中实现区域固定来减少延迟。

10. **启动多文件源代码程序（Launch Multi-File Source-Code Programs）**：JEP 458，允许用户直接运行由多个 Java 源代码文件组成的程序，无需先进行编译。

11. **Markdown 文档注释（Markdown Documentation Comments）**：JEP 467，提议支持以 Markdown 格式编写 Javadoc 文档注释。

12. **类文件 API（Class-File API）**：JEP 466，第二轮预览，提供 API 来解析、生成和转换 Java 类文件。

这些特性展示了 Java 平台的持续进步，旨在提高开发者的生产力，增强程序性能，并简化与本地代码的互操作。

# 详细介绍 JDK 22 外部函数和内存 API

JDK 22 引入了外部函数和内存 API（通常称为 Project Panama 的一部分），这是一个重要的特性，它允许 Java 程序安全且高效地与 Java 运行时环境之外的代码和数据进行互操作。这个特性在 JDK 17 作为孵化特性首次引入，并在 JDK 18、JDK 19、JDK 20、JDK 21 中作为预览特性不断演进，最终在 JDK 22 中成为正式特性。

以下是 JDK 22 中外部函数和内存 API 的一些关键特性：

1. **安全互操作**：API 旨在提供一种比 Java Native Interface (JNI) 更安全的方法来调用本地库和操作非 JVM 管理的内存。

2. **简化的 FFI**：外部函数和内存 API 旨在简化 Java 与本地代码之间的互操作，减少 JNI 带来的复杂性和风险。

3. **内存操作**：API 提供了对非 JVM 管理内存的访问，允许 Java 代码分配、访问和操作本地内存。

4. **外部函数调用**：开发者可以使用这个 API 调用用 C 或其他语言编写的本地函数，直接从 Java 代码中。

5. **动态链接**：API 支持动态链接本地库，无需在 JVM 启动时指定所有本地库。

6. **资源类型**：引入了资源类型的概念，这些资源在作用域结束时自动被清理，减少了内存泄漏和其他资源管理问题。

7. **方法句柄**：API 使用方法句柄来表示和调用外部函数，这使得调用过程更加自然和高效。

8. **正式特性**：作为正式特性，外部函数和内存 API 允许开发者在生产环境中使用这个 API，并期望它在 JDK 的未来版本中保持稳定。

9. **示例代码**：
   ```java
   // 假设已经加载了某个本地库，并且库中有一个名为 "compute" 的函数
   MethodHandle computeHandle = lookup().find("compute");
   int result = (int) computeHandle.invokeExact(arg1, arg2);
   ```

10. **与 JNI 的关系**：FFM API 旨在最终取代 JNI，提供一种更安全和高效的方式来处理 Java 与本地代码的互操作。

11. **未来发展**：随着 JDK 的发展，外部函数和内存 API 预计将在未来版本中继续得到增强和改进。

# 详细介绍 JDK 22 向量 API

JDK 22 中的向量 API（Vector API）是一个重要的特性，它在 JDK 22 中作为第七轮孵化版引入。这个 API 提供了一种表达方式，让开发者能够利用现代 CPU 架构的 SIMD（单指令多数据）指令集进行高效的向量计算。以下是 JDK 22 中向量 API 的一些关键特性：

1. **高效性能**：向量 API 允许开发者编写可以在运行时编译为特定 CPU 架构上最佳向量指令的代码，从而实现优于等效标量计算的性能。

2. **平台无关性**：向量 API 提供了一种与平台无关的方式来表达向量计算，使得开发者可以编写一次代码，然后在支持的 CPU 架构上运行，以利用硬件加速。

3. **安全性**：与直接使用 SIMD 指令相比，向量 API 提供了更高级别的抽象，减少了因错误使用硬件指令而带来的风险。

4. **表达能力**：向量 API 提供了丰富的表达能力，允许开发者以声明式的方式编写复杂的向量运算。

5. **内存段操作**：向量 API 增强了对 `MemorySegment` 的操作，允许从 `MemorySegment` 加载和存储向量，这与外部函数和内存 API 的预览定义相一致。

6. **错误修复和性能增强**：在 JDK 22 中，向量 API 包括了错误修复和性能增强，例如支持使用任何原始元素类型的数组支持的堆 `MemorySegments` 进行向量访问，而以前仅限于由字节数组支持的堆 `MemorySegment`。

7. **孵化阶段**：作为孵化 API，向量 API 允许开发者尝试这个 API 并提供反馈，以便进一步的开发和改进。

8. **未来发展**：随着 JDK 的发展，向量 API 预计将逐渐趋于稳定，并在未来版本中成为正式特性，从而为 Java 程序提供更广泛的硬件加速能力。

# 详细介绍 JDK 22 流聚合器 API

JDK 22 引入了流聚合器（Stream Gatherers）API 作为预览特性，这是 Java 语言的一个新特性，旨在增强流（Stream）API 的功能，提供一种更灵活和强大的方式处理集合和流。流聚合器 API 是 Project Amber 的一部分，该项目致力于改进 Java 语言的某些方面。

以下是 JDK 22 中流聚合器 API 的一些关键特性：

1. **增强流操作**：流聚合器 API 引入了一种新的流操作，允许开发者以声明式的方式对集合进行更复杂的操作。

2. **简化集合处理**：通过流聚合器，可以更简洁地表达某些集合操作，减少中间集合的创建，提高代码的可读性和性能。

3. **预览特性**：作为预览特性，流聚合器 API 允许开发者提前尝试这个 API，并为 JDK 的未来版本提供反馈。

4. **与现有流 API 的兼容性**：流聚合器 API 与现有的 Java 流 API 兼容，可以作为现有流操作的补充。

5. **示例代码**：
   ```java
   // 假设有一个 Stream 的实例 stream
   Gatherer.builder()
           .addAll(stream)
           .resultCollector(/* 收集器 */)
           .build()
           .gathering();
   ```
   使用流聚合器可以以更灵活的方式处理流中的元素。

6. **JDK 22 中的位置**：流聚合器 API 作为 JDK 22 的一部分，允许开发者直接在标准 Java 应用程序中作为预览特性使用。

7. **未来发展**：随着 JDK 的发展，流聚合器 API 预计将在 JDK 的未来版本中根据开发者的反馈进行改进，并可能最终成为正式特性。

# 详细介绍 JDK 22 结构化并发

JDK 22 中的结构化并发（Structured Concurrency）是 Java 语言的一个预览特性，旨在简化和改进多线程程序的编写和管理。结构化并发通过将相关的并发任务组织为一个工作单元，从而简化错误处理、取消操作，并提高程序的可靠性和可观测性。

以下是 JDK 22 中结构化并发的一些关键特性：

1. **工作单元**：结构化并发将相关的并发任务（如线程或异步任务）组织为一个工作单元，这些任务作为一个整体被管理，便于集中处理取消和异常。

2. **错误传播**：如果工作单元中的一个任务失败，结构化并发可以自动取消同一工作单元中的其他任务，并将异常传播到父任务，简化了错误处理。

3. **作用域**：结构化并发通常与一个特定的代码块或作用域关联，任务的生命周期被限制在这个作用域内。

4. **取消操作**：结构化并发提供了一种机制，允许在不需要时取消整个工作单元中的所有任务。

5. **资源管理**：它与作用域结合，可以确保在作用域结束时自动释放资源，减少了资源泄露的风险。

6. **安全性**：结构化并发通过限制任务的执行范围，减少了并发编程中的许多常见错误，如死锁和竞态条件。

7. **与虚拟线程的协同**：结构化并发与虚拟线程紧密结合，使得在大量并发执行时，资源管理和错误处理更加高效。

8. **异步编程**：结构化并发也适用于异步编程模式，可以与 CompletableFuture 或其他异步 API 结合使用。

9. **预览特性**：在 JDK 22 中，结构化并发作为一个预览特性，允许开发者尝试这个 API 并提供反馈。

10. **示例代码**：
    ```java
    StructuredTaskScope scope = StructuredTaskScope.open();
    try {
        scope.spawn(() -> {
            // 这里是并发任务的代码
        });
        // 可以继续执行其他工作单元外的代码
    } finally {
        scope.close();
    }
    ```
    使用 `StructuredTaskScope` 可以定义一个结构化并发的作用域，并使用 `spawn` 方法来启动并发任务。

11. **资源清理**：在作用域结束时，所有启动的任务都将被取消，并且相关的资源将被清理。

12. **未来发展**：结构化并发预计将继续发展，并在 JDK 的未来版本中提供更稳定的 API。

# 详细介绍 JDK 22 作用域值

在 JDK 22 中，作用域值（Scoped Values）作为一个预览特性被引入，这是 Java 并发编程的一个重要补充。作用域值允许在线程内部和线程之间共享不可变数据，提供了一种优于传统 `ThreadLocal` 变量的新方式，特别是在大量使用虚拟线程时。

以下是 JDK 22 中作用域值的一些关键特性：

1. **不可变性**：作用域值是不可变的，这意味着一旦创建，它的值就不能被更改。这提供了线程安全性，因为不可变对象不需要额外的同步措施。

2. **作用域限制**：作用域值的访问受限于其声明的作用域，通常是一个代码块或方法调用栈。这限制了变量的可见性和生命周期，减少了作用域错误的风险。

3. **简化线程间共享**：与传统的线程局部变量（`ThreadLocal`）相比，作用域值提供了一种更简洁和更安全的方式来共享数据。它们允许在大型程序中的组件之间高效地共享数据，而无需通过方法参数传递。

4. **易于使用**：作用域值的 API 设计简单直观，易于理解和使用。开发者可以快速地声明和使用作用域值，而无需深入了解底层的并发机制。

5. **与虚拟线程的协同**：作用域值与 JDK 22 中的另一个特性——虚拟线程（Virtual Threads）——紧密集成。虚拟线程是轻量级的线程，适合编写高吞吐量的并发应用程序。

6. **性能优势**：由于作用域值的不可变性和作用域限制，它们在多线程环境中的性能通常优于传统的线程安全技术，如同步块或锁。

7. **预览特性**：作为预览特性，作用域值还处于早期开发阶段，可能会在未来的 JDK 版本中进行改进和优化。

8. **使用示例**：
   ```java
   final static ScopedValue<String> message = new ScopedValue<>();
   message.run(() -> {
       // 在这里访问或修改 message 的值
       String value = message.get();
       // ...
   });
   ```
   使用 `ScopedValue` 可以声明一个作用域值，并使用 `run` 方法来在特定作用域内访问或修改它的值。

# 详细介绍 JDK 22 字符串模板

JDK 22 引入了字符串模板（String Templates）作为第二轮预览特性，这是 Java 语言的一个新特性，旨在提供一种更简洁和高效的方式来构建字符串。字符串模板允许开发者使用类似于格式化字符串字面量的方式来创建字符串，同时保持了字符串的不可变性。

以下是 JDK 22 中字符串模板的一些关键特性：

1. **预览特性**：字符串模板在 JDK 22 中作为第二轮预览特性引入，这意味着它还在开发中，并且可能会根据用户反馈进行改进。

2. **简洁的语法**：字符串模板提供了一种新的字符串字面量语法，允许开发者在字符串中直接嵌入表达式，从而减少了字符串拼接的复杂性。

3. **类型安全**：字符串模板在编译时进行类型检查，确保嵌入的表达式与预期的字符串格式兼容，提高了代码的安全性。

4. **性能优化**：字符串模板的设计考虑了性能，它通过优化字符串的构建过程，减少了内存分配和字符串连接操作，提高了运行效率。

5. **格式化能力**：字符串模板支持格式化操作，允许开发者指定数字、日期等的格式，提供了与 `String.format` 类似的功能。

6. **使用示例**：
   ```java
   String name = "World";
   String greeting = `Hello, ${name}!`; // 使用字符串模板构建字符串
   ```

7. **与现有字符串处理的兼容性**：字符串模板设计为与现有的字符串处理方式兼容，使得开发者可以逐步采用这一新特性，而不是完全重写现有代码。

8. **未来发展**：作为预览特性，字符串模板预计在未来的 JDK 版本中会根据开发者的反馈进行调整，并可能在将来成为正式特性。

9. **JDK 22 中的位置**：字符串模板作为 JDK 22 的一部分，可以通过 Java 的字符串字面量直接使用。

# 详细介绍 JDK 22 未命名变量和模式

在 JDK 22 中，未命名变量和模式作为一个新特性被引入，旨在简化 Java 语言中的模式匹配和变量声明。这个特性通过引入新的语法结构，允许开发者在模式匹配和变量声明中忽略某些不需要的值，从而提高代码的可读性和简洁性。

以下是 JDK 22 中未命名变量和模式的一些关键特性：

1. **简化代码**：通过使用下划线 `_` 作为未命名模式或变量，开发者可以忽略在模式匹配中不需要的值，减少代码的冗余。

2. **提高可读性**：未命名模式和变量的使用使得代码更加直观，开发者可以更清晰地表达他们的意图，即某些值在当前上下文中是不必要的。

3. **减少模板代码**：在处理包含多个元素的数据结构时，如果某些元素不需要被单独处理，未命名模式和变量可以减少模板代码的编写。

4. **新特性**：这是 JDK 22 中引入的一个新特性，它体现了 Java 语言对简化编程模型的持续关注。

5. **示例代码**：
   ```java
   Object obj = ...;
   if (obj instanceof String _ || obj instanceof Integer _) {
       // 在这里，我们不关心具体的 String 或 Integer 值
   }
   ```

   在这个例子中，模式匹配使用了下划线 `_` 来表示开发者不关心 `String` 或 `Integer` 的具体值。

6. **与现有代码的兼容性**：尽管未命名模式和变量是一个新特性，但它设计为与现有的 Java 代码兼容，这意味着现有的代码可以在不做修改的情况下继续工作。

7. **未来发展**：随着 JDK 的发展，未命名模式和变量预计将在 JDK 的未来版本中根据开发者的反馈进行改进，并可能最终成为正式特性。

# 详细介绍 JDK 22 隐式声明类和实例主方法

在 JDK 22 中，隐式声明类和实例 `main` 方法作为一个预览特性被引入，旨在简化 Java 程序的编写，特别是在创建小型工具或快速原型时。这个特性允许开发者在不显式定义类的情况下编写 `main` 方法，从而减少样板代码并使程序入口点更加直观。

以下是 JDK 22 中隐式声明类和实例 `main` 方法的一些关键特性：

1. **简化程序入口**：开发者可以直接在源文件中编写 `main` 方法，而不需要创建一个单独的类来封装它。

2. **减少样板代码**：隐式声明类的特性避免了编写重复的类定义代码，这在处理小型程序或脚本时非常有用。

3. **易于理解和使用**：对于 Java 初学者来说，隐式声明类和 `main` 方法的引入降低了学习曲线，使得他们可以更快地开始编写简单的 Java 程序。

4. **预览特性**：作为预览特性，隐式声明类和实例 `main` 方法在 JDK 22 中引入，这意味着它还在开发中，并且可能会根据用户反馈进行改进。

5. **示例代码**：
   ```java
   public static void main(String[] args) {
       // 程序逻辑
   }
   ```
   在这个示例中，`main` 方法直接出现在源文件中，没有被包裹在一个类定义中。

6. **与现有代码的兼容性**：尽管隐式声明类和实例 `main` 方法是一个新特性，但它设计为与现有的 Java 代码兼容，这意味着现有的类定义和 `main` 方法的使用不受影响。

7. **未来发展**：随着 JDK 的发展，隐式声明类和实例 `main` 方法预计将在 JDK 的未来版本中成为正式特性，从而成为 Java 程序员在编写简单程序时的一个有用工具。

# 详细介绍 JDK 22 G1 的区域固定

JDK 22 引入了 G1 垃圾收集器的区域固定（Region Pinning）特性，这是通过 JEP 423 实现的。这项特性旨在减少垃圾回收（Garbage Collection，GC）的延迟，特别是在与 Java 本地接口（JNI）关键区域交互时。

以下是 JDK 22 中 G1 区域固定的一些关键特性：

1. **减少 GC 延迟**：通过实现区域固定，G1 垃圾收集器在 JNI 关键区域期间不需要完全禁用，从而减少了停顿时间。

2. **改善 JNI 互操作性**：JNI 关键区域是 Java 代码与非托管代码（如 C 或 C++）交互的点。在这些点上，GC 通常会被禁用以避免对象移动，这可能导致性能问题。区域固定允许在这些关键区域中安全地进行垃圾回收。

3. **内存区域固定**：G1 垃圾收集器可以固定包含关键对象的内存区域，这样即使在进行垃圾回收时，这些区域也不会被清理或移动。

4. **计数机制**：区域固定通过在每个区域中维护关键对象的计数来实现，在获取关键对象时增加计数，在释放时减少，以此来决定是否固定区域。

5. **提高性能**：这种机制确保了关键对象不会被移动，同时避免了完全禁用 GC，显著降低了延迟，提高了应用程序的性能。

6. **潜在风险**：虽然区域固定带来了性能上的改进，但也存在潜在风险，如如果应用程序同时固定多个区域，可能会导致堆内存耗尽。不过，从已经实现了类似机制的 Shenandoah GC 来看，这种风险是可控的。

7. **技术增强**：JEP 423 为 OpenJDK 的 G1 垃圾回收器引入了重大的技术增强，改进了 JVM 在与非托管语言发生互操作时的垃圾回收处理。

8. **Java 垃圾回收机制的进步**：这项新特性代表了 Java 垃圾回收机制的重大进步，解决了与 JNI 关键区域相关的延迟问题。

9. **JDK 22 的一部分**：作为 JDK 22 的一部分，区域固定特性通过减少 GC 停顿时间，提升了 Java 应用的性能，尤其是在涉及大量 JNI 交互的场景中。

# 详细介绍 JDK 22 启动多文件源代码程序

JDK 22 引入了一个新特性，允许开发者直接从命令行启动由多个 Java 源代码文件组成的程序，而无需先将它们编译成类文件。这个特性由 JEP 458 实现，它提供了一种更简单快捷的方式来运行和测试小型的 Java 程序，特别是对于教育、快速原型开发和临时脚本编写等场景。

以下是 JDK 22 中启动多文件源代码程序特性的一些关键点：

1. **简化编译过程**：开发者可以直接运行多个源文件组成的程序，无需单独编译每个文件并运行生成的类文件。

2. **提高效率**：这个特性使得从编写代码到程序运行的周期更短，特别适合快速迭代和测试。

3. **命令行支持**：通过在命令行中使用 `java` 命令，可以直接启动包含多个源文件的程序。

4. **适用场景**：这个特性特别适合小型项目和学习 Java 的初学者，因为它减少了配置构建工具的复杂性。

5. **示例代码**：
   ```shell
   java MyProgram.java OtherFile.java
   ```
   在这个例子中，`MyProgram.java` 和 `OtherFile.java` 是程序的源代码文件，可以直接通过 `java` 命令运行。

6. **与构建工具的互补**：虽然这个特性简化了小型程序的运行，但对于大型项目，构建工具如 Maven 或 Gradle 仍然是必需的。

7. **JDK 22 的一部分**：作为 JDK 22 的一部分，这个特性体现了 Java 平台对开发者体验的持续关注和改进。

8. **未来发展**：预计这个特性将在未来 Java 版本中继续存在，并可能根据开发者的反馈进行改进。


# 详细介绍 JDK 22 Markdown 文档注释

JDK 22 引入了一个新的特性，即 Markdown 文档注释，这是通过 JEP 467 实现的。这个特性建议允许 JavaDoc 文档注释以 Markdown 格式编写，而不仅仅是 HTML 和 JavaDoc `@` 标记的混合体。以下是 JDK 22 中 Markdown 文档注释的一些关键特性：

1. **易于编写和阅读**：Markdown 是一种轻量级的标记语言，它以易读易写而闻名。引入 Markdown 将使文档注释在源代码形式下更易于编写和阅读。

2. **保留现有功能**：现有的 HTML 和 JavaDoc 标记不会被弃用，Markdown 注释将作为另一种可选的方式来增强文档的可读性。

3. **兼容性**：为了向下兼容，现有的 `/** ... */` 注释语法仍然有效。新的 Markdown 注释使用 `///` 开头，以区分传统的 JavaDoc 注释。

4. **增强的链接支持**：在 Markdown 文档注释中，提供了一种扩展的 Markdown 引用链接形式，允许方便地链接到 API 中的其他元素。

5. **JavaDoc 标签支持**：JavaDoc 标签，包括内联标签如 `{@inheritDoc}` 和块标签如 `@param` 和 `@return`，都可以在 Markdown 文档注释中使用。

6. **未来工作**：JEP 467 还提到了一些未来的工作方向，比如可能将一些 Markdown 标题自动转换为相应的 JavaDoc 标签。

7. **风险和假设**：实施该特性时使用了第三方库 commonmark-java 来将 Markdown 转换为 HTML。如果该库不再维护，OpenJDK 社区可能需要维护该库的分支或寻找替代方案。

8. **语法细节**：为了处理 Markdown 中重要的空白字符，文档注释的内容会根据特定的规则进行处理，以确保 Markdown 的格式和意图被正确解析。

9. **渲染和呈现**：`javadoc` 工具将 Markdown 注释渲染为 HTML，同时保留了链接和其他 JavaDoc 功能。

10. **社区反馈**：JEP 467 是基于社区反馈和对 Java 文档实践的观察而提出的，目的是改善开发者编写和维护文档的体验。

# 详细介绍 JDK 22 类文件 API

JDK 22 引入了类文件 API（Class-File API），这是通过 JEP 457 实现的一个预览特性。这个 API 提供了一套工具，用于解析、生成和转换 Java 类文件。以下是 JDK 22 中类文件 API 的一些关键特性：

1. **预览特性**：类文件 API 在 JDK 22 中作为预览特性提供，允许开发者提前尝试这个 API，并为 JDK 的未来版本提供反馈。

2. **简化类文件操作**：该 API 旨在简化与类文件的交互，提供一种标准化和简化的方式来处理类文件。

3. **不可变对象**：类文件 API 将类文件实体（如字段、方法、属性和字节码指令）视为不可变对象，这有助于在类文件转换时可靠地进行共享。

4. **树形结构**：API 采用树形结构来反映类文件的层次结构，支持用户驱动的导航以进行高效地解析。

5. **延迟解析**：类文件 API 强调解析过程的延迟性，即只会处理满足用户需求所需的类文件，这提高了效率。

6. **模式解析**：该 API 引入了使用模式解析类文件的新方法，与基于访问者的旧方式（如 ASM 库）有所不同，支持更直接和更简洁的表达式。

7. **元素、构建器和转换**：类文件 API 包含三个主要的抽象：元素（类文件组件的不可变描述）、构建器（用于构造类文件的特定构建方法）和转换（在构建过程中修改元素的函数）。

8. **替代 ASM**：类文件 API 最初将作为 JDK 中 Java 字节码操作和分析框架 ASM 的内部替代品，并计划将其作为公共 API 开放。

9. **使用示例**：
   ```java
   ClassFile cf = ClassFile.of();
   ClassModel classModel = cf.parse(bytes);
   byte[] newBytes = cf.transform(classModel, (classBuilder, ce) -> {
       // 转换逻辑
   });
   ```
   在这个示例中，开发者可以使用类文件 API 来解析和转换类文件。

10. **未来发展**：Java 语言架构师 Brian Goetz 描述了 ASM 是一个“带有大量遗留包袱的旧代码库”，并提供了关于类文件 API 如何发展并最终取代 ASM 的背景信息。


# 参考资料

https://blogs.oracle.com/java/post/the-arrival-of-java-22


* any list
{:toc}