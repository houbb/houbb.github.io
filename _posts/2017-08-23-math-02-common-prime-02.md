---
layout: post
title:  Math-数学基础知识素数 Prime
date:  2017-8-23 10:04:34 +0800
categories: [Math]
tags: [math]
published: true
---

# 素数

质数又称素数。

一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。

# 特性

## 1. 素数的个数无限多（不存在最大的素数）

证明：反证法，假设存在最大的素数P，那么我们可以构造一个新的数2 * 3 * 5 * 7 * … * P + 1（所有的素数乘起来加1）。

显然这个数不能被任一素数整除（所有素数除它都余1），这说明我们找到了一个更大的素数。

## 2. 存在任意长的一段连续数，其中的所有数都是合数（相邻素数之间的间隔任意大）

证明：当 0 < a <= n时，n!+a能被a整除。

长度为n-1的数列n!+2, n!+3, n!+4, …, n!+n中，所有的数都是合数。

这个结论对所有大于1的整数n都成立，而n可以取到任意大。

## 3. 所有大于2的素数都可以唯一地表示成两个平方数之差。

证明：大于2的素数都是奇数。

假设这个数是2n+1。由于(n+1)^2=n^2+2n+1，(n+1)^2和n^2就是我们要找的两个平方数。

下面证明这个方案是唯一的。如果素数p能表示成a^2-b^2，则p=a^2-b^2=(a+b)(a-b)。由于p是素数，那么只可能a+b=p且a-b=1，这给出了a和b的唯一解。

## 4. 当n为大于2的整数时，2^n+1和2^n-1两个数中，如果其中一个数是素数，那么另一个数一定是合数。

证明：2^n不能被3整除。

如果它被3除余1，那么2^n-1就能被3整除；如果被3除余2，那么2^n+1就能被3整除。总之，2^n+1和2^n-1中至少有一个是合数。

## 5. 如果p是素数，a是小于p的正整数，那么a^(p-1) mod p = 1。

这个证明就有点麻烦了。

首先我们证明这样一个结论：如果p是一个素数的话，那么对任意一个小于p的正整数a，a, 2a, 3a, …, (p-1)a除以p的余数正好是一个1到p-1的排列。例如，5是素数，3, 6, 9, 12除以5的余数分别为3, 1, 4, 2，正好就是1到4这四个数。

反证法，假如结论不成立的话，那么就是说有两个小于p的正整数m和n使得na和ma除以p的余数相同。

不妨假设n>m，则p可以整除a(n-m)。但p是素数，那么a和n-m中至少有一个含有因子p。这显然是不可能的，因为a和n-m都比p小。

# 简单解法的三种方式

## 最基本的方式

最直观的方法，根据定义，因为质数除了1和本身之外没有其他约数，所以判断n是否为质数，根据定义直接判断从2到n-1是否存在n的约数即可。

C++代码如下：

```c
bool isPrime_1( int num )
{
    int tmp =num- 1;
    for(int i= 2; i <= tmp; i++)
      if(num %i== 0)
         return 0 ;
    return 1 ;
}
```

## 初步改进

上述判断方法，明显存在效率极低的问题。

对于每个数n，其实并不需要从2判断到n-1。

我们知道，一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)。

据此，上述代码中并不需要遍历到n-1，遍历到sqrt(n)即可，因为若sqrt(n)左侧找不到约数，那么右侧也一定找不到约数。

C++代码如下：

```c
bool isPrime_2( int num )
{
     int tmp =sqrt( num);
     for(int i= 2;i <=tmp; i++)
        if(num %i== 0)
          return 0 ;
     return 1 ;
}
```

## 再次改进

方法（2）应该是最常见的判断算法了，时间复杂度O(sqrt(n))，速度上比方法（1）的O(n)快得多。

最近在网上偶然看到另一种更高效的方法，暂且称为方法（3）吧，由于找不到原始的出处，这里就不贴出链接了，如果有原创者看到，烦请联系我，必定补上版权引用。

下面讲一下这种更快速的判断方法；

### 分布规律分析

首先看一个关于质数分布的规律：大于等于5的质数一定和6的倍数相邻。例如5和7，11和13,17和19等等；

证明：令x≥1，将大于等于5的自然数表示如下：

······ 6x-1，6x，6x+1，6x+2，6x+3，6x+4，6x+5，6(x+1），6(x+1)+1 ······

可以看到，不在6的倍数两侧，即6x两侧的数为6x+2，6x+3，6x+4，由于2(3x+1)，3(2x+1)，2(3x+2)，所以它们一定不是素数，再除去6x本身，显然，素数要出现只可能出现在6x的相邻两侧。

这里有个题外话，关于孪生素数，有兴趣的道友可以再另行了解一下，由于与我们主题无关，暂且跳过。

这里要注意的一点是，在6的倍数相邻两侧并不是一定就是质数。

此时判断质数可以6个为单元快进，即将方法（2）循环中i++步长加大为6，加快判断速度，

原因是，假如要判定的数为n，则n必定是6x-1或6x+1的形式，对于循环中6i-1，6i，6i+1,6i+2，6i+3，6i+4，其中如果n能被6i，6i+2，6i+4整除，则n至少得是一个偶数，但是6x-1或6x+1的形式明显是一个奇数，故不成立；

另外，如果n能被6i+3整除，则n至少能被3整除，但是6x能被3整除，故6x-1或6x+1（即n）不可能被3整除，故不成立。

综上，循环中只需要考虑6i-1和6i+1的情况，即循环的步长可以定为6，每次判断循环变量k和k+2的情况即可，理论上讲整体速度应该会是方法（2）的3倍。

### 代码

代码如下：

```c
bool isPrime_3(int num)
{
    //两个较小数另外处理
    if(num == 2 || num==3 )
         return 1;

    //不在6的倍数两侧的一定不是质数
    if(num %6!= 1&&num %6!= 5)
        return 0;

    int tmp = sqrt(num);

    //在6的倍数两侧的也可能不是质数
    for(int i= 5;i <=tmp; i+=6 )
        if(num %i== 0||num %(i+ 2)==0 )
            return 0 ;

    //排除所有，剩余的是质数
    return 1 ;
}
```

### i 的步长为什么能是 +6 

假设要判断的数为x，那么执行到for循环时，x一定为6n-1或者6n+1的形式，因为其他的形式在之前已经被排除了。 

所以x不可能被6n除尽假设x可以被6n+2除尽，那么x一定可以被2除尽，所以x一定不可能为6n-1或者6n+1的形式。 

与前提相矛盾，因此x不可以被6n+2除尽同理，x不可以被6n+3，6n+4除尽 

证毕



## 个人的优化方案

1. 在 `[3, sqrt(n))` 的范围内，所有的偶数都不是素数。

2. 结合上面 6 的步长，可以优化掉接近 一大半。

# 查表法

可以把一定范围内的所有素数存起来。

用空间换时间。

# 素数筛法

## 准备工作

素数筛法是这样的：

1. 开一个大的bool型数组prime[]，大小就是n+1就可以了.先把所有的下标为奇数的标为true,下标为偶数的标为false.

2. 然后全部初始化为 false

3. 最后输出bool数组中的值为true的单元的下标，就是所求的n以内的素数了。

## 基本原理

原理很简单，就是当i是质(素)数的时候，i的所有的倍数必然是合数。

如果i已经被判断不是质数了，那么再找到i后面的质数来把这个质数的倍数筛掉。

- 数据的重复利用

出了这样的优化以外，另外在每一次用当前已得出的素数筛选后面的数的时候可以一步跳到已经被判定不是素数的

数后面，这样就减少了大量的重复计算。（比如我们看到的，i=0与i=1时都标了[6],这个就是重复的计算。）

我们可以发现一个规律，那就是3（即i=0）是从下标为[3]的开始筛的，5（即i=1）是从下标为[11]开始筛的（因为[6]

已经被3筛过了）。然后如果n很大的话，继续筛。7（i=2）本来应该从下标为[9]开始筛，但是由于[9]被筛过了，而

[16]也已经被5（i=1）筛过了。于是7（i=2）从[23]（就是2*23+3=49）开始筛。

于是外围循环为i时，内存循环的筛法是从 i+(2*i+3)*(i+1)即i*(2*i+6)+3开始筛的。

## 示例代码

```c
#include<stdio.h>
#include<math.h>
#define N 10000001

bool prime[N];

int main()
{

   int i, j;
   for(i=2; i<N; i++)
      if(i%2) 
        prime[i]=true;
      else 
        prime[i]=false;

   for(i=3; i<=sqrt(N); i++)
   {   
        if(prime[i])
           for(j=i+i; j<N; j+=i) 
                prime[i]=false;
   }

   for(i=2; i<100; i++)//由于输出将占用太多io时间，所以只输出2-100内的素数。可以把100改为N
   if( prime[i] )printf("%d ",i);
   return 0;
}
```


# 其他算法

米勒罗宾


# 参考资料
 
[素数-百度百科](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fromtitle=%E7%B4%A0%E6%95%B0&fromid=115069&fr=aladdin)

[数论部分第一节：素数与素性测试](http://www.matrix67.com/blog/archives/234)

[C语言判断素数（求素数）（两种方法）](http://c.biancheng.net/view/498.html)

[经典的找素数算法：Sieve of Eratosthenes](https://blog.csdn.net/endurehero/article/details/82560241)

[素数判断算法(高效率）](https://blog.csdn.net/liukehua123/article/details/5482854)

[素数之美-证明](https://spaces.ac.cn/archives/2800)

[不可思议的素数（上）](https://mp.weixin.qq.com/s?__biz=MzA5ODUxOTA5Mg==&mid=2652560693&idx=1&sn=690c6ba271a7d4ee594ccbd2f0a4c946&chksm=8b7e2c6ebc09a578f6c91ce32e93a3358856db3c3f5bd26b33de0a9738f83d178a24d193bb6a&scene=21#wechat_redirect)


## 经典算法

[埃氏筛法搜寻1亿以内素数](http://fcode.cn/algorithm-144-1.html)

[筛法求素数(埃氏筛法+线性筛法+6倍数判别法)](https://blog.csdn.net/u011590573/article/details/81451542)

* any list
{:toc}

