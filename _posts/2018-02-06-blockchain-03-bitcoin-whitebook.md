---
layout: post
title:  BlockChain 03 BitCoin White Book 比特币白皮书
date:  2018-2-7 13:55:12 +0800
categories: [BlockChain]
tags: [blockchain, bit coin]
published: true
---


# 比特币白皮书

> [英文原版](https://bitcoin.org/bitcoin.pdf)

备注：本文为了不受其他文章的影响，直接使用 google 进行翻译。后面会添加个人思考。

以后有时间会结合前人的经验，完善此文的正确性和阅读性。

# 摘要

纯电子现金的对等版本将允许在线
付款直接从一方发送到另一方，而不经过一个
金融机构。数字签名提供了解决方案的一部分，但主要的
如果仍然需要一个值得信赖的第三方来防止双重开支，那么效益将会丧失。
我们提出了使用对等网络的双重支出问题的解决方案。
网络将交易时间标记为一个持续的链
基于散列的工作证明，形成无需重做就无法更改的记录
工作证明。最长的链不仅作为序列的证明
目击事件，但证明它来自最大的CPU权力池。如
只要大部分CPU功率由不合作的节点控制
攻击网络，他们将产生最长的连锁和超越攻击者。该
网络本身需要最小的结构。消息以尽力而为的广播
节点可以随意离开和重新加入网络，接受时间最长
证明工作链，以证明他们离开后发生的事情。

# 介绍

互联网上的商业几乎完全依赖于金融机构
值得信赖的第三方来处理电子支付。虽然系统运行良好
大多数交易仍然存在着信任模式固有的弱点。
完全不可逆的交易是不可能的，因为金融机构不能
避免调解纠纷。调解的成本增加了交易成本，限制了
最小的实际交易规模和切断小型临时交易的可能性，
并且在不可逆转的支付能力丧失方面存在更广泛的成本
服务。随着逆转的可能性，对信任的需求蔓延。商家必须
警惕他们的顾客，为他们争取更多的信息，而不是他们所需要的。
一定比例的欺诈被认为是不可避免的。这些成本和支付不确定性
可以通过使用实物货币来亲自回避，但没有任何机制可以支付
通过没有信任方的通信渠道。
所需要的是基于密码证明而不是信任的电子支付系统，
允许任何两个自愿的双方直接相互处理，而不需要一个可信任的
第三方。在计算上不可逆转的交易将保护卖家
从欺诈和常规托管机制可以很容易地实施，以保护买家。在
本文提出了一种使用点对点分布式的双重支出问题的解决方案
时间戳服务器来生成交易的时间顺序的计算证明。该
系统是安全的，只要诚实的节点集体控制比任何更多的CPU电源
协作攻击者节点组。

# Transactions

我们将电子硬币定义为数字签名链。 每个所有者将硬币转移到
接下来通过数字签名前一个交易的散列和下一个所有者的公钥
并将其添加到硬币的末端。 收款人可以验证签名来验证链
所有权。

![20180207-bitcoin-whitebook-transaction.jpg](https://raw.githubusercontent.com/houbb/resource/master/img/blockchain/20180207-bitcoin-whitebook-transaction.jpg)

当然问题是收款人无法验证其中一个所有者没有双重支出
硬币。一个常见的解决办法是引入一个值得信赖的中央权威机构，
交易双倍​​开支。每次交易后，必须将硬币退还给薄荷
发行新的硬币，只有从薄荷直接发行的硬币是可信的，而不是双重花费。
这个解决方案的问题是，整个货币体系的命运取决于
公司正在运行薄荷，每一笔交易都要经过它们，就像银行一样。
我们需要一种方法让收款人知道以前的所有者没有早点签名
交易。就我们的目的而言，最早的交易是重要的交易，所以我们不在乎
关于稍后尝试双重花费。确认没有交易的唯一方法是
了解所有交易。在基于薄荷的模型中，薄荷意识到所有的交易和
决定哪一个到达。为了完成这个没有信任的一方，交易必须是
公开宣布，我们需要一个系统让参与者就一个单一的历史记录达成一致
接收的顺序。收款人需要证明，在每次交易时，
大部分节点同意这是第一次收到。

# 时间戳服务器

我们建议的解决方案从时间戳服务器开始。 一个时间戳服务器通过一个
散列项目的时间戳，并广泛发布散列，如在一个
报纸或Usenet帖子。 时间戳证明数据必须存在于
显然，时间是为了进入哈希。 每个时间戳都包含之前的时间戳
它的散列，形成一个链，每个附加的时间戳加强之前。

![20180207-bitcoin-whitebook-timeserver.jpg](https://raw.githubusercontent.com/houbb/resource/master/img/blockchain/20180207-bitcoin-whitebook-timeserver.jpg)

# 验证的工作

为了在点对点基础上实现分布式时间戳服务器，我们将需要使用证明 - 
这个系统类似于Adam Back的Hashcash，而不是报纸或Usenet帖子。
工作证明涉及扫描散列的值，例如SHA-256
哈希以零位开始。 所需的平均工作数量是指数
需要零位，并且可以通过执行单个散列来验证。
对于我们的时间戳网络，我们通过增加一个随机数来实现工作的证明
直到找到一个给块的散列值所需的零位的值。 一旦CPU
已经花费了努力使其满足工作的证明，块不能改变
无需重做工作。 后来的块被链接后，改变块的工作
将包括重做之后的所有块。

![20180207-bitcoin-whitebook-proof-of-work.jpg](https://raw.githubusercontent.com/houbb/resource/master/img/blockchain/20180207-bitcoin-whitebook-proof-of-work.jpg)

工作证明也解决了在多数决定中确定代表性的问题
制造。如果大多数是基于一个IP地址一票的话，那么任何人都可以破坏它
能够分配许多IP。工作证明本质上是一个CPU一票。大多数
决策是由最长的连锁代表的，这是最大的工作量证明
在里面。如果大部分的CPU能力是由诚实的节点来控制的话，诚实的链条就会增长
最快和超过任何竞争链。要修改过去的块，攻击者将不得不
重做之后的所有街区的工程证明，然后赶上并超越
诚实节点的工作。稍后我们会展示一个较慢攻击者追赶的概率
随着随后的块被添加，指数性地减小。
为了补偿硬件速度的增加和随着时间的推移对运行节点的不同兴趣，
工作证明的难度取决于平均移动平均数
块每小时。如果产生得太快，难度就会增加

# 网络

运行网络的步骤如下：

1）新交易广播给所有节点。

2）每个节点收集新的交易到一个块。

3）每个节点的工作是找到一个困难的块证明。

4）当一个节点发现工作证明时，它将该块广播给所有节点。

5）只有在节点中的所有事务都有效且尚未使用的情况下，节点才接受该节点。

6）节点通过创建下一个块来表达他们对块的接受链，使用接受块的散列作为前面的散列。


节点总是认为最长的链是正确的，并将继续工作
扩展它。 如果两个节点同时广播下一个块的不同版本，则会有一些
节点可以先接收一个或另一个。 在这种情况下，他们在收到的第一个工作，
但保存其他分支，以防变长。 当下一个证据被打破时，领带将被打破，
找到工作，一个分支变长; 在另一个上工作的节点
分支会切换到较长的分支。

新的交易广播不一定需要到达所有的节点。 只要他们到达
很多节点，他们不久就会进入一个块。 块广播也容忍掉线
消息。 如果一个节点没有收到一个块，它会在收到下一个块时请求它
意识到错过了一个。


# 激励

按照惯例，块中的第一笔交易是一个特殊的交易，开始一个新的硬币
由该块的创建者。这增加了激励节点支持网络，并提供
一种最初分配硬币的方式，因为没有中央机构来发行它们。
不断增加的一定数量的新币与黄金矿工消费相似
资源为流通添加黄金。在我们的情况下，这是CPU时间和电力消耗。
激励也可以用交易费来支付。如果交易的输出值是
小于其投入价值，差额就是交易费用加上的激励价值
包含交易的块。一旦预定数量的硬币已经进入
流通，激励可以完全转移到交易费用，完全通货膨胀
自由。
激励可能有助于鼓励节点保持诚实。如果一个贪婪的攻击者能够
比所有诚实的节点组装更多的CPU功率，他将不得不选择使用它
通过窃取他的付款来欺诈人们，或者用它来生成新的硬币。他应该
发现按照规则玩耍更有利可图，这种规则比较喜欢用更多的新硬币
其他人结合在一起，而不是破坏制度和他自己的财富的有效性。


# 回收磁盘空间

一旦硬币中的最新交易被埋没在足够的区块之下，之前的交易已经花费了
它可以被丢弃以节省磁盘空间。 为了在不破坏块的散列的情况下实现这一点，
事务在Merkle树中被散列，只有块包含在块的哈希中。
然后可以通过树枝上的树枝来压实旧的木块。 内部哈希则不需要存储。

![20180207-bitcoin-whitebook-remaining-disk.jpg](https://raw.githubusercontent.com/houbb/resource/master/img/blockchain/20180207-bitcoin-whitebook-remaining-disk.jpg)

一个没有事务的块头大概是80个字节。 如果我们假设块是
每10分钟产生一次，每年 `80字节* 6 * 24 * 365 = 4.2MB`。 
与计算机系统通常在2008年以2GB内存销售，摩尔定律预测目前的增长速度
每年1.2GB，即使块头必须保存，存储也不应该成为问题记忆。

# 简化付款验证

可以在不运行完整网络节点的情况下验证付款。 用户只需要保留
最长的工作证明链的块标题副本，他可以通过查询获得
网络节点，直到他确信他拥有最长的链条，并获得Merkle分支
将交易链接到时间戳中的块。他无法检查交易
他自己，但通过链接到链中的一个地方，他可以看到一个网络节点已经接受它，
并在进一步确认网络已经接受之后添加块。

![20180207-bitcoin-whitebook-simple-pay-verify.jpg](https://raw.githubusercontent.com/houbb/resource/master/img/blockchain/20180207-bitcoin-whitebook-simple-pay-verify.jpg)

因此，只要诚实的节点控制网络，验证是可靠的，但更多
如果网络被攻击者威胁的话，这个漏洞很容易被攻破。 网络节点可以验证
交易为自己，简化的方法可以被黑客捏造
交易只要攻击者能够继续压制网络。 一个策略
防止这种情况是在网络节点检测到无效时接受警报
阻止，提示用户的软件下载完整的块并提醒交易
确认不一致。 接受频繁付款的企业可能仍然希望
运行自己的节点以获得更加独立的安全性和更快的验证。

# 合并与分裂的价值

虽然单独处理硬币是可能的，但要做到这一点还是不容易的
单独交易每分一转。 为了让价值被分割和合并，
交易包含多个输入和输出。 通常会有一个单一的输入
从较大的以前交易或多个输入组合较小的数额，最多两个
输出：一个用于付款，另一个用于将更改（如果有）返还给发件人。

![20180207-bitcoin-whitebook-combining-and-spliting-value.jpg](https://raw.githubusercontent.com/houbb/resource/master/img/blockchain/20180207-bitcoin-whitebook-combining-and-spliting-value.jpg)

应该指出，扇出，交易取决于几个交易，这些
交易依赖更多，这里不是问题。 从来没有必要提取一个
完整的交易记录的独立副本。

# 隐私

传统的银行业务模式通过限制信息的获取来实现一定程度的隐私
有关各方和值得信赖的第三方。 公开公布所有交易的必要性
排除了这种方法，但隐私仍然可以通过打破信息流来维持
另一个地方：通过保持公钥匿名。 公众可以看到有人在发送
一个金额给其他人，但没有将交易连接到任何人的信息。 这是
类似于证券交易所发布的信息的时间和大小
个别行业，“磁带”，是公开的，但没有告知谁是当事人。

![20180207-bitcoin-whitebook-privacy.jpg](https://raw.githubusercontent.com/houbb/resource/master/img/blockchain/20180207-bitcoin-whitebook-privacy.jpg)

作为附加的防火墙，每个事务都应该使用一个新的密钥对来保存它们
从被链接到共同的所有者。 多点输入仍然是不可避免的
交易，必然显示他们的投入是由同一个所有者拥有。 风险
是如果一个密钥的所有者被揭示，链接可以揭示属于其他交易
同一个所有者。

# 计算

我们认为一个攻击者试图比老实验更快地产生一个替代链
链。即使这样做完成，也不会使系统对任意改变开放，例如
作为凭空创造价值或者从不属于攻击者的金钱。节点是
不会接受无效的交易作为付款，诚实的节点永远不会接受一个块
包含它们。攻击者只能尝试改变他自己的一个交易来收回
他最近花了钱。
诚实链和攻击者链之间的竞争可以被定性为二项式
随机游走。成功事件是诚实的链条延伸了一个街区，增加了
导致+1，而失败事件是攻击者的链延伸一个块，减少了
差距由-1。
攻击者从给定的赤字追赶的概率类似于赌徒的概率
废墟问题。假设一个无限制的信用的赌徒从赤字开始并且扮演潜在的一个
尝试达到盈亏平衡的无数尝试。我们可以计算他曾经的可能性
达到盈亏平衡，或攻击者追赶诚实的链条，如下：

```
p = 诚实的节点找到下一个块的概率
q = 攻击者找到下一个块的概率
qz = 攻击者将从后面的z块追上的概率
```

转换成c代码：

```c++
#include<math.h> 
doubleAttackerSuccessProbability(double q, int z){
      double p= 1.0 - q;
      doublelambda = z * (q / p);
      doublesum = 1.0;
      int i, k;
      for (k =0; k <= z; k++)
      {
             doublepoisson = exp(-lambda);
             for (i = 1; i <= k; i++) 
                   poisson *= lambda / i; 
                   sum -= poisson * (1 - pow(q / p, z - k));
      }    
      return sum; 
}
```

运行得到结果，我们可以看到概率随z的指数下降。

```
q=0.1

z=0 P=1.0000000

z=1 P=0.2045873

z=2 P=0.0509779

z=3 P=0.0131722

z=4 P=0.0034552

z=5 P=0.0009137

z=6 P=0.0002428

z=7 P=0.0000647

z=8 P=0.0000173

z=9 P=0.0000046

z=10 P=0.0000012

q=0.3

z=0 P=1.0000000

z=5 P=0.1773523

z=10 P=0.0416605

z=15 P=0.0101008

z=20 P=0.0024804

z=25 P=0.0006132

z=30 P=0.0001522

z=35 P=0.0000379

z=40 P=0.0000095

z=45 P=0.0000024

z=50 P=0.0000006
```

求解令P<0.1%的z值：

```
P <0.001

q=0.10 z=5

q=0.15 z=8

q=0.20 z=11

q=0.25 z=15

q=0.30 z=24

q=0.35 z=41

q=0.40 z=89

q=0.45 z=340
```

可见，等**6个区块**是绝对稳妥的方法。


# 总结

我们提出了一个不依靠信任的电子交易系统。我们开始
通常由数字签名制成的硬币框架，它提供了强有力的控制
所有权，但没有办法防止双重开支是不完整的。为了解决这个问题，我们
提出了一个使用工作证明记录公共交易历史的对等网络
对于攻击者来说，如果真诚的节点变化，这对于计算上的快速变得不切实际
控制大部分CPU的功率。该网络非结构化的简单健壮。节点
一点点协调一下工作。他们不需要被识别，因为信息是
没有路由到任何特定的地方，只需要以尽力而为的方式交付。节点可以
离开并重新加入网络，接受工作证明链作为证据
他们走后发生了。他们用CPU的力量投票，表示接受
通过努力扩展它们并通过拒绝工作来拒绝无效块
他们。任何需要的规则和激励都可以通过这个共识机制来实施。


* any list
{:toc}