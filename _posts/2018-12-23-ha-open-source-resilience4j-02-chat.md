---
layout: post
title: 高可用开源库之 Resilience4j-02-chat 聊一聊
date: 2018-12-23 13:55:13 +0800
categories: [Distributed]
tags: [distributed, sh]
published: true
---

# chat

## 详细介绍一下 Resilience4j what?

Resilience4j 是一个用于 Java 的容错库，它提供了一系列机制来增强应用程序的弹性，以应对故障和瞬时问题。

Resilience4j 的设计灵活，易于集成，适用于微服务架构。

以下是 Resilience4j 的一些主要特性和组件：

### 主要特性

1. **轻量级**：Resilience4j 采用 Java 8+ 的功能，特别是函数式编程特性，使其更加轻量和灵活。

2. **无依赖**：Resilience4j 是一个单一的库，不依赖于其他库，这使得集成更简单。

3. **灵活的配置**：支持通过 Spring 配置、YAML 文件等方式进行灵活配置。

### 主要组件

1. **断路器（Circuit Breaker）**：
   - 用于监控服务调用的失败率，并在达到某个阈值后打开断路器，阻止进一步的调用，以避免对后端服务的过载。
   - 提供恢复机制，在一定时间后自动尝试恢复调用。

2. **重试（Retry）**：
   - 自动重试失败的操作，支持设置重试次数和延迟。
   - 可以与断路器结合使用，增强调用的成功率。

3. **限流（Rate Limiter）**：
   - 限制单位时间内的请求次数，防止服务被过载。
   - 可以按用户、IP 或其他维度进行限流。

4. **隔离器（Bulkhead）**：
   - 通过将服务分割为多个隔离的部分，防止某一部分的故障影响到整个系统。
   - 可用于限制资源（如线程池）的使用。

5. **缓存（Cache）**：
   - 提供缓存机制来存储结果，以减少重复的计算和网络调用。

### 使用示例

在 Spring Boot 应用中集成 Resilience4j 非常简单，通常需要添加相应的依赖：

```xml
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot2</artifactId>
    <version>1.7.1</version>
</dependency>
```

然后，可以在配置文件中配置断路器、重试等：

```yaml
resilience4j.circuitbreaker:
  instances:
    serviceA:
      failureRateThreshold: 50
      waitDurationInOpenState: 10000
```

在代码中使用：

```java
@CircuitBreaker(name = "serviceA")
public String callServiceA() {
    // 调用外部服务
}
```

### 总结

Resilience4j 是一个强大的工具，可以帮助开发人员在微服务架构中实现高可用性和弹性。

通过合理配置和组合各个组件，开发人员可以有效应对各种故障场景，提高系统的可靠性。

## 为什么需要 Resilience4j? 解决了什么问题？ why

需要 **Resilience4j** 主要是为了应对**分布式系统**中的不确定性和故障问题，尤其是在微服务架构中，这些问题更加显著。Resilience4j 解决了许多常见的分布式系统中的问题，使系统能够在面对服务故障、延迟、过载等情况时具有更高的**弹性（resilience）**和**容错能力**。以下是它解决的一些关键问题：

### 1. **短暂故障和间歇性故障**
在分布式系统中，网络问题、服务重启、资源竞争等问题会导致短暂的故障。这种情况下，直接放弃请求可能会导致用户体验下降。**Resilience4j** 提供了 `重试（Retry）` 机制，当出现短暂故障时，自动进行一系列重试操作，有效提高成功率。

**问题解决：**  
- 自动化重试，减少偶发性故障的影响。

### 2. **雪崩效应**
当某个服务处于不稳定状态或性能下降时，如果没有限制，其他服务会不断发起请求，进一步加重故障服务的负担，最终导致整个系统崩溃。这种情况被称为**雪崩效应**。**Resilience4j** 的 `断路器（Circuit Breaker）` 组件，通过监控服务的失败率，当达到一定阈值时，自动中断请求，避免故障扩散，并给系统足够的时间恢复。

**问题解决：**
- 防止故障服务的过载，保护系统其他部分，避免连锁反应导致系统整体崩溃。

### 3. **资源枯竭**
在分布式系统中，不同的服务可能使用相同的资源（如线程池、数据库连接等）。如果一个服务耗尽了资源，可能会导致整个系统崩溃。`隔离器（Bulkhead）` 组件允许对不同服务使用不同的资源池或隔离的资源，防止单个服务消耗过多资源。

**问题解决：**
- 通过资源隔离，防止一个服务的故障影响整个系统的可用性。

### 4. **限流保护**
当某个服务突然遭遇大量请求（例如瞬间的流量激增或DDoS攻击），该服务可能因负载过重而无法正常工作。Resilience4j 的 `限流器（Rate Limiter）` 可以通过限制每秒请求数，来保护服务免受过载。

**问题解决：**
- 防止服务过载，确保系统在高并发场景下的稳定性。

### 5. **缓存与重复请求**
在一些高频调用或计算密集型操作场景下，重复的请求会增加服务器的负担。Resilience4j 提供的 `缓存（Cache）` 组件允许对结果进行缓存，避免对相同数据的重复计算或请求。

**问题解决：**
- 减少不必要的重复请求，提升系统性能。

### 6. **失败后的恢复与退化**
有时候，某些服务即使失败了，也可以通过一些退化方案（降级）继续提供服务。Resilience4j 支持设置 `后备机制（Fallback）`，在主服务调用失败时，可以执行预定义的降级策略，例如返回默认值或调用备用服务。

**问题解决：**
- 提供退化方案，防止服务完全不可用，提升系统的鲁棒性。

### 7. **降低延迟与超时**
微服务之间的调用存在不确定性，可能会因为网络延迟、服务拥堵等问题导致响应时间过长。通过 `超时（Timeout）` 机制，Resilience4j 可以在指定时间内没有响应时，及时终止调用，避免长时间等待。

**问题解决：**
- 通过设置超时，防止长时间等待卡住系统，提升整体响应性。

### 为什么选择 Resilience4j？

**1. 专为 Java 8+ 设计**：它充分利用了 Java 8 的函数式编程特性，具有轻量级和无依赖的优势，相比于 Hystrix，它更适合现代的 Java 应用。

**2. 更灵活的配置**：Resilience4j 的各个组件可以独立使用，开发者可以按需组合不同的容错机制，灵活性更高。

**3. 性能优势**：Resilience4j 相比于之前的 Hystrix 更轻量，而且性能表现更优，适用于对性能敏感的微服务系统。

### 总结

Resilience4j 解决了微服务架构中常见的**短暂故障、服务过载、雪崩效应、资源枯竭**等问题，并提供了**断路器、重试、限流、隔离**等关键机制。通过这些容错机制，可以显著提高系统的弹性和稳定性，使其在面对不确定性时表现更为可靠。

## Resilience4j 的优缺点? 什么场景适合使用？where/when

### Resilience4j 的优缺点

#### 优点：

1. **轻量级**：
   - Resilience4j 是为 Java 8+ 设计的轻量级库，不需要其他依赖。相比于类似的容错库（如 Netflix 的 Hystrix），Resilience4j 更加精简，性能开销较小。

2. **模块化**：
   - Resilience4j 的各个组件（如断路器、重试、限流、隔离等）是独立的，可以按需使用，而无需引入整个框架。这使得它灵活性更高。

3. **函数式编程支持**：
   - Resilience4j 利用了 Java 8 的函数式编程特性，使得编写和配置更加简洁、现代。例如，它支持 `Supplier`、`Function`、`Runnable` 等标准 Java 函数接口，非常符合现代 Java 编程风格。

4. **与 Spring Boot 集成良好**：
   - Resilience4j 可以通过 Spring Boot 的自动配置与 Spring 应用无缝集成，支持通过注解（如 `@CircuitBreaker`、`@Retry`）的方式来配置和管理。

5. **性能更高**：
   - 相比 Hystrix，Resilience4j 的性能表现更好。Hystrix 通过线程池隔离执行服务调用，而 Resilience4j 通过信号量隔离和更轻量级的执行模型，减少了开销。

6. **更多的配置选项**：
   - Resilience4j 提供了丰富的配置选项，包括多种恢复策略、限流策略、断路器状态等，可以更精细地控制服务的容错行为。

#### 缺点：

1. **复杂度上升**：
   - 在复杂系统中，如果大量使用 Resilience4j 的不同组件，可能会导致配置和管理的复杂度上升。尤其是处理断路器、重试、限流等多种机制组合时，调优和监控变得困难。

2. **学习曲线**：
   - 虽然 Resilience4j 轻量，但对于初次接触容错机制的开发者来说，需要花费时间去理解其内部工作原理及其各组件的组合使用。

3. **缺少仪表板支持**：
   - 与 Hystrix 提供的实时监控仪表板相比，Resilience4j 默认不带有可视化的监控工具，需要开发者通过 Actuator、Micrometer 等工具进行额外的监控配置。

4. **线程池隔离支持不足**：
   - Resilience4j 默认不支持线程池隔离机制（像 Hystrix 那样），而是使用信号量隔离。这在某些场景下可能不足以应对需要强隔离的系统。

### 使用场景

Resilience4j 适用于需要**高可用性**和**容错性**的分布式系统，特别是在微服务架构中，以下是一些典型的使用场景：

#### 1. **微服务间的调用保护**
   - 当系统中某个微服务出现故障或响应延迟时，使用 `断路器（Circuit Breaker）` 可以防止大量无效请求继续触发，减轻下游服务的负担，并提高系统的健壮性。
   
   **场景**：微服务 A 调用微服务 B，B 出现故障或性能瓶颈，A 通过断路器中断请求，保护自己不被影响。

#### 2. **处理不稳定的外部依赖**
   - 在与外部 API 或服务集成时，通常会遇到服务不稳定或超时的问题。使用 `重试（Retry）` 和 `超时（Timeout）` 机制可以在一定程度上避免这种情况，提高请求成功率。

   **场景**：你的系统依赖第三方 API，可能会偶尔失败或者响应延迟。Resilience4j 的重试机制可以自动重试失败的请求。

#### 3. **高并发请求的流量控制**
   - 当系统面对瞬间流量激增时，使用 `限流器（Rate Limiter）` 控制单位时间内的请求数量，避免系统资源被耗尽或服务过载。

   **场景**：某服务面对突发的流量高峰，为了避免资源被过度消耗，可以通过限流器限制请求数，确保系统在高并发情况下保持稳定。

#### 4. **保护共享资源**
   - 在处理数据库连接、线程池等有限资源时，可以使用 `隔离器（Bulkhead）` 将不同服务的资源隔离开，防止某个服务资源耗尽时影响其他服务。

   **场景**：多个微服务共用数据库连接池或线程池。通过 Bulkhead 可以对这些资源进行隔离，防止某个服务的高负载影响其他服务的正常运行。

#### 5. **服务降级（Fallback）**
   - 在不可避免的故障情况下，Resilience4j 支持定义 `Fallback` 机制，即在调用失败时返回默认的降级值或备用响应，确保系统能够以某种方式继续提供服务。

   **场景**：当微服务调用下游服务失败时，可以返回缓存结果、默认响应或其他替代方案，避免直接报错。

#### 6. **优化计算密集型任务**
   - 对于需要重复计算或调用相同外部服务的操作，使用 Resilience4j 的 `缓存（Cache）` 组件，可以减少系统负担，提升响应速度。

   **场景**：频繁调用某些需要较高计算资源的服务或执行同样的数据库查询，通过缓存组件减少重复计算的开销。

### 总结

**Resilience4j** 是一个适合现代 Java 应用的轻量级容错库，特别是在微服务架构中，它的灵活性和强大的功能使其非常适用于分布式系统的弹性管理。

然而，开发者需要根据实际场景仔细选择和配置各个组件，以确保性能和复杂性之间的平衡。

## 如何优雅的使用 Resilience4j？最佳实践？how

为了优雅地使用 Resilience4j 并最大化其效益，以下是一些最佳实践，帮助你在开发过程中实现系统的高可用性、健壮性和可维护性。

### 1. **按需选择和组合组件**
Resilience4j 提供了多种容错机制，包括**断路器（Circuit Breaker）**、**重试（Retry）**、**限流（Rate Limiter）**、**隔离器（Bulkhead）**等。不要盲目引入所有组件，而是根据你的系统的实际需求和场景按需组合。

#### 实践建议：
- **断路器**：适合保护调用频繁但不稳定的下游服务。
- **重试机制**：适合短暂失败或网络抖动的场景，但要谨慎配置，避免引入更多负载。
- **限流**：应对高并发和流量激增的保护措施。
- **隔离器**：适合保护有限资源（如线程池、数据库连接池）。

```java
// 使用断路器和重试结合
@CircuitBreaker(name = "backendA")
@Retry(name = "backendA")
public String callBackendA() {
    // 调用外部服务
}
```

### 2. **合理配置阈值**
每个 Resilience4j 组件都依赖阈值（如断路器失败率、重试次数、限流速率等）。合理的阈值设置是确保系统稳定性和高效运行的关键。

#### 实践建议：
- **断路器**：设置一个合适的**失败率阈值**（如 50%），和合理的**开关时间间隔**。避免断路器过于敏感或不敏感。
- **重试**：限制重试的次数，并引入**指数退避**或**固定间隔退避**策略，避免对不稳定的下游服务造成额外压力。
- **限流**：根据系统负载和瓶颈设置合理的速率限制（如每秒允许的最大请求数）。
  
```yaml
resilience4j.circuitbreaker:
  instances:
    serviceA:
      failureRateThreshold: 50
      waitDurationInOpenState: 10000
      ringBufferSizeInClosedState: 10

resilience4j.retry:
  instances:
    serviceA:
      maxAttempts: 3
      waitDuration: 1000  # 指数退避
```

### 3. **引入超时机制**
超时机制是防止下游服务响应过慢导致资源被长时间占用的关键措施。**超时（Timeout）**机制可以确保在一定时间内服务未响应时自动中断调用。

#### 实践建议：
- 对每个外部服务调用设置一个合理的超时，防止长时间阻塞系统线程。
  
```java
@TimeLimiter(name = "backendA")
@CircuitBreaker(name = "backendA")
public CompletableFuture<String> callBackendA() {
    return CompletableFuture.supplyAsync(() -> {
        // 调用外部服务
    });
}
```

### 4. **使用 Fallback 机制处理失败**
为关键路径或重要服务设置**回退（Fallback）**策略，确保在服务不可用时提供备用方案，防止系统完全不可用。

#### 实践建议：
- 定义合理的降级策略，可以返回缓存数据、默认值或简化的响应。确保即使调用失败，用户体验依然保持在可接受范围内。

```java
@CircuitBreaker(name = "backendA", fallbackMethod = "fallbackBackendA")
public String callBackendA() {
    // 调用外部服务
}

public String fallbackBackendA(Throwable t) {
    return "Default response";  // 回退策略
}
```

### 5. **监控和度量**
Resilience4j 提供了与 Micrometer 集成的功能，可以将运行时的断路器状态、重试次数、限流等指标暴露给监控系统。监控是确保 Resilience4j 正常工作的基础。

#### 实践建议：
- 使用 Micrometer 将度量数据发送到监控系统（如 Prometheus），从而实时跟踪和分析系统的容错机制是否按预期运行。
- 定期查看这些监控数据，调整配置，优化性能。

```java
@Bean
public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
    return registry -> registry.config().commonTags("application", "your-app-name");
}
```

### 6. **避免滥用重试机制**
重试机制是 Resilience4j 中常用的功能，但过多的重试可能会增加系统负担，尤其是在服务已经高负载或不可用的情况下。适当的重试机制应与**断路器**结合使用，并避免同时对多个服务进行多层次的重试。

#### 实践建议：
- 设置合理的最大重试次数（如 3 次），避免无限重试。
- 在重试间隔中引入**退避策略**（如指数退避），避免频繁的重试请求加重下游服务的负担。

```yaml
resilience4j.retry:
  instances:
    serviceA:
      maxAttempts: 3
      waitDuration: 1000ms
      exponentialBackoffMultiplier: 2.0
```

### 7. **隔离关键服务**
关键服务调用应与非关键服务调用隔离开来，以防止资源竞争和影响。在使用 Resilience4j 的**隔离器（Bulkhead）**时，确保关键服务有足够的隔离资源。

#### 实践建议：
- 针对关键服务设置**线程池隔离**或**信号量隔离**，为它们预留独立的资源，避免高负载下相互影响。

```java
@Bulkhead(name = "backendA", type = Bulkhead.Type.SEMAPHORE)
public String callBackendA() {
    // 调用外部服务
}
```

### 8. **做好限流保护**
对于一些可能受到突发流量冲击的服务，可以通过 Resilience4j 的**限流器（Rate Limiter）**来保护它们，避免因短期流量高峰导致服务不可用。

#### 实践建议：
- 设置合理的速率限制，平滑地处理瞬时高并发请求。
- 将限流器与缓存、回退策略等结合使用，提升系统的弹性。

```yaml
resilience4j.ratelimiter:
  instances:
    serviceA:
      limitForPeriod: 10
      limitRefreshPeriod: 1s
```

### 9. **优化配置文件管理**
随着系统规模的增加，Resilience4j 的配置也可能变得复杂。使用**集中化管理**或**分层管理**（如按环境或服务模块）来维护 Resilience4j 的配置。

#### 实践建议：
- 使用 Spring Cloud Config 或其他配置中心管理系统，确保配置文件的灵活管理和动态更新。
- 按照环境（如开发、测试、生产）分别配置不同的 Resilience4j 策略。

### 10. **结合业务逻辑优化**
Resilience4j 的配置应根据实际的业务逻辑和性能需求优化，而不是一味追求高容错。对于不同的业务场景，不同的策略应灵活调整。

#### 实践建议：
- 对于高优先级、关键的业务请求，可能需要设置较低的断路器阈值和严格的限流。
- 对于非关键业务，如日志记录或非实时分析，可以设置较高的容错能力，甚至允许更多的失败请求。

### 总结

要优雅地使用 **Resilience4j**，需要合理地选择和组合组件，配置好容错机制，保持性能监控，同时结合业务需求动态调整配置。

通过这些最佳实践，你可以打造出高弹性、健壮且可维护的分布式系统，从而提升系统的稳定性与可用性。

* any list
{:toc}