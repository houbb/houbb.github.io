---
layout: post
title: leetcode 数组专题之数组遍历-01-遍历 T1089 复写零
date:  2020-6-8 15:13:08 +0800
categories: [Algorithm]
tags: [algorithm, data-struct, topics, leetcode, array, traverse, sf]
published: true
---


# 数组

大家好，我是老马。

今天我们一起来学习一下数组这种数据结构。

## 主要知识

数组需要拆分下面几个部分：

1. 理论介绍

2. 源码分析

3. 数据结构实现？

4. 题目练习（按照算法思想分类）

5. 梳理对应的 sdk 包

6. 应用实战

因为这个是 leetcode 系列，所以重点是 4、5(对4再一次总结)。

为了照顾没有基础的小伙伴，会简单介绍一下1的基础理论。

简单介绍1，重点为4。其他不是本系列的重点。


# T1089 复写零


给你一个长度固定的整数数组 arr ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。

注意：请不要在超过该数组长度的位置写入元素。请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。

示例 1：

输入：arr = [1,0,2,3,0,4,5,0]
输出：[1,0,0,2,3,0,0,4]
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]


示例 2：

输入：arr = [1,2,3]
输出：[1,2,3]
解释：调用函数后，输入的数组将被修改为：[1,2,3]
 

提示：

1 <= arr.length <= 104
0 <= arr[i] <= 9

# v1-暴力方式

## 思路

就是最朴素的符合题目意思的解法，没有任何技巧。

## 解法

```java
    public void duplicateZeros(int[] arr) {
        int n = arr.length;
        for(int i = 0; i < n; i++) {
            if(arr[i] == 0) {
                // 当前位置后面的全部往后移动一个位置
                for(int j = n-1; j >= i+1; j--) {
                    arr[j] = arr[j-1];
                }
                // 下一个位置插入0
                i++;
                if(i >= n) {
                    return;
                }
                arr[i] = 0;
            }
            
            // 提前结束
            if(i >= n) {
                return;
            }
        }
    }
```


## 效果

17ms 击败 6.70%

竟然 AC 了，大概这就是 easy 的理由。

# v2-空间换时间

## 思路

虽然这一题要求原地排序，不过我们用这个方法用来作为双指针的过渡。

left 对应 temp 数字下标。

right 对应原始的下标。

我们可以用 left right 两个指针，遇到 0 就往 left 多加一个0。

如果 left 长度和以前一样，结束。

## 实现

```java
    public void duplicateZeros(int[] arr) {
        int n = arr.length;
        int left = 0;
        int right = 0;

        // 临时数组
        int[] temp = new int[n];
        for(right = 0; right < n; right++) {
            temp[left++] = arr[right];
            // 提前结束
            if(left >= n) {
                break;
            }

            // 处理0
            if(arr[right] == 0) {
                temp[left++] = 0;
                if(left >= n) {
                    break;
                }
            }
        }
        
        // copy
        System.arraycopy(temp, 0, arr, 0, n);
    }
```

## 效果

0ms 100%

## 反思

当然，这种方法我们开辟了新的空间，实际上是不符合题意的。

这就是题目设计的不够开放的问题，可以把原地当做一个额外的限制条件。而不是上来就限定死。

# v3-双指针

## 思路

其实这一题是比较难的，双指针拐了2次弯儿，一般人10分钟内估计根本想不到。

就算想到了用 left、right 两个指针移动，类似于 T26 T27，但是会发现，因为要复写 0，会导致后面的数字被覆盖，这个和移除是不同的。

那么，怎么解决呢？

## 逆流而上

最核心的问题在于直接 0 复制，会导致后面的信息被覆盖。

所以我们最好是从后往前操作。

自然地，我们可以想到快慢指针，先找到结束的位置。然后倒过来处理一遍。

不过做的时候发现好多坑...

## 实现

todo...

```java

```






## 反思

双指针适用性更强，值得深刻记忆。

----------------------------------------------------------------

# 数组基本知识+技巧

| 分类      | 代表技巧              |
| ------- | ----------------- |
| 遍历类     | 遍历、双指针、滑窗         |
| 前缀/差分类  | 前缀和、差分、后缀数组       |
| 查找类     | 二分、哈希、离散化         |
| 空间/状态优化 | 状压、滚动数组、差分压缩      |
| 排序/归并类  | 排序、归并逆序对、树状数组、线段树 |
| 子数组/序列  | 动规、中心扩展、单调栈       |
| 矩阵类     | 二维差分、DFS/BFS、旋转模拟 |
| 特殊技巧    | 快速幂、滚动哈希、模拟题技巧    |

## 🎯 常见遍历技巧 + 力扣题目对照表

| 技巧    | 力扣题目         | 说明       |
| ----- | ------------ | -------- |
| 基础遍历  | 27.移除元素      | 直接遍历+判断  |
| 快慢指针  | 26. 删除重复项    | 原地去重     |
| 左右夹逼  | 167.两数之和 II  | 排序+夹逼    |
| 滑动窗口  | 209. 长度最小子数组 | 动态控制窗口   |
| 子数组枚举 | 560. 和为K的子数组 | 前缀和优化    |
| 子序列枚举 | 491. 递增子序列   | 回溯       |
| 倒序遍历  | 198. 打家劫舍    | 动态规划     |
| 规则模拟  | 54. 螺旋矩阵     | 控制方向循环遍历 |




* any list
{:toc}