---
layout: post
title:  test ui-02-UI 测试组件之 Appium 入门介绍
date:  2016-04-26 14:10:52 +0800
categories: [Test]
tags: [java, ui-test, test]
published: true
---


# Appium简介

正如主页所述，Appium的目标是支持许多不同平台（移动、Web、桌面等）的UI自动化。

不仅如此，它还旨在支持用不同语言（JS、Java、Python等）编写的自动化代码。

将所有这些功能组合到一个程序中是一个非常艰巨的任务，如果不是不可能的话！

为了实现这一目标，Appium有效地分为四个部分：

1. **Appium核心 - 定义核心API**
2. **驱动程序 - 实现与特定平台的连接**
3. **客户端 - 用特定语言实现Appium的API**
4. **插件 - 更改或扩展Appium的核心功能**

因此，要开始使用Appium进行自动化，您需要：

1. 安装Appium本身
2. 为目标平台安装一个驱动程序
3. 为目标编程语言安装一个客户端库
4. （可选）安装一个或多个插件

这些是基础知识！如果您准备好开始，可以继续查看快速入门！

如果您希望了解更多有关其工作原理的详细信息，请参阅以下页面以获取背景材料：

- [Appium核心](链接到相关页面)
- [Appium驱动程序](链接到相关页面)
- [Appium客户端](链接到相关页面)

# Appium工作原理

正如主页所述，Appium是一个开源项目和相关软件生态系统，旨在简化许多应用平台的UI自动化。随着Appium 2的发布，Appium有以下主要目标：

1. 使平台特定的自动化功能在跨平台的标准API下可用。
2. 允许从任何编程语言轻松访问此API。
3. 提供工具以便方便地共同开发Appium扩展。

因此，无论您了解哪个应用平台，比如iOS或Android，Appium都希望开发人员和测试人员能够按照单一、统一的API编写该平台的UI自动化代码。基于Appium的目标，我们需要回答许多问题，以使所有这些都能正常工作：

1. “单一、统一”的API应该是哪个？
2. 我们如何将该API映射到特定平台的自动化行为？
3. 我们如何使该API可通过多种流行的编程语言轻松访问？

在这里，还有一个更大的问题潜伏在背后，因为除了iOS和Android之外，还有更多的应用平台：

1. 我们如何为所有平台启用自动化？

探索Appium对这些问题的回答可能不是了解Appium的最快方式，但肯定是一个很好的方式！所以让我们深入研究。

**Appium选择的API**

Appium非常幸运，因为它前身是一个在UI自动化领域长期领先的技术，即Selenium。 Selenium项目的目标是支持浏览器的UI自动化，从这个角度来看，我们可以将其视为占据Appium目标的一个子集。在发展过程中，Selenium（和它们合并后的另一个项目WebDriver）为浏览器自动化开发了一个相对稳定的API。

多年来，Selenium与各种Web浏览器供应商和W3C标准组合作，将其API转化为一个官方的Web浏览器标准，称为WebDriver规范。现在，所有主要浏览器都实现了与WebDriver规范一致的自动化功能，而无需Selenium团队维护任何执行实际自动化的软件；标准为赢得！

Appium最初的目标是为移动应用（iOS和Android）开发自动化标准。我们本可以创造一些新东西，但为了与其他力量联合并保持标准，我们决定采用WebDriver规范作为Appium的API。虽然在网站和移动原生应用之间的用户交互并不完全相同（例如，在考虑由简单遥控器控制的电视平台时差异更大），但事实是大多数软件UI基本相同。这意味着WebDriver规范提供了在任何平台上都能使用的自动化API基元（查找元素、与元素交互、加载页面或屏幕等...），这些基元在任何平台上都基本相同。

当然，Appium希望支持从Web到移动或从Web到电视的用户交互差异的情况，因此Appium还利用了WebDriver规范的内置可扩展性。结果是，无论要自动化哪个平台，使用Appium时，您将使用标准的WebDriver规范，但有两个注意事项：

1. 我们可能无法在给定平台上支持特定的WebDriver API命令，因此某些命令可能不受支持（例如，在原生移动应用自动化的世界中，获取或设置Cookie是不可能的）。
2. 我们可能支持超出WebDriver API命令列表提供的自动化行为，尽管任何这样的命令都将是符合规范的WebDriver API的有效扩展。

**如何使用WebDriver API**

接下来的问题是，Appium如何将此协议映射到各种平台上的自动化行为？技巧在于，严格来说，Appium不这样做！它将这一责任留给一种称为Appium驱动程序的软件模块。您可以在接下来阅读的整个[Driver介绍](https://appium.io/docs/en/about-appium/intro/)中详细了解，所以我们现在不会深入研究它们的工作原理。

目前需要理解的重要事项是，驱动程序在某种程度上类似于一个可插入到Appium的可插拔模块，它赋予Appium自动化特定平台的能力（或者根据驱动的目标集，可能是一组平台）。在一天结束时，驱动程序的责任只是简单地实现一个代表WebDriver协议的Appium内部接口。它如何实现此接口完全取决于驱动程序，基于其在特定平台上实现自动化的策略。通常情况下，驱动程序依赖于特定于平台的自动化技术，虽然细节上更加复杂和困难。例如，苹果维护一种名为XCUITest的iOS自动化技术。支持iOS应用自动化的Appium驱动程序称为XCUITest Driver，因为它的最终目标是将WebDriver协议转换为XCUITest库调用。

驱动程序是独立的、可插拔的模块的原因之一是它们彼此完全不同。构建和使用不同平台的驱动程序的工具和要求完全不同。因此，Appium允许您仅使用您需要的驱动程序来执行自己的自动化任务。选择驱动程序并安装它们，以便您可以在Appium实例中使用它们，是非常重要的，以至于Appium都有自己的CLI来管理驱动程序。

所以，回答我们最初的问题，Appium为给定平台提供自动化功能的方式是，Appium团队（或任何其他人）为该平台编写了一个驱动程序，实现了所需的WebDriver协议的任何（子|超）集。然后，任何使用Appium的人都可以安装该驱动程序。

**通用编程语言访问**

那么，实际上使用WebDriver API是什么样的，特别是在Appium的上下文中？由于Appium最终是一个Node.js程序，它可能看起来像是将Appium及其驱动程序作为库导入到您自己的Node.js程序中。但是，这样做将无法实现Appium提供任何流行编程语言的自动化能力的目标。

幸运的是，Appium紧随Selenium的脚步，意味着我们从一开始就有了解决这个问题的解决方案。你看，WebDriver规范实际上是一种基于HTTP的协议，这意味着它设计用于在网络上使用，而不是在单个程序的内存中使用。

这种“客户端-服务器”架构的主要优势之一是它允许自动化实现者（在这种情况下是执行自动化的事物，即“服务器”）与定义自动化应该完成的步骤的自动化运行者（在这种情况下是“客户端”）完全不同。基本上，所有“难事”（实际弄清楚如何在给定平台上实现自动化）可以在服务器端的一个地方处理，而可以编写“薄”的客户端库以任何编程语言来编码将HTTP请求以语言适当的方式发送到服务器。换句话说，通过编写该语言的基本HTTP客户端，可以相对轻松地将基本的Appium / WebDriver功能引入到新的编程语言中，假设存在高级别的HTTP库。

对于您，Appium用户，这里有一些重要的要点：

1. Appium是一个HTTP服务器。只要您希望使用它进行自动化，它就必须作为一个进程在某台计算机上运行。它必须在网络上对您希望从中运行自动化的计算机（无论是同一台机器还是世界上的另一台计算机）进行访问。

2. 除非您想编写原始的HTTP调用或使用cURL，否则使用Appium进行自动化涉及使用您选择的语言的Appium客户端。这些客户端的目标是封装WebDriver协议，因此您无需担心协议本身，而可以使用在您的语言中感觉习惯的对象和方法。

3. Appium服务器和Appium客户端不需要在同一台计算机上运行。您只需要能够通过某个网络从客户端向服务器发送HTTP请求。这极大地方便了在云提供商上使用Appium，因为它们可以托管Appium服务器和任何相关的驱动程序和设备，而您只需要将客户端脚本指向其安全的端点。

当然，所有这些都与“测试”本身无关，纯粹是关于使用Appium及其客户端库进行自动化。如果您想进行“测试”目的的自动化，您可能希望寻求测试运行器、测试框架等的帮助，这些与Appium无关；Appium的“通用可访问性”的一个好处是它能够与您发现对您的情况最有利的工具集相关的任何一组工具很好地协同工作。

**Appium的 huge scope**

Appium的愿景（通过单一API自动化一切）是巨大的！当然，远大于开源项目的核心维护人员团队。那么Appium希望如何实现这个目标呢？基本上，通过赋予社区在Appium作为一个平台上开发功能的能力。这就是我们所说的Appium“生态系统”。

Appium团队确实正式维护一些驱动程序（例如前面提到的XCUITest驱动程序）。但是它无法希望拥有维护许多不同平台的驱动程序所需的平台特定的专业知识或能力。但是，特别是从Appium 2开始，我们所做的是提供工具，赋予社区加入我们愿景的能力：

1. 任何人都可以通过创建符合适当约定并实现WebDriver协议的任何（子|超）集的Node.js模块来创建驱动程序。创建驱动程序通常涉及一些代码，因为WebDriver协议的详细信息被抽象掉了，而且许多辅助库可用——这些库与Appium团队自己的驱动程序使用的相同。
2. 使用Appium驱动程序CLI，与他人分享驱动程序非常容易。没有中央机构。任何人都可以公开或私下分享驱动程序，可以免费或售卖。驱动程序可以是开源或闭源的（尽管显然我们欢迎开源！）。

Appium作为一个平台的开发愿景不仅限于支持所有应用平台的自动化。作为一种流行的自动化工具，有许多机会将Appium与各种其他工具和服务集成在一起。此外，有许多关于Appium的功能想法，无论是作为核心服务器还是在其在各种驱动程序中的化身，核心团队永远没有时间去构建。因此，随着Appium 2的发布，Appium推出了一个插件系统，使任何人都可以构建和分享改变Appium工作方式的模块！

与驱动程序一样，插件可以通过Appium驱动程序CLI发布和使用。插件可以做各种事情，例如添加Appium查找和与基于模板图像的屏幕区域交互的能力（如图像插件）。对于插件，您几乎可以做任何事情，因此您可能也有兴趣了解如何构建可用于Appium的Node.js插件。

这就是Appium：一个可扩展的、用于UI自动化的通用接口，可能涵盖一切！继续阅读一些具体的入门文档，以获取更多详细信息，或查看各种指南，深入了解Appium的一些更一般的概念和功能。

# Appium驱动程序简介

正如主要概览中明确提到的，“驱动程序”基本上是Appium对于“如何支持多个不相关平台的自动化”这个问题的回答。

在这份文档中，我们将更详细地了解驱动程序的工作原理。

驱动程序的具体细节可能对你来说并不太重要，除非你打算编写自己的驱动程序或为现有的驱动程序做贡献（我们希望你这样做！）。

了解更多关于驱动程序如何工作的一点好处是，了解典型复杂性或典型驱动程序架构将在你不可避免地在测试中遇到问题时指导你的调试过程。

## 接口实现¶

在最基本的层面上，驱动程序只是简单地扩展了Appium中包含的一个特殊类（称为BaseDriver）的Node.js类。

你可以使用以下非常简单的代码非常接近一个“可工作”的驱动程序：

```js
import BaseDriver from '@appium/base-driver'

class MyNewDriver extends BaseDriver {
}
```

这个空的驱动程序什么都不做，但你可以将它封装在一个Node.js模块中，向模块的清单（package.json）中添加一些与Appium相关的字段，然后使用`appium driver install`进行安装。

因此，从技术角度来看，一个Appium驱动程序只是继承自其他Appium代码的一小段代码。就是这样！现在，继承自BaseDriver实际上为我们带来了很多好处，因为BaseDriver本质上是整个WebDriver协议的封装。因此，驱动程序要实现有用的功能，只需要实现与其WebDriver协议等效的Node.js方法。

所以假设我想对这个空驱动程序做点什么；首先，我必须决定要实现哪个WebDriver命令。

在我们的例子中，让我们来看看导航到WebDriver命令。暂时不管当执行这个命令时我想让驱动程序做什么。为了告诉Appium驱动程序可以处理这个命令，我们只需在我们的驱动程序类中定义一个类似于以下的方法：

```js
async setUrl(url) {
    // do whatever we want here
}
```

就是这样！我们实际上如何实现这个命令完全取决于我们，取决于我们想要支持的平台。以下是针对不同平台的此命令的一些不同示例实现：

- 浏览器：执行一些JavaScript以设置window.location.href
- iOS应用程序：使用深链接启动应用程序
- Android应用程序：使用深链接启动应用程序
- React应用程序：加载特定路由
- Unity：转到一个命名场景

因此，您可以看到在不同平台上，驱动程序如何实现相同的WebDriver命令可能存在许多差异。2 然而，相同的是它们如何表达它们能够处理协议命令。

我们提供了这么多详细信息（顺便说一下，您不需要记住这些），因为强调一个重点很重要，即Appium驱动程序本质上并不是什么具体的东西，除了一小段能够处理WebDriver协议命令的JS代码。

从这点出发，接下来的发展取决于你，驱动程序的作者！


# 自动化映射¶

但通常，驱动程序作者想要做的是为给定的平台（通常是移动设备平台）提供语义上与浏览器的WebDriver规范实现非常相似的自动化行为。当你想要查找一个元素时，你应该得到一个对UI元素的引用。当你想要点击或轻触该元素时，结果的行为应该与人们点击或轻触该元素的行为相同。依此类推。

因此，驱动程序作者真正面临的挑战不是如何使用WebDriver协议（因为BaseDriver已经为您封装了所有这些），而是如何在目标平台上实现实际的自动化。每个驱动程序都依赖于其自己的一套底层技术。正如在总览中提到的，iOS驱动程序使用了一种名为XCUITest的Apple技术。这些底层自动化技术通常具有专有或独特的API。编写驱动程序变成了将WebDriver协议映射到这个底层API的任务（或者有时映射到一组不同的底层API，例如UiAutomator2驱动程序不仅依赖于Google的UiAutomator2技术，还依赖于通过ADB提供的功能，以及仅通过Android SDK在辅助应用程序中提供的功能）。将所有这些整合成一个可用的WebDriver接口是驱动程序开发中非常有用（但也非常具有挑战性）的艺术！

# 多层次架构¶

在实际应用中，这通常导致了一个相当复杂的架构。再以iOS为例。XCUITest框架（由Appium驱动程序使用）期望调用它的代码是用Objective-C或Swift编写的。此外，XCUITest代码只能在由Xcode触发的特殊模式下运行（直接或间接由Xcode命令行工具触发）。换句话说，没有直接的方法可以从Node.js函数实现（比如上面的`setUrl()`）到XCUITest API调用。

XCUITest驱动程序的作者所做的是将驱动程序分成两部分：一部分由Node.js编写（被合并到Appium中，最初处理WebDriver命令），另一部分由Objective-C编写（实际在iOS设备上运行并进行XCUITest API调用）。这使得与XCUITest进行交互成为可能，但也引入了两部分之间协调的新问题。

驱动程序的作者可以选择使用许多非常不同的策略来模拟Node.js端和Objective-C端之间的通信，但归根结底决定使用……WebDriver协议！没错，XCUITest驱动程序的Objective-C端本身就是一个WebDriver实现，称为WebDriverAgent。3

Appium XCUITest驱动程序为您构建和管理WebDriverAgent，这可能会有些麻烦，并涉及使用Xcode。
XCUITest驱动程序执行的任务远远超出了WebDriverAgent的能力范围，例如与模拟器或设备一起工作，安装应用程序等。
故事的寓意是，由于我们试图解决的问题的性质，驱动程序的架构可能变得相当复杂和多层次。这也意味着有时很难确定在这一系列技术中的哪个环节发生了问题，如果你在特定的测试中遇到了问题。在XCUITest世界中，我们同时涉及到以下一系列技术：

- 您的测试代码（在其编程语言中） - 由您拥有
- Appium客户端库 - 由Appium拥有
- Selenium客户端库 - 由Selenium拥有
- 网络（本地或互联网）
- Appium服务器 - 由Appium拥有
- Appium XCUITest驱动程序 - 由Appium拥有
- WebDriverAgent - 由Appium拥有
- Xcode - 由Apple拥有
- XCUITest - 由Apple拥有
- iOS本身 - 由Apple拥有
- macOS（其中运行Xcode和iOS模拟器） - 由Apple拥有

这是一个相当深的技术堆栈！

总之，Appium驱动程序的目标是提供一种通用的接口，以使您能够使用WebDriver协议在多个平台上执行自动化。

这就是Appium驱动程序的真正力量，以及为什么Appium能够成为一个强大的自动化工具，支持移动应用、Web应用和其他各种平台。

请注意，这只是Appium的基本工作原理的一个高层次概述，因为底层实现可能因平台和技术而异。

深入了解每个平台的细节将有助于您更好地使用Appium进行自动化测试。

# Proxy模式¶

还有一个重要的驱动程序架构方面需要理解，可以通过XCUITest驱动程序再次说明。

回想一下，我们刚刚讨论了XCUITest驱动程序的两个“部分”都使用了WebDriver协议---Node.js部分直接嵌入到了Appium的WebDriver服务器中，而Objective-C部分（WebDriverAgent）则是其自己的WebDriver实现。

这为Appium在某些情况下采取捷径提供了可能性。让我们想象一下，XCUITest驱动程序需要实现Click Element命令。

该实现的内部代码将类似于获取适当参数并构建HTTP请求到WebDriverAgent服务器。在这种情况下，我们基本上只是重建客户端对Appium服务器的原始调用！4因此，实际上甚至无需编写实现Click Element命令的函数。相反，XCUITest驱动程序只需让Appium知道这个命令应该直接代理到另一个WebDriver服务器。

如果您不熟悉“代理”概念，在这种情况下，它只是意味着XCUITest驱动程序根本不参与处理该命令。相反，它将在协议级别上仅被重新打包并转发到WebDriverAgent，WebDriverAgent的响应也将直接传递回客户端，而不需要XCUITest驱动程序代码查看或修改它。

这种架构模式为那些选择在所有地方处理WebDriver协议而不是构建专门协议的驱动程序作者提供了一个很好的奖励。这也意味着Appium可以非常轻松地为任何其他现有的WebDriver实现创建包装驱动程序。例如，如果您查看Appium Safari驱动程序代码，您会发现它基本上不实现任何标准命令，因为所有这些命令都直接代理到底层的SafariDriver进程。

重要的是要理解，这种代理业务有时是在幕后发生的，因此如果您曾经深入研究一些开源驱动程序代码，试图找出命令是在哪里实现的，您可能会惊讶地发现在Node.js驱动程序代码中根本没有实现！在这种情况下，您需要弄清楚命令正在被代理到何处，以便您可以在那里查找相应的实现。

好的，这就足够详细介绍驱动程序了！

# Appium客户端简介

如主要概览中所讨论的那样，Appium基于W3C WebDriver规范。

这意味着Appium实现了一个客户端-服务器架构。服务器（由Appium本身以及您用于自动化的任何驱动程序或插件组成）连接到测试设备，并实际负责在这些设备上执行自动化。

客户端（由您，Appium测试作者驱动）负责通过网络向服务器发送命令，并接收服务器的响应。

这些响应可用于判断自动化命令是否成功，或可能包含您查询应用程序状态的信息。这份文档是对此方程式中客户端部分的概念性介绍。

> 有关方程式的服务器端（即Appium如何实际控制设备？）的更多信息，请查看我们的Appium驱动程序简介。要跳转到Appium客户端库链接列表，请查看客户端列表。

有哪些自动化命令可用？这取决于您在任何给定会话中使用的特定驱动程序和插件。

例如，标准的命令集可能包括以下内容：

- 查找元素

- 点击元素

- 获取页面源码

- 获取屏幕截图

如果您查看WebDriver规范中的这些命令，您会注意到它们并没有根据任何特定的编程语言定义。

它们不是Java命令、JavaScript命令或Python命令。

相反，它们构成了一个HTTP API的一部分，可以从任何编程语言（或没有！如果您愿意，可以只使用cURL）中访问。

因此，例如，查找元素命令对应于发送到HTTP端点/session/:sessionid/element的HTTP POST请求（在这种情况下，:sessionid是服务器在先前调用Create Session时生成的唯一会话ID的占位符）。

这些信息主要对于开发与WebDriver规范兼容的技术的人员是有用的。对于试图编写Appium或Selenium测试的人来说，这并不特别有用。在编写Appium测试时，您希望使用熟悉的编程语言。幸运的是，存在一组Appium客户端库，负责与Appium服务器进行HTTP通信。它们不会直接暴露特定编程语言的HTTP细节，而是为特定编程语言公开了一组“本地”命令，使得对于测试作者来说，就感觉像是在编写Python、JavaScript或Java。

例如，以下是相同的一组简单的Appium命令，使用每种语言的推荐Appium客户端绑定（请注意，这不是包含所有适当导入的工作示例代码；请参阅每个客户端库的设置和命令参考文档）：

```js
const element = await driver.$('//*[@text="Foo"]');
await element.click();
console.log(await element.getText())
console.log(await driver.getPageSource())
```

这些脚本，尽管使用不同的编程语言编写，但在底层执行的是相同的操作：

1. 使用xpath作为using参数，使用表达XPath查询的值参数调用Find Element。（如果您对这些术语感到困惑，您可能会发现介绍Appium或Selenium的内容很有用）
2. 使用上一步调用中找到的元素的ID调用Click Element。
3. 使用相同元素的ID调用Get Element Text，并将其打印到控制台。
4. 调用Get Page Source检索页面/应用源代码，并将其打印到控制台。

在选择或使用客户端之前，需要注意的另一件事是每个客户端都是独立维护的。仅因为一个客户端中有某个功能，并不意味着另一个客户端也有（尽管所有客户端至少支持标准的W3C协议以及任何常见的Appium扩展）。仅因为一个客户端具有一套不错的辅助函数，并不意味着另一个客户端也有。有些客户端保持非常频繁的更新，而其他客户端则没有！因此，在选择库时，首要考虑的是要使用的编程语言，其次考虑的是库的功能齐全程度和维护情况如何！

要了解如何使用Appium客户端，请访问该客户端的主页以获取更多信息。在许多情况下，给定语言的Appium客户端是建立在该语言的Selenium客户端之上的，因此某些Appium客户端可能仅记录在Selenium客户端之上添加的功能。总之，为了获取完整的参考信息，您可能需要同时访问Appium客户端文档和Selenium客户端文档。

这就是关于Appium客户端的所有需要知道的内容！请转到[客户端页面](https://appium.io/docs/en/about-appium/intro/#clients)查看当前客户端列表。

# chat

## 详细介绍 UI 测试组件 Appium

**Appium 简介：**

Appium 是一款用于移动应用程序自动化测试的开源工具。

它支持 Android 和 iOS 平台上的原生应用、混合应用和移动网页应用。

Appium提供了一种统一的接口，使得开发人员能够使用相同的API和测试脚本来测试不同平台上的移动应用程序。

以下是 Appium 的一些关键特性和组成部分：

1. **跨平台支持：** Appium 提供了一致的 API，允许使用相同的测试脚本来测试 Android 和 iOS 应用程序。这种跨平台支持使得测试脚本的复用性更强。

2. **支持多种应用类型：** Appium 可以测试原生应用、混合应用和移动网页应用，使其成为一种灵活的移动应用测试工具。

3. **多语言支持：** Appium 支持多种编程语言，包括 Java、Python、JavaScript、C# 等，让开发人员能够使用他们熟悉的语言编写测试脚本。

4. **无需修改应用程序代码：** Appium 允许测试应用程序而无需在应用程序代码中插入任何特殊的标记或代码，这使得测试对应用程序的影响最小。

5. **支持多种设备：** Appium 可以在不同的设备上运行，包括真实设备和模拟器。这为开发人员提供了在多种环境中进行测试的能力。

6. **基于 WebDriver 协议：** Appium 是建立在 WebDriver 协议之上的，这使得它与许多现有的自动化测试工具和框架能够更好地集成。

7. **社区活跃：** Appium 拥有庞大的开发者社区，提供了丰富的文档、教程和支持资源。

**Appium 架构：**

Appium 的架构包括以下关键组件：

1. **Appium Server：** Appium 服务器负责接收来自测试脚本的命令，并将这些命令转发到设备上的相应驱动程序。

2. **Appium Clients：** Appium 客户端是与 Appium 服务器通信的库或工具，支持多种编程语言。开发人员使用客户端库来编写测试脚本。

3. **Appium Drivers：** Appium 驱动程序负责与设备上的操作系统和应用程序进行通信。每个驱动程序针对特定的移动平台（Android 或 iOS）和应用类型（原生、混合、Web）。

4. **JSON Wire Protocol：** Appium 使用 JSON Wire Protocol（基于 WebDriver 协议）来定义客户端和服务器之间的通信协议。

**Appium 测试流程：**

1. **启动 Appium 服务器：** 使用 Appium 服务器启动，并监听来自测试脚本的命令。

2. **连接设备：** Appium 与测试设备建立连接，可以是真实设备或模拟器。

3. **启动应用：** Appium 启动或安装待测试的应用程序。

4. **执行测试：** 测试脚本通过 Appium 客户端与 Appium 服务器通信，发送测试命令。

5. **设备操作：** Appium 驱动程序将测试命令翻译为设备上的相应操作，例如点击、滑动、输入等。

6. **结果返回：** 执行结果和测试日志返回给测试脚本，可以用于验证测试是否成功。

7. **关闭应用和断开连接：** 测试结束后，Appium 关闭应用程序，断开与设备的连接。

**总结：**

Appium 是一款强大的移动应用自动化测试工具，提供了跨平台、多语言支持，能够在不同类型的移动应用上执行测试。由于其灵活性和活跃的社区支持，Appium 成为了移动应用测试领域的热门选择。


## WebDriver 协议是什么？

WebDriver 协议是一种用于浏览器自动化的开放标准协议，它定义了客户端（测试脚本）和浏览器驱动程序之间的通信规范。

该协议旨在实现对不同浏览器的统一控制和操作，使得测试人员能够使用相同的测试脚本来与不同浏览器进行交互。

主要的 WebDriver 协议实现由 Selenium 提供，因此它通常被称为 "Selenium WebDriver"。

然而，WebDriver 协议并不局限于 Selenium，其他自动化测试工具和框架也可以实现该协议，从而与不同浏览器进行通信。

以下是 WebDriver 协议的关键特点：

1. **统一的接口：** WebDriver 提供了一个统一的接口，通过这个接口，测试脚本可以与各种浏览器进行通信，包括 Chrome、Firefox、Edge、Safari 等。

2. **多语言支持：** WebDriver 协议支持多种编程语言，使得测试人员可以使用他们熟悉的语言编写测试脚本。常见的支持语言包括 Java、Python、JavaScript、C# 等。

3. **定义了浏览器行为：** 协议定义了一组命令和事件，用于描述测试脚本与浏览器之间的交互。这包括导航、元素定位、点击、输入等操作。

4. **无缝集成：** WebDriver 协议的实现通常嵌入在浏览器驱动程序中，作为浏览器和测试脚本之间的中介。这样的实现可以与浏览器的不同版本和类型进行无缝集成。

5. **异步通信：** WebDriver 协议基于异步通信模型，测试脚本发送命令并等待响应。这允许测试脚本在等待操作完成时执行其他任务。

使用 WebDriver 协议，测试人员可以编写一套通用的测试脚本，然后在不同浏览器和平台上运行，而不必修改脚本的主要逻辑。这种能力大大提高了测试的可维护性和跨浏览器兼容性。

## ios/安卓 和 WebDriver 协议应该是不兼容的吧？是不是只能用于 web 页面？

iOS、Android 和 WebDriver 协议之间并非不兼容，实际上，WebDriver 协议的设计是为了支持跨平台的浏览器自动化测试，包括原生应用、混合应用以及移动网页应用。

WebDriver 协议提供了一种通用的方式来与不同平台上的浏览器和应用进行通信。

对于移动应用（原生应用和混合应用），WebDriver 协议的实现通常是通过相应的移动端浏览器驱动来完成的。

这些驱动负责将 WebDriver 协议翻译成与移动平台交互的原生命令，从而实现对移动应用的控制和操作。

在移动应用测试中，主要有两个常用的 WebDriver 协议的实现：

1. **XCUITest（iOS）和 UIAutomator（Android）：** 这两个是用于原生应用的测试框架，它们直接支持 WebDriver 协议。XCUITest 用于 iOS 应用，而 UIAutomator 用于 Android 应用。

2. **Appium：** Appium 是一个开源的移动应用自动化测试工具，它实现了 WebDriver 协议，并允许测试人员使用通用的 WebDriver API 来测试 iOS、Android 和移动网页应用。Appium 的底层实现使用了 XCUITest 和 UIAutomator，使得它可以适用于不同平台。

总体而言，WebDriver 协议不仅限于 Web 页面，也适用于跨平台的移动应用测试。测试人员可以使用相同的 WebDriver API 编写测试脚本，然后在不同平台上运行这些脚本，从而实现代码的可重用性和跨平台兼容性。

## 给出 Appium 深入的学习资料，包含网址

以下是一些深入学习 Appium 的资料和网址，包括官方文档、教程、示例代码以及一些建议的书籍：

1. **Appium 官方文档：**
   - [Appium Documentation](http://appium.io/docs/en/about-appium/intro/): Appium 的官方文档包含详细的介绍、安装指南、API 参考等，是深入了解 Appium 的首选资源。

2. **Appium GitHub 仓库：**
   - [Appium GitHub Repository](https://github.com/appium/appium): Appium 的 GitHub 仓库包含源代码、问题跟踪和其他与项目相关的信息。可以在这里找到最新的更新和贡献者。

3. **Appium Pro：**
   - [Appium Pro](https://appiumpro.com/): Appium Pro 是一份由 Jonathan Lipps 撰写的付费订阅周刊，提供有关 Appium 最新技术和实践的高质量内容。

4. **Test Automation University - Appium Courses:**
   - [Test Automation University - Appium Courses](https://testautomationu.applitools.com/appium-webinar-series-joel-herrington/): Test Automation University 提供了一系列关于 Appium 的在线课程，由行业专家讲授。

5. **Appium Essentials Book:**
   - ["Appium Essentials" by Manoj Hans](https://www.packtpub.com/product/appium-essentials/9781783554705): 这本书提供了关于 Appium 的深入介绍，适合希望深入了解 Appium 的读者。

6. **Appium Pro Newsletter Archive:**
   - [Appium Pro Newsletter Archive](https://appiumpro.com/editions): Appium Pro 的邮件通讯包含了大量有关 Appium 的实用信息，可以查看过往的邮件来获取更多知识。

请注意，Appium 是一个不断发展的开源项目，因此确保查看最新版本的文档和教程以获取最准确和最新的信息。

深入学习 Appium 最好通过实际的实践和项目经验，因为实际项目中的挑战有助于更好地理解和应用所学知识。

## 详细介绍一下Appium 的架构关键组件

Appium 的架构涉及到多个关键组件，这些组件协同工作，使得 Appium 能够实现对移动应用程序的自动化测试。

以下是 Appium 架构的主要组件：

1. **Appium Server：**
   - **作用：** Appium Server 是 Appium 架构的核心组件，负责接收来自客户端（测试脚本）的命令，并将这些命令转发到设备上的相应驱动程序。
   - **实现：** Appium Server 的实现有两种：Appium Server for Android 和 Appium Server for iOS。它们分别负责与 Android 和 iOS 设备进行通信。

2. **Appium Clients：**
   - **作用：** Appium Clients 是用于与 Appium Server 通信的库或工具，支持多种编程语言。开发人员使用这些客户端库来编写测试脚本。
   - **实现：** Appium 支持多种编程语言的客户端，如 Java、Python、JavaScript、C# 等。测试人员可以选择他们熟悉的语言来编写测试脚本。

3. **Appium Drivers：**
   - **作用：** Appium Drivers 负责与设备上的操作系统和应用程序进行通信，执行测试脚本中指定的动作。
   - **实现：** Appium 针对 Android 和 iOS 分别提供了相应的驱动程序。这些驱动程序将测试脚本中的命令转换成设备上的原生命令，实现测试操作。

4. **JSON Wire Protocol：**
   - **作用：** Appium 使用 JSON Wire Protocol（基于 WebDriver 协议）来定义客户端和服务器之间的通信规范。这种协议定义了客户端发送命令，服务器执行并返回结果的方式。
   - **实现：** JSON Wire Protocol 提供了一种统一的方式来描述测试操作和传递数据，使得不同语言的客户端能够与不同语言的服务器进行通信。

5. **Mobile Devices：**
   - **作用：** 移动设备是需要测试的目标。这可以是 Android 设备、iOS 设备或模拟器。
   - **实现：** Appium 支持与真实设备和模拟器进行通信，以执行测试操作。

总体而言，Appium 的架构通过 Appium Server 、客户端库、驱动程序和移动设备之间的协同工作，实现了一种通用的、跨平台的移动应用程序自动化测试框架。

这种设计使得开发人员能够使用相同的测试脚本来测试不同平台上的应用程序，提高了测试的可维护性和可重复性。

# 小结

selenium 为 web 的统一做出巨大贡献，看的出来 aoppium 期望统一移动端+web端。

# 参考资料

https://www.selenium.dev/documentation/webdriver/getting_started/first_script/

* any list
{:toc}