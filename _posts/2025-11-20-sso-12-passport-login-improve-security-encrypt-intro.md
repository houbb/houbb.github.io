---
layout: post
title: 权限体系之-12-passport 登录安全之加密策略 慢的艺术
date: 2025-11-20 14:12:33 +0800
categories: [plateform]
tags: [plateform, sh]
published: true
---






# chat

## 限制

详细介绍一下下面的几个加密算法：企业系统推荐： bcrypt > Argon2 > PBKDF2 > scrypt 对比一下

很好，这个问题非常“企业级”。

你给出的排序：
**bcrypt > Argon2 > PBKDF2 > scrypt**
本质是在问：**密码存储到底该用哪个算法最靠谱？**

我从「原理 + 安全性 + 企业实践 + 场景推荐」四个维度给你系统性对比一次。

---

# 一、先统一一个核心认知

这些都不是“加密算法”，而是：

> ✅ 专门用于密码存储的「密码哈希算法（Password Hashing Function）」

它们的目标不是快，而是：

* 慢
* 可调成本
* 抗暴力破解
* 抗 GPU/ASIC 并行攻击

---

# 二、总体结论先给你

| 排名        | 算法    | 企业推荐指数            | 适合场景 |
| --------- | ----- | ----------------- | ---- |
| 🥇 Argon2 | ★★★★★ | 高安全系统 / 金融 / 身份平台 |      |
| 🥈 bcrypt | ★★★★☆ | 互联网系统通用首选         |      |
| 🥉 scrypt | ★★★☆☆ | 防 GPU 侧重点系统       |      |
| 🧱 PBKDF2 | ★★☆☆☆ | 兼容老系统、安全下限        |      |

如果你在设计 Passport/SSO：
👉 **强烈建议：Argon2 或 bcrypt**

---

# 三、逐个深度解析

---

## 1️⃣ bcrypt —— 老牌王者，企业最常用

### 特点

* 基于 Blowfish
* 自带 salt
* 可配置 cost（工作因子）
* 专门为密码设计

### 优点

✅ 实战验证多年
✅ 抵抗彩虹表
✅ 易用、成熟、稳定
✅ Java / Spring / DevOps 原生支持极强
✅ 企业落地成本低

### 缺点

❌ 对 GPU 抵抗能力一般
❌ 最大密码长度 72 字节
❌ 时代稍显老旧

### 示例思想

```
$2a$10$wHkJ9GbO...xxxxx
```

10 = cost，越高越慢

### 适用

* 通用企业系统
* 大多数互联网产品
* Passport / UMS / SSO 首选之一

---

## 2️⃣ Argon2 —— 当前理论最优解

2015 年密码哈希大赛 PHC 冠军。

### 推荐模式

Argon2id （综合版，最安全）

### 特点

* 内存硬性消耗算法
* 兼顾 CPU + RAM 抗破解
* 多模态配置

### 优点

✅ 抗 GPU / ASIC 攻击极强
✅ 可调参数丰富
✅ 当代密码学推荐首选
✅ 真正安全向设计

### 缺点

❌ 实现复杂
❌ 生态比 bcrypt 弱一点
❌ 配置需要一定经验

### 参数控制

* memory_cost
* time_cost
* parallelism

### 适用

* 金融、政府、核心身份系统
* 高安全级别 Passport

---

## 3️⃣ PBKDF2 —— 安全但偏“保守”

最早标准化的密码哈希方法之一。

### 特点

* 基于 HMAC
* 迭代次数可控

### 优点

✅ 标准化程度高（RFC 2898）
✅ 兼容极好
✅ 各语言原生支持

### 缺点

❌ 容易被 GPU 暴力破解
❌ 纯 CPU 算法，抗并行能力差
❌ 只适合“最低安全保障”

### 适用

* 兼容老系统
* 系统升级过渡期

---

## 4️⃣ scrypt —— GPU 抗性优选

scrypt 是为抗 GPU 破解而设计。

### 核心思想

通过消耗大量内存，让并行攻击成本异常高。

### 优点

✅ GPU 抗性较强
✅ 比 PBKDF2 强
✅ 支持内存消耗机制

### 缺点

❌ 实现复杂
❌ 参数不当可能影响性能
❌ 开发使用率不如 bcrypt

---

# 四、核心对比矩阵（企业视角）

| 维度     | bcrypt | Argon2 | PBKDF2 | scrypt |
| ------ | ------ | ------ | ------ | ------ |
| 安全性    | 高      | 极高     | 一般     | 高      |
| GPU 抵抗 | 中      | 极强     | 弱      | 强      |
| 内存消耗   | 低      | 高      | 低      | 高      |
| 企业成熟度  | 极高     | 高      | 极高     | 中      |
| 易用性    | 极高     | 中      | 高      | 中      |
| 未来趋势   | 稳定     | 主流     | 淘汰边缘   | 小众     |

---

# 五、为什么你给的顺序几乎是反的？

你给的是：

> bcrypt > Argon2 > PBKDF2 > scrypt

从“企业可落地性”角度，这个排序其实合理：

* bcrypt：落地友好、稳定性王者
* Argon2：理论最强，但配置门槛高
* PBKDF2：广泛但安全退化
* scrypt：存在感弱于前两者

如果从**安全理论**排序：

> Argon2 > scrypt > bcrypt > PBKDF2

所以取决于你更关注：

* 实用性？选 bcrypt
* 极致安全？选 Argon2

---

# 六、企业推荐策略（落地版）

## ✅ 标准 Web 系统

```text
bcrypt(cost=10~12) + 唯一 salt + pepper
```

## ✅ 高安全 Passport

```text
Argon2id(memory=64MB, time=3, parallelism=2)
```

## ✅ 老系统迁移

```text
PBKDF2 -> bcrypt 渐进升级
```

---

# 七、Passport 场景的推荐方案

结合你之前的 Passport 风控设计，给你一个实战建议：

### 推荐架构

```
密码输入
 ↓
Argon2id 哈希
 ↓
数据库存储
 ↓
加 pepper 二次增强
 ↓
登录验证比对
```

并配合：

* 密码复杂度策略
* 密码黑名单
* 登录限流
* 登录失败封禁

---

# 八、重点总结

一句话版本：

| 需求       | 推荐                |
| -------- | ----------------- |
| 通用企业系统   | ✅ bcrypt          |
| 高安全系统    | ✅ Argon2          |
| 老系统被迫兼容  | ⚠ PBKDF2          |
| 抗 GPU 攻击 | ✅ Argon2 / scrypt |

最终结论：

> ✅ 如果你在设计真正靠谱的 Passport：
> **Argon2id 是技术上最优解，bcrypt 是工程上最优解。**

---

如果你希望，我可以进一步给你：

* ✅ Java Spring 中 Argon2 / bcrypt 实战最佳实践配置
* ✅ Passport 密码存储完整安全方案设计
* ✅ 登录系统「密码安全体系」全景蓝图

你可以直接说：
**“结合我的 Passport 项目，给出最优密码存储技术方案”** 👌

## 你这里所谓的慢我没有直观的感受 给出耗时对比

你这个问题问得非常到位 ——
“慢”不量化，其实就是空话。

我直接给你一个**可感知的耗时对比表**，让你一眼就明白这些算法到底“慢在哪”。

---

# 一、先给你直观结论

👉 同样一台普通服务器（约 4 核 CPU），单次密码哈希耗时大致如下：

| 算法           | 常见安全配置        | 单次耗时（约）      | 直观感受  |
| ------------ | ------------- | ------------ | ----- |
| MD5 / SHA256 | 默认            | 0.002 ms     | 快到离谱  |
| PBKDF2       | 100,000 次迭代   | 50 ~ 120 ms  | 稍微有点慢 |
| bcrypt       | cost=10       | 80 ~ 150 ms  | 人类可感知 |
| bcrypt       | cost=12       | 250 ~ 350 ms | 明显延迟  |
| scrypt       | 标准参数          | 200 ~ 500 ms | 已经很慢  |
| Argon2id     | 64MB / time=3 | 300 ~ 800 ms | 安全级慢  |

✅ 你现在终于可以直观理解了：
bcrypt / Argon2 的一个核心设计目标就是：

> 让攻击者每猜一次密码，都要付出「接近 0.5 秒」的代价。

---

# 二、从“攻击者视角”看差异更清楚

假设黑客拿到了你的用户密码表：

## 使用普通哈希（SHA256）

```
每秒可计算：10 亿次
1 小时：36万亿次尝试
```

## 使用 bcrypt（cost=12）

```
单次 300ms ≈ 每秒 3次
1 小时：10800次
```

差距不是倍数，是天文级。

> 这就是“慢”的真正意义：
> 不是让用户慢，是让黑客绝望。

---

# 三、用更形象的比喻

| 算法     | 类比       |
| ------ | -------- |
| MD5    | 开门不用钥匙   |
| PBKDF2 | 加一把普通锁   |
| bcrypt | 防盗门      |
| scrypt | 指纹 + 防盗门 |
| Argon2 | 银行金库级别   |

---

# 四、一次登录请求的真实体验

我们从用户登录角度看：

### bcrypt cost=10

```
输入密码 → 后端校验 → 响应完成：约 120ms
用户几乎无感
```

### Argon2id（安全配置）

```
输入密码 → 延迟 400~600ms → 响应
用户会感觉：稍微慢一点但仍可接受
```

你的前后端请求链路通常在：

* 网络：100ms
* 数据库：50ms
* JS渲染：50ms

所以：

> 只要在 500ms 以内，用户体验完全可接受。

---

# 五、四大算法实测对比（模拟）

以 Java 服务为例单线程：

| 算法           | 1 次耗时 | 100 次 | 1000 次 |
| ------------ | ----- | ----- | ------ |
| PBKDF2(100k) | 90ms  | 9s    | 90s    |
| bcrypt(10)   | 120ms | 12s   | 120s   |
| bcrypt(12)   | 300ms | 30s   | 300s   |
| Argon2id     | 500ms | 50s   | 500s   |

攻击者要破解 10 万真实用户密码：

| 算法         | 预计耗时 |
| ---------- | ---- |
| SHA256     | 几秒   |
| PBKDF2     | 数小时  |
| bcrypt(12) | 数年   |
| Argon2id   | 数十年  |

---

# 六、为什么不能“太快”？

你可能会想：
“登录慢一点真的值得吗？”

答案是：

✅ 是的，非常值得。

因为密码系统就是典型的：

* 正常用户：每天验证 3~5 次
* 攻击者：每秒验证几十万次

慢 = 只影响攻击者，不影响正常用户。

---

# 七、企业级建议配置（平衡版）

结合你 Passport 平台：

### ✅ bcrypt 推荐

```
cost = 12
耗时 ≈ 250ms
安全 & 性能平衡最佳
```

### ✅ Argon2 推荐

```
Argon2id
memory = 64MB
iterations = 3
time ≈ 400~700ms
```

---

# 八、如果你需要更极致的直观感受

我可以给你模拟一个对比：

| 场景         | 完成 1 万次密码验证所需时间 |
| ---------- | --------------- |
| MD5        | 0.02 秒          |
| PBKDF2     | 15 分钟           |
| bcrypt(12) | 50 分钟           |
| Argon2id   | 2 小时以上          |

这个时候你会明白：
慢，是一种战略武器。

---

# 九、总结一句话

✅ “慢”不是缺点，而是密码算法最重要的护城河。

| 你关心的是  | 结论    |
| ------ | ----- |
| 登录体验   | 完全可接受 |
| 防暴力破解  | 显著提升  |
| 企业安全等级 | 质变级提升 |

---

如果你想更进一步，我可以帮你做：

* 🔧 模拟你 Passport 系统的真实 QPS 压测估算
* 📊 登录并发情况下不同算法的性能瓶颈分析
* 🧠 安全等级 vs 性能成本的最优曲线设计

直接说：
👉 **“帮我估算 Passport 并发登录下的性能影响”**
我可以给你算到服务器规格级别。


## 为什么会这么慢？

这个问题问得非常“到本质” 👍  
一句话回答你：

> **它们慢，不是因为技术差，而是“被刻意设计成慢”。慢本身就是安全机制。**

我用几个层次帮你拆清楚。

---

## 一、普通哈希为什么“快得离谱”？

像 MD5 / SHA256 这种设计目标是：

- 文件校验
- 数据完整性验证
- 高吞吐计算

它们追求的是：
```
越快越好、越多越好、越省资源越好
```

所以结果是：
- 一秒可以算几千万乃至上亿次
- GPU 可以并行跑到恐怖级别

这在“密码场景”下就是灾难：
> 黑客一秒可以试几亿个密码。

---

## 二、密码哈希为什么要“故意变慢”？

密码系统的目标完全相反：

✅ 不是高性能  
✅ 是让暴力破解代价变高  
✅ 是让穷举变得不可承受

于是出现了一个核心理念：

> Password Hash = 刻意消耗 CPU + 时间 + 内存

所以它们被设计为：
- 多次重复运算（迭代）
- 强制等待
- 占用大量内存
- 抑制并行

---

## 三、“慢”的真正来源拆解

我们用 bcrypt / Argon2 为例。

### 1️⃣ 反复计算（Key Stretching）

bcrypt 干的事情类似：

```
hash(password)
再 hash(hash(password))
再 hash(...)
重复 2^cost 次
```

cost=12 意味着：
```
重复 4096 次加密轮
```

不是一次，而是几千次。

---

### 2️⃣ 强制时间成本

算法内部存在：  
「必须走完这套流程才能给结果」

不像普通函数可以被 CPU 优化，它是刻意绕路。

就像：
- 普通算法直线跑
- 密码算法强制蛇形绕 100 圈

---

### 3️⃣ 内存硬消耗（Argon2 / scrypt）

Argon2 更狠：

它不仅慢，而且会说：
```
你必须给我 64MB 内存，否则我不干活
```

而 GPU 的问题是：
- 算得快但内存小
- 并行多但内存不够

于是破解成本暴涨。

---

### 4️⃣ 抑制并行攻击

普通哈希：
```
GPU 一张显卡 = 几千线程一起算
```

Argon2 / bcrypt：
```
你想并行？可以，每个线程都要完整的内存和时间
```

结果是：
✅ 攻击成本线性暴涨  
✅ 黑客硬件费用极高  

---

## 四、用人类世界做比喻更直观

| 普通哈希 | 密码哈希 |
|----------|------------|
| 刷二维码进门 | 要过 10 道关卡安检 |
| 打开 Excel | 打开银行金库 |
| 骑共享单车 | 开保险柜 |

bcrypt / Argon2 就像：

> 每次验证密码，都执行一场“安全演练”

而不是简单查个字符串。

---

## 五、从执行过程看真实差异

### 普通 SHA256
```
1. 读取密码
2. 数学函数
3. 输出结果
完成 ✅
```

### bcrypt
```
1. 生成盐
2. 重复数千次 Blowfish 加密
3. 混合盐与密码
4. 多轮循环扰动
5. 输出结果
```

### Argon2
```
1. 分配内存区块
2. 多轮随机访问
3. 混合KDF运算
4. 内存重排
5. 多次迭代
6. 输出结果
```

你可以理解为：

> 普通哈希是“算一道题”，密码哈希是“做一整套卷子”。

---

## 六、为什么不能再快一点？

因为一旦变快，攻击者就开心了。

假设：
- 算法 1ms 完成 ⇒ 一秒 1000 次
- 算法 300ms 完成 ⇒ 一秒 3 次

对用户：
- 500ms 登录体验你几乎无感

对攻击者：
- 从每秒百万次 → 每秒 3 次  
- 破解成本直接跃迁几个数量级

慢是精准打击攻击者的。

---

## 七、一个更真实的数学对比

假设用户密码为 8 位：

| 算法 | 破解 1 亿次尝试耗时 |
|------|----------------|
| SHA256 | 0.1 秒 |
| bcrypt(12) | 347 天 |
| Argon2 | 6 年 |

这就是你感知的“慢”。

---

## 八、结论：它们不是慢，是“重型安保程序”

可以总结成一句话：

> ✅ 普通哈希是跑得快  
> ✅ 密码哈希是穿着防弹衣慢慢走  
> ✅ 慢 = 强安全的代价

---

## 九、给你的直观认知总结

| 你看到的 | 实际含义 |
|------------|------------|
| 登录稍微慢一点 | 安全级别直线上升 |
| CPU 占用高一点 | 黑客崩溃 |
| 内存消耗 | 防 GPU 暴力破解 |

## 对自己系统的影响？


你这个直觉非常对：  
**“慢密码算法 = 伤敌一千，自损八百？”**  
看起来是，但实际上这是一个**非常精妙的“可控自伤，换取极高安全性”的设计哲学**。

我用更直观的方式拆给你。

---

## 一、慢算法确实会“伤自己”，但它伤得很可控

先说结论：

> ✅ 密码哈希算法的“慢”，是对攻击者成千上万倍的伤害  
> ✅ 对正常系统的影响是微乎其微的

### 看一个真实对比：

假设：
- 用户平均登录 QPS：50
- 黑客撞库速度：100万次/秒

| 场景 | 普通 Hash(SHA-256) | bcrypt(cost=10) |
|------|------------------|----------------|
| 单次耗时 | 0.1ms | 100ms |
| 正常登录成本 | 50 * 100ms = 5s / 秒 | 可接受 |
| 黑客爆破成本(100万次) | 100ms 总耗时 | 27小时 |

**差距是指数级的，不是线性级的。**

慢算法对：
- ✅ 正常用户：多 100ms 几乎无感  
- ❌ 攻击者：直接从“秒级”变成“几天甚至几个月”

---

## 二、密码算法为什么必须“慢”？

因为你防的不是普通程序，是：

- GPU 并行暴力破解
- 彩虹表
- 字典攻击
- 分布式云算力

如果你的密码验证是「快的」，攻击流程是这样的：

```
数据库泄露 → 拿走 hash → 离线暴力破解 → 秒出结果
```

慢算法的核心目的只有一句：

> 让攻击者每试一次密码都“肉疼”。

---

## 三、系统真的会被拖垮吗？看两个关键点

### ✅ 1. 登录不是高频操作

登录场景不是：
- 每秒10万请求
而是：
- 用户偶尔登录
- 修改密码
- 找回密码

这和接口QPS完全不是一个量级。

所以，CPU消耗主要集中在：
- **认证边界**
- 而不是业务核心

---

### ✅ 2. 慢是“可调”的

以 bcrypt 为例：

```text
cost = 10 → 100ms
cost = 12 → 300ms
cost = 14 → 1秒+
```

你可以根据业务调整：

| 场景 | 推荐 |
|------|------|
| 普通企业系统 | bcrypt cost = 10~12 |
| 金融系统 | Argon2 / cost更高 |
| 高并发系统 | PBKDF2 次数降低 |

所以不会出现“拖垮系统”现象，而是**精准控制性能成本**。

---

## 四、真实系统中的架构做法

成熟系统都是这样设计的：

### 🎯 登录结构拆分

```
浏览器
  ↓
网关限流
  ↓
认证服务(专用)
  ↓
慢哈希验证
```

慢操作只在：
- auth-service 内部
- 不影响核心业务线程

甚至可以：
- 登录队列化
- 独立实例扩容

---

## 五、真正的收益：服务器慢 100ms，黑客慢 3个月

直观对比给你记住这个感觉：

| 角色 | SHA-256 | bcrypt |
|------|----------|----------|
| 正常用户 | 0.01秒 | 0.1秒 |
| 黑客爆破 10亿次 | 10秒 | 3年 |

所以这不是“伤敌一千自损八百”，而是：

> **伤敌一亿，自损 0.1 秒。**

---

## 六、正确姿势：如何避免系统损耗过大？

企业级实践通常配合：

### ✅ 1. 登录限流 + IP封禁
极大减少触发慢算法的频率。

### ✅ 2. 缓存登录态
成功登录后：
- 不再重复验证密码
- 走 Token / Session

### ✅ 3. 异常账户策略
连续失败锁定 + 冻结。

---

## 七、总结一句话给你

慢密码 = 用 CPU 换时间，用时间换安全。

这是现代安全领域的经典设计哲学：

> ✅ 接受可控的系统损耗  
> ✅ 换取攻击成本指数级上升  
> ✅ 让黑客从“随便试试”变成“根本不想试”

---

## 如果从 Passport 平台角度给你一个结论建议：

| 场景 | 建议 |
|------|------|
| 企业通用 | bcrypt (cost 10-12) |
| 高安全级 | Argon2id |
| 老系统兼容 | PBKDF2 |

并配套：
- 登录失败处理
- 限流
- 风控规则
- IP封禁




# 加密策略安全性问题

这一块其实正是「密码安全的分水岭」。

很多系统还停留在 **“MD5 + salt = 安全” 的认知阶段**，但在今天的攻防环境下，这已经远远不够了。

我从工程角度给你拆清楚：

---

# 一、MD5 + salt 到底差在哪里？

很多系统的“安全设计”大概是这样：

```text
password = 用户输入
salt = 随机字符串
hash = MD5(password + salt)
```

看起来很专业，但问题非常大。

## 1. MD5 本质是“高速哈希算法”

MD5 设计目标不是安全，而是：

> 快速计算 + 快速校验完整性

在密码领域，**快是致命缺陷**。

### 现实攻击成本：

* GPU 每秒可计算：

  * 💥 数十亿次 MD5
* 也就是说：
  一个 8 位复杂密码，在离线下可能几分钟就被跑出来。

安全密码的目标恰恰相反：

> 必须慢到攻击者无法批量尝试。

---

## 2. Salt 并没有解决“暴力破解”问题

Salt 的作用是什么？

✅ 防止相同密码得到相同 hash
✅ 破坏预生成彩虹表

但它无法阻止：

* 暴力枚举
* GPU 并行破解
* 撞库攻击

即便你这样：

```text
MD5(salt + password)
```

攻击者只需要：

```
读取 salt
暴力尝试密码
对每个密码重新 MD5(salt + guess)
```

Salt ≠ 防破解
Salt 只是让破解“更麻烦，但还远不够”。

---

## 3. MD5 已被彻底破坏

MD5 已经存在：

* 碰撞攻击
* 安全漏洞
* 被公开破解工具支持

在安全标准里：

> MD5 已被明确列为不适合用于密码存储。

---

# 二、真正安全的密码保护目标是什么？

现代密码保护的目标是：

不是“无法破解”，而是：

✅ 让破解成本高到不值得
✅ 即使数据库泄露也无法短时间解出
✅ 单条密码破解耗费巨大资源

所以设计理念变成：

| 传统思路  | 现代思路   |
| ----- | ------ |
| 快速哈希  | 有意减慢   |
| 一次计算  | 多轮迭代   |
| 单线程友好 | GPU不友好 |

---

# 三、安全算法：bcrypt / PBKDF2 / scrypt 的核心优势

它们专门为“密码存储”而设计，而不是通用哈希。

## 核心特性对比

| 特性   | MD5 | bcrypt | PBKDF2 | scrypt |
| ---- | --- | ------ | ------ | ------ |
| 设计目标 | 校验  | 密码     | 密码     | 密码     |
| 抗GPU | ❌   | ✅      | ✅      | ✅      |
| 可调成本 | ❌   | ✅      | ✅      | ✅      |
| 迭代机制 | ❌   | ✅      | ✅      | ✅      |
| 安全级别 | 极低  | 高      | 高      | 很高     |

---

# 四、为什么“慢”反而安全？

以 bcrypt 为例：

bcrypt 有一个 cost 参数，比如 12：

```
cost = 12
实际计算次数 ≈ 2^12 = 4096 次
```

攻击者想破解一个密码：

* 需要执行 4096 次加密
* 每次都很耗 CPU

如果数据库有 100 万用户：

```
100万 * 4096 次 = 40亿次计算
```

成本直接爆炸。

这就是 **指数级提高破解成本**。

---

# 五、你提到的三点，是现代密码系统的核心

我们逐条拆解。

---

## ✅ 1. 使用 bcrypt / PBKDF2 / scrypt

推荐优先级：

```
企业系统推荐：
bcrypt > Argon2 > PBKDF2 > scrypt
```

特点说明：

### bcrypt

* 自动管理 salt
* 自带 cost 参数
* 被广泛验证成熟

### PBKDF2

* 可控迭代次数
* Java 原生支持
* 稳定可靠

### scrypt

* 引入内存消耗机制
* 对 GPU 更不友好

推荐实践：

* Web 系统：bcrypt 或 PBKDF2
* 高安全系统：Argon2

---

## ✅ 2. 每个用户独立 salt

真正安全的结构应该是：

```json
{
  "user_id": 1001,
  "password_hash": "$2a$12$aSdfk93...asdasd",
  "salt": "unique_random_string"
}
```

意义是：

| 情况       | 结果        |
| -------- | --------- |
| 两个用户密码相同 | hash 完全不同 |
| 字典攻击     | 必须逐个用户重新算 |
| 彩虹表      | 全部失效      |

---

## ✅ 3. 增加迭代次数（或成本因子）

这个是安全与性能的平衡点。

建议值：

| 算法     | 推荐值               |
| ------ | ----------------- |
| bcrypt | cost = 10 ~ 14    |
| PBKDF2 | 100,000 ~ 300,000 |
| scrypt | N=16384, r=8, p=1 |

原则：

> 服务器可承受最大延迟但用户无明显感知。

例如：
登录耗时 200~500ms 是完全合理的。

---

# 六、为什么可以防止“反推出明文密码”？

因为这类算法具备：

✅ 单向性（不可逆）
✅ 多轮运算
✅ 随机 salt
✅ 高计算成本

即使攻击者拿到数据库：

* 无法直接解出密码
* 只能暴力猜测
* 每次尝试都非常昂贵

彩虹表攻击直接失效，因为：

```
hash = bcrypt(password + uniqueSalt)
```

每个用户都不同，预计算完全没意义。

---

# 七、推荐 Passport 平台的安全密码结构

推荐结构示例：

```
user_password_table
------------------
user_id
password_hash
salt
algorithm
cost
updated_at
```

登录校验流程：

```
用户输入密码
 → 读取该用户 salt + cost
 → 使用指定算法加密输入密码
 → 与数据库 hash 对比
 → 匹配则通过
```

---

# 八、Java 示例：bcrypt 安全实现

推荐使用 Spring Security：

```java
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(12);

// 注册时
String hash = encoder.encode(password);

// 登录校验
boolean matches = encoder.matches(inputPassword, hash);
```

它已自动：

* 生成 salt
* 处理迭代
* 管理成本参数

无需自己造轮子。

---

# 九、错误示范 vs 正确示范

### ❌ 错误方式

```java
String hash = md5(password + salt);
```

### ✅ 正确方式

```java
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(12);
String hash = encoder.encode(password);
```

---

# 十、总结一句非常重要的话

> MD5 + salt 的安全等级，已经只是“心理安慰级别”。

真正安全的密码存储必须满足：

* 慢哈希算法
* 可调成本
* 每用户独立 salt
* 抗GPU攻击

---

# ✅ 推荐落地方案总结

如果你要构建安全 Passport 平台，我建议：

✔ bcrypt（cost=12）
✔ 独立 salt
✔ 强密码规则
✔ 密码历史限制
✔ 登录失败风控
✔ 密码修改审计


* any list
{:toc}