---
layout: post
title: 加密平台的进阶：为什么每条数据一个 salt 还不够？
date: 2022-02-18 21:01:55 +0800 
categories: [Safe]
tags: [safe, web, in-action, sh]
published: true
---

# chat

# 为什么每条数据一个 salt 还不够？

```
还是不太理解为什么需要 key 轮转？我为每一条记录生成一个唯一的 salt 不行吗？
```

# 为什么 salt 不能替代 key 轮转？

## 一、先给结论（避免绕弯）

> **Salt 解决的是“抗预计算攻击 / 彩虹表问题”，
> Key 轮转解决的是“密钥泄露后的爆炸半径控制问题”。**

它们**不冲突、不替代、也不在同一个维度**。

---

## 二、你提出的方案到底在解决什么问题？

### 你的设想（简化版）

```text
ciphertext = Encrypt(key, plaintext + unique_salt_per_record)
```

或者：

* 每条记录一个随机 salt
* salt 存数据库
* key 固定

### 这个方案**确实能做到什么？**

✅ 防止：

* 相同明文 → 相同密文
* 彩虹表攻击
* 批量离线破解

👉 **这是“数据级安全”**

---

## 三、那它解决不了什么？（关键）

### 场景：Key 泄露了

假设某一天发生以下任何一种情况：

* Key 被日志打出来
* Key 被误提交到 Git
* Key 被内存 dump
* Key 被运维误操作拷走

**问题来了：**

> 拿到 key 的人，
> 是否可以解密你数据库里的所有记录？

答案是：
👉 **可以，salt 完全挡不住。**

### 为什么？

因为：

* salt 是公开的（或可读的）
* salt 不是秘密
* 它只改变输入，不改变“解密能力”

**攻击者只需要：**

```text
Decrypt(key, ciphertext, salt)
```

---

## 四、Key 轮转到底在解决什么问题？

### Key 轮转的目标只有一个：

> **当 Key 泄露时，
> 损失是否可以被“时间和范围”限制住？**

---

### 没有 key 轮转的世界

* Key = K1
* 使用 3 年
* 加密了 1 亿条数据

一旦 K1 泄露：

> **1 亿条，全灭**

salt 完全无能为力。

---

### 有 key 轮转的世界

* K1：2022–2023（已废弃）
* K2：2023–2024（已废弃）
* K3：2024–Now（当前）

如果 K3 泄露：

* 只能解密 **最近一段时间的数据**
* 历史数据仍然安全
* 你可以立刻：

  * 停用 K3
  * 启用 K4

👉 **爆炸半径被“时间切片”**

---

## 五、一个非常关键但常被忽略的点

### salt ≠ secret

### key = secret

安全工程的第一原则：

> **真正需要被轮换的，永远是“秘密”，而不是“随机性”。**

* salt 是随机性
* key 是秘密

**只有秘密需要生命周期管理。**

---

## 六、从“攻击者视角”再看一遍（非常重要）

### 攻击者问的不是：

> “salt 是不是唯一的？”

而是：

> “我一旦拿到 key，我能解多少？”

---

### 对比总结

| 维度       | 每条记录 salt | Key 轮转 |
| -------- | --------- | ------ |
| 防彩虹表     | ✅         | ❌      |
| 防重复密文    | ✅         | ❌      |
| 防 key 泄露 | ❌         | ✅      |
| 控制损失范围   | ❌         | ✅      |
| 合规要求     | ❌         | ✅      |

---

## 七、那是否可以 “salt + 不轮转 key”？

### 理论上可以

### 工程上不可接受

原因只有一句话：

> **你在假设“key 永远不会泄露”。**

在企业级安全中，这是一个**不允许成立的假设**。

---

## 八、一个更贴近现实的比喻

* salt：给每个箱子加一把不同的锁眼结构
* key：真正能打开锁的钥匙

你可以有 1 万种锁眼（salt），
但如果 **同一把钥匙能开所有锁**，
那钥匙一丢，全部失守。

**Key 轮转 = 定期换钥匙**

---

## 九、正确的工程结论（你可以直接用）

> **Salt 是数据安全的“增强器”，
> Key 轮转是组织安全的“止血阀”。**

---

## 十、什么时候“salt 足够”？

只有一种情况：

* 你用的是 **单向哈希（不可逆）**
* 场景是 **密码存储**
* 不需要解密

这就是为什么：

* 密码：salt + hash
* 敏感数据：key + rotation

---

## 十一、总结一句话（非常重要）

> **如果数据是“可解密的”，
> 那就必须假设 Key 会泄露，
> 而 Key 一旦可能泄露，就必须轮转。**


# 参考资料

* any list
{:toc}