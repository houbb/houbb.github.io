---
layout: post
title:  ASM-02-classes
date:  2018-07-20 13:43:31 +0800
categories: [Java]
tags: [java, asm, sh]
published: true
---

# Class

本章介绍如何使用核心ASM API生成和转换已编译的Java类。

它首先介绍了已编译的类，然后提供了许多说明性示例，介绍了相应的ASM接口，组件和生成和转换它们的工具。

在下一章中将介绍方法，注释和泛型的内容。

# Structure

## 概览

编译类的整体结构非常简单。

实际上，与本地编译的应用程序不同，编译的类保留结构信息和源代码中几乎所有的符号。

实际上，一个已编译的类包含：

- 描述修饰符（例如公共或私有），名称，超类，接口和类的注释的部分。

- 此类中每个字段声明一个部分。 

每个部分都描述了字段的修饰符，名称，类型和注释。

- 在该类中声明的每个方法和构造函数一节。 

每个部分都描述了修饰符，名称，返回和参数类型以及方法的注释。 

它还以Java字节码指令序列的形式包含该方法的已编译代码。

## 区别

但是，源类和编译后的类之间存在一些差异：

- 编译的类仅描述一个类，而源文件可以包含多个类。

例如，将描述一个内部类的类的源文件编译为两个类文件：一个用于主类，一个用于主类。
内部阶级。

但是，主类文件包含对其内部类的引用，方法内部定义的内部类包含对以下类的引用：
他们的封闭方法。

- 当然，已编译的类不包含注释，但可以包含可用于将其他信息与这些元素相关联的类，字段，方法和代码属性。 

自从Java 5中引入了可用于相同目的的 annotations 以来，属性几乎变得无用。

- 编译的类不包含package和import section，因此所有类型名称都必须完全限定。

另一个非常重要的结构差异是，已编译的类包含一个常量池部分。

该池是一个包含所有出现在类中的数字，字符串和类型常量的数组。

这些常量仅在常量池部分中定义一次，并在类文件的所有其他部分中由它们的索引引用。

希望ASM隐藏与常量池相关的所有详细信息，因此您不必费心。

图2.1总结了已编译类的整体结构。 

确切的结构在Java虚拟机规范的第4节中进行了描述。

![image](https://user-images.githubusercontent.com/18375710/70206527-ceae8880-1762-11ea-84b0-18e477cabed6.png)

另一个重要的区别是Java类型在编译类和源类中的表示方式有所不同。

下一节将解释它们在编译类中的表示形式。

TODO...


# 拓展学习 

JVM class 文件信息

# 参考文档

[https://asm.ow2.io/asm4-guide.pdf](https://asm.ow2.io/asm4-guide.pdf)

* any list
{:toc}