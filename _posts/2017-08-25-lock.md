---
layout: post
title:  Lock
date:  2017-8-25 11:11:29 +0800
categories: [Java]
tags: [java, lock]
published: true
---

# IBM

> [Java 理论与实践](https://www.ibm.com/developerworks/cn/java/j-jtp/index.html)

[IBM](https://www.ibm.com/developerworks/cn/) 社区的作品看起来不错。对于个人的眼界提升帮助比较大。

本文记录一下学习笔记与心德，便于回顾查阅。

# Volatile

> [聊聊并发（一）深入分析Volatile的实现原理](http://ifeve.com/volatile/)

在多线程并发编程中 synchronized 和 Volatile 都扮演着重要的角色， Volatile **是轻量级的 synchronized**(不会引起线程上下文的切换和调度)，它在多处理器开发中保证了共享变量的**可见性**。
可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。

一、术语表

本表用于查阅，后面的实现原理会使用到。仅供查阅。

| 术语	| 英文单词	| 描述 | 
|:---|:---|:---|
| 共享变量		| | 在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。|
| 内存屏障	    | Memory Barriers	        | 是一组处理器指令，用于实现对内存操作的顺序限制。 | 
| 缓冲行	        | Cache line	            | 缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。 | 
| 原子操作	    | Atomic operations	        | 不可中断的一个或一系列操作。 | 
| 缓存行填充	    | cache line fill	        | 当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3的或所有） | 
| 缓存命中	    | cache hit	                | 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存。| 
| 写命中	        | write hit	                | 当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。| 
| 写缺失	        | write misses the cache	| 一个有效的缓存行被写入到不存在的内存区域。| 

二、底层原理

处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，
如果对声明了 `Volatile` 变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，
如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，
每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，
当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。


# Synchronized

一、术语表

| 术语	| 英文	| 说明 |
|:---|:---|
| CAS	| Compare and Swap	| 比较并设置。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。比较是否和给定的数值一致，如果一致则修改，不一致则不修改。|

二、锁的基础

> [Java SE1.6中的Synchronized](http://ifeve.com/java-synchronized/)

Java 中的每一个对象都可以作为锁。

- 对于同步方法，锁是当前实例对象。

- 对于静态同步方法，锁是当前对象的Class对象。

- 对于同步方法块，锁是 `Synchonized` 括号里配置的对象。

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁存在哪里呢？锁里面会存储什么信息呢？

三、各种锁的对比

锁会依次递增，且不会回退。(为了避免无用的自旋)

| 锁   | 优点  | 缺点  | 适用场景    |
|:---|:----|:----|:----|
| 偏向锁      |  加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距     | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 |   适用于只有一个线程访问同步块场景 |
| 轻量级锁     | 竞争的线程不会阻塞，提高了程序的响应速度                        | 如果始终得不到锁竞争的线程使用自旋会消耗CPU |   追求响应时间。同步块执行速度非常快 |
| 重量级锁     | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢  |  追求吞吐量。同步块执行速度较长 |


# ReentrantLock

> [JDK 5.0 中更灵活、更具可伸缩性的锁定机制](https://www.ibm.com/developerworks/cn/java/j-jtp10264/index.html#artrelatedtopics)


# ConcurrentHashMap

> [深入分析ConcurrentHashMap](http://ifeve.com/concurrenthashmap/)

ConcurrentHashMap 实现在 JDK 1.6/1.7/1.8 中差异较大。

一、术语

| 术语	| 英文	| 解释 |
|:----|:---|:----|
| 哈希算法	|hash algorithm	| 是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值 | 
| 哈希表	| hash table	| 根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址 |

二、线程不安全的 HashMap



* any list
{:toc}












