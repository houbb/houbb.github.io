---
layout: post
title:  Lock
date:  2017-8-25 11:11:29 +0800
categories: [Java]
tags: [java, lock]
published: true
---

# IBM

> [Java 理论与实践](https://www.ibm.com/developerworks/cn/java/j-jtp/index.html)

[IBM](https://www.ibm.com/developerworks/cn/) 社区的作品看起来不错。对于个人的眼界提升帮助比较大。

本文记录一下学习笔记与心德，便于回顾查阅。

# Volatile

> [聊聊并发（一）深入分析Volatile的实现原理](http://ifeve.com/volatile/)

在多线程并发编程中 synchronized 和 Volatile 都扮演着重要的角色， Volatile **是轻量级的 synchronized**(不会引起线程上下文的切换和调度)，它在多处理器开发中保证了共享变量的**可见性**。
可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。

一、术语表

本表用于查阅，后面的实现原理会使用到。仅供查阅。

| 术语	| 英文单词	| 描述 | 
|:---|:---|:---|
| 共享变量		| | 在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。|
| 内存屏障	    | Memory Barriers	        | 是一组处理器指令，用于实现对内存操作的顺序限制。 | 
| 缓冲行	        | Cache line	            | 缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。 | 
| 原子操作	    | Atomic operations	        | 不可中断的一个或一系列操作。 | 
| 缓存行填充	    | cache line fill	        | 当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3的或所有） | 
| 缓存命中	    | cache hit	                | 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存。| 
| 写命中	        | write hit	                | 当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中。| 
| 写缺失	        | write misses the cache	| 一个有效的缓存行被写入到不存在的内存区域。| 

二、底层原理

处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，
如果对声明了 `Volatile` 变量进行写操作，JVM 就会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，
如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，
每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，
当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。




# ReentrantLock

> [JDK 5.0 中更灵活、更具可伸缩性的锁定机制](https://www.ibm.com/developerworks/cn/java/j-jtp10264/index.html#artrelatedtopics)

TBC...

* any list
{:toc}












