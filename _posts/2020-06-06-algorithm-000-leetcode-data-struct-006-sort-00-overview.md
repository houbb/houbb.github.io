---
layout: post
title: leetcode sort 排序-00-整体概览介绍
date:  2020-6-8 15:13:08 +0800
categories: [Algorithm]
tags: [algorithm, sort, sf]
published: true
---

# 排序系列

[sort-00-排序算法汇总](https://houbb.github.io/2016/07/14/sort-00-overview-sort)

[sort-01-bubble sort 冒泡排序算法详解](https://houbb.github.io/2016/07/14/sort-01-bubble-sort)

[sort-02-QuickSort 快速排序到底快在哪里？](https://houbb.github.io/2016/07/14/sort-02-quick-sort)

[sort-03-SelectSort 选择排序算法详解](https://houbb.github.io/2016/07/14/sort-03-select-sort)

[sort-04-heap sort 堆排序算法详解](https://houbb.github.io/2016/07/14/sort-04-heap-sort)

[sort-05-insert sort 插入排序算法详解](https://houbb.github.io/2016/07/14/sort-05-insert-sort)

[sort-06-shell sort 希尔排序算法详解](https://houbb.github.io/2016/07/14/sort-06-shell-sort)

[sort-07-merge sort 归并排序](https://houbb.github.io/2016/07/14/sort-07-merge-sort)

[sort-08-counting sort 计数排序](https://houbb.github.io/2016/07/14/sort-08-counting-sort)

[sort-09-bucket sort 桶排序](https://houbb.github.io/2016/07/14/sort-09-bucket-sort)

[sort-10-bigfile 大文件外部排序](https://houbb.github.io/2016/07/14/sort-10-bigfile-sort)

# 前言

大家好，我是老马。

以前从工程的角度，已经梳理过一次排序算法。

这里从力扣算法的角度，重新梳理一遍。

核心内容包含：

1）常见排序算法介绍

2）背后的核心思想

3）leetcode 经典题目练习+讲解

4）应用场景、优缺点等对比总结

5）工程 sdk 包，这个已经完成。

6) 可视化

# 整体对比

下面是**常见排序算法的完整对比表**，包括：时间复杂度、空间复杂度、是否稳定、优缺点等信息，方便系统地掌握。

---

### 🧱 一、基础排序算法（适合入门）

| 算法                      | 时间复杂度 (平均/最坏) | 空间复杂度 | 稳定性   | 优点           | 缺点               |
| ----------------------- | ------------- | ----- | ----- | ------------ | ---------------- |
| **冒泡排序** Bubble Sort    | O(n²) / O(n²) | O(1)  | ✅ 稳定  | 实现简单，适合教学    | 效率极低，适合数据很小或几乎有序 |
| **选择排序** Selection Sort | O(n²) / O(n²) | O(1)  | ❌ 不稳定 | 交换次数少，结构清晰   | 比冒泡还慢，不能利用已有序性   |
| **插入排序** Insertion Sort | O(n²) / O(n²) | O(1)  | ✅ 稳定  | 适合小规模、部分有序数据 | 大数据量时效率低         |

---

### ⚙️ 二、进阶排序算法（效率更高）

| 算法                  | 时间复杂度 (平均/最坏)           | 空间复杂度         | 稳定性   | 优点              | 缺点                |
| ------------------- | ----------------------- | ------------- | ----- | --------------- | ----------------- |
| **归并排序** Merge Sort | O(n log n) / O(n log n) | O(n)          | ✅ 稳定  | 稳定，时间稳定，适合链表等结构 | 空间消耗大，递归实现复杂      |
| **快速排序** Quick Sort | O(n log n) / O(n²)      | O(log n)（递归栈） | ❌ 不稳定 | 平均快，原地排序，实用性强   | 最坏情况退化为 O(n²)，不稳定 |
| **希尔排序** Shell Sort | 约 O(n¹.³) / O(n²)       | O(1)          | ❌ 不稳定 | 改进插入排序，速度提升大    | 增量序列选择影响性能，难分析    |
| **堆排序** Heap Sort   | O(n log n) / O(n log n) | O(1)          | ❌ 不稳定 | 不使用递归，不需要额外内存   | 实现略复杂，不稳定         |

---

### 🚀 三、线性排序算法（特定场景）

| 算法                     | 时间复杂度 (平均/最坏)       | 空间复杂度    | 稳定性  | 优点             | 缺点              |
| ---------------------- | ------------------- | -------- | ---- | -------------- | --------------- |
| **计数排序** Counting Sort | O(n + k) / O(n + k) | O(k)     | ✅ 稳定 | 非比较排序，适合范围小的整数 | 数据范围大时空间消耗严重    |
| **桶排序** Bucket Sort    | O(n + k) / O(n²)    | O(n + k) | ✅ 稳定 | 适合小数和均匀分布      | 依赖数据分布，桶内排序开销大  |
| **基数排序** Radix Sort    | O(n·k) / O(n·k)     | O(n + k) | ✅ 稳定 | 适合定长整数或字符串，效率高 | 需要额外空间，非比较型，不通用 |

> 注：k 表示值域或位数（如基数或最大整数范围）

---

### 📌 总结推荐（按使用场景）

| 场景          | 推荐算法           |
| ----------- | -------------- |
| 初学者入门       | 冒泡排序、插入排序      |
| 面试常考 + 实用   | 快速排序、归并排序      |
| 数据几乎有序      | 插入排序、冒泡排序（优化版） |
| 大量数据 + 空间充足 | 归并排序、基数排序      |
| 内存紧张        | 快速排序、堆排序（原地排序） |
| 要求稳定        | 插入、冒泡、归并、计数、基数 |
| 特殊整数范围      | 计数排序、桶排序、基数排序  |

# 每种常见排序算法的核心思想

下面是**每种常见排序算法的核心思想**简要总结，帮你快速理解“它到底在干什么”。


### 🧱 一、基础排序（核心是“模拟人工排序过程”）

| 算法                      | 核心思想                                  |
| ----------------------- | ------------------------------------- |
| **冒泡排序** Bubble Sort    | 反复比较**相邻元素**，大的往后交换，让最大元素“像气泡一样”冒到最后。 |
| **选择排序** Selection Sort | 每次从未排序区域中**选择最小值**，放到已排序区的末尾。         |
| **插入排序** Insertion Sort | 类似整理扑克牌，**将当前元素插入到前面已排好序的部分中**合适的位置。  |

---

### ⚙️ 二、进阶排序（核心是“分治、结构控制”）

| 算法                  | 核心思想                                            |
| ------------------- | ----------------------------------------------- |
| **归并排序** Merge Sort | 典型**分治法**：先分成左右两半，分别排序，再把两个有序数组**合并**。          |
| **快速排序** Quick Sort | 也是**分治法**：选一个“基准值”，把比它小的放左边，大的放右边，然后**递归排序两边**。 |
| **希尔排序** Shell Sort | 对插入排序的改进：**先分组进行粗排序**，然后逐步缩小间隔，最后整体插入排序。        |
| **堆排序** Heap Sort   | 利用**堆这种数据结构**，不断取出堆顶最大/最小值，然后重新调整成堆。            |

---

### 🚀 三、线性排序（核心是“用空间换时间”）

| 算法                     | 核心思想                                  |
| ---------------------- | ------------------------------------- |
| **计数排序** Counting Sort | 建一个计数数组记录每个数的出现次数，**然后按顺序还原排序结果**。    |
| **桶排序** Bucket Sort    | 把数据**按范围分到多个桶里**，每个桶内部排序后合并。          |
| **基数排序** Radix Sort    | 按数字的**每一位从低到高**进行多轮排序，常用**计数排序做子步骤**。 |

---

### 🧠 一句话记住它们的核心思想：

| 算法 | 一句话记忆核心            |
| -- | ------------------ |
| 冒泡 | 相邻交换，最大慢慢冒出来       |
| 选择 | 每轮选最小，放到前面         |
| 插入 | 当前值往前插入合适位置        |
| 归并 | 分成两半 → 各自排序 → 合并   |
| 快排 | 选基准 → 分左右 → 递归处理   |
| 希尔 | 分组插排，逐步缩小步长        |
| 堆排 | 构造大/小顶堆，每次取堆顶      |
| 计数 | 统计出现次数，反推出排序       |
| 桶排 | 分桶 → 桶内排 → 合并      |
| 基数 | 按位排（个位→十位…），多轮稳定排序 |


* any list
{:toc}