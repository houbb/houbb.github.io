---
layout: post
title: Redis Learn-23-keyspace notify
date: 2018-12-12 11:35:23 +0800
categories: [Redis]
tags: [redis, cache, sh]
published: true
---

# Redis Keyspace Notifications

IMPORTANT Keyspace notifications is a feature available since 2.8.0

## Feature overview

Keyspace notifications allows clients to subscribe to Pub/Sub channels in order to receive events affecting the Redis data set in some way.

## 可以接受到的信息

Examples of the events that is possible to receive are the following:

All the commands affecting a given key.

All the keys receiving an LPUSH operation.

All the keys expiring in the database 0.

Events are delivered using the normal Pub/Sub layer of Redis, so clients implementing Pub/Sub are able to use this feature without modifications.

## 注意

Because Redis Pub/Sub is fire and forget（阅后即焚的感觉） currently there is no way to use this feature if your application demands（需要） reliable notification of events, that is, if your Pub/Sub client disconnects, and reconnects later, all the events delivered during the time the client was disconnected are lost.

ps: 在客户端挂掉，重启的这段时间，配置是丢失的。这其实是一件很危险的事情。

In the future there are plans to allow for more reliable delivering of events, but probably this will be addressed at a more general level either bringing reliability to Pub/Sub itself, or allowing Lua scripts to intercept Pub/Sub messages to perform operations like pushing the events into a list.

# Type of events

Keyspace notifications are implemented sending two distinct type of events for every operation affecting the Redis data space. 

For instance a DEL operation targeting the key named mykey in database 0 will trigger the delivering of two messages, exactly equivalent to the following two PUBLISH commands:

```
PUBLISH __keyspace@0__:mykey del
PUBLISH __keyevent@0__:del mykey
```

It is easy to see how one channel allows to listen to all the events targeting the key mykey and the other channel allows to obtain information about all the keys that are target of a del operation.

The first kind of event, with keyspace prefix in the channel is called a `Key-space notification`, while the second, with the keyevent prefix, is called a `Key-event notification`.

In the above example a del event was generated for the key mykey. 

What happens is that:

1. The Key-space channel receives as message the name of the event.

2. The Key-event channel receives as message the name of the key.

It is possible to enable only one kind of notification in order to deliver（交付） just the subset of events we are interested in.

# Configuration

By default keyspace events notifications are disabled because while not very sensible the feature uses some CPU power. 

Notifications are enabled using the notify-keyspace-events of redis.conf or via the CONFIG SET.

Setting the parameter to the empty string disables notifications. 

## 配置的指定说明

In order to enable the feature a non-empty string is used, composed of multiple characters, where every character has a special meaning according to the following table:

```
K     Keyspace events, published with __keyspace@<db>__ prefix.
E     Keyevent events, published with __keyevent@<db>__ prefix.
g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
$     String commands
l     List commands
s     Set commands
h     Hash commands
z     Sorted set commands
x     Expired events (events generated every time a key expires)
e     Evicted events (events generated when a key is evicted for maxmemory)
A     Alias for g$lshzxe, so that the "AKE" string means all the events.
```

At least K or E should be present in the string, otherwise no event will be delivered regardless of the rest of the string.

For instance to enable just Key-space events for lists, the configuration parameter must be set to `Kl`, and so forth.

The string `KEA` can be used to enable every possible event.

# Events generated by different commands

Different commands generate different kind of events according to the following list.

```
DEL generates a del event for every deleted key.

RENAME generates two events, a rename_from event for the source key, and a rename_to event for the destination key.

EXPIRE generates an expire event when an expire is set to the key, or an expired event every time a positive timeout set on a key results into the key being deleted (see EXPIRE documentation for more info).

SORT generates a sortstore event when STORE is used to set a new key. If the resulting list is empty, and the STORE option is used, and there was already an existing key with that name, the result is that the key is deleted, so a del event is generated in this condition.

SET and all its variants (SETEX, SETNX,GETSET) generate set events. However SETEX will also generate an expire events.

MSET generates a separated set event for every key.

SETRANGE generates a setrange event.

INCR, DECR, INCRBY, DECRBY commands all generate incrby events.

INCRBYFLOAT generates an incrbyfloat events.

APPEND generates an append event.

LPUSH and LPUSHX generates a single lpush event, even in the variadic case.

RPUSH and RPUSHX generates a single rpush event, even in the variadic case.

RPOP generates an rpop event. Additionally a del event is generated if the key is removed because the last element from the list was popped.

LPOP generates an lpop event. Additionally a del event is generated if the key is removed because the last element from the list was popped.
LINSERT generates an linsert event.

LSET generates an lset event.

LREM generates an lrem event, and additionally a del event if the resulting list is empty and the key is removed.

LTRIM generates an ltrim event, and additionally a del event if the resulting list is empty and the key is removed.

RPOPLPUSH and BRPOPLPUSH generate an rpop event and an lpush event. In both cases the order is guaranteed (the lpush event will always be delivered after the rpop event). Additionally a del event will be generated if the resulting list is zero length and the key is removed.
HSET, HSETNX and HMSET all generate a single hset event.

HINCRBY generates an hincrby event.

HINCRBYFLOAT generates an hincrbyfloat event.

HDEL generates a single hdel event, and an additional del event if the resulting hash is empty and the key is removed.

SADD generates a single sadd event, even in the variadic case.

SREM generates a single srem event, and an additional del event if the resulting set is empty and the key is removed.

SMOVE generates an srem event for the source key, and an sadd event for the destination key.

SPOP generates an spop event, and an additional del event if the resulting set is empty and the key is removed.

SINTERSTORE, SUNIONSTORE, SDIFFSTORE generate sinterstore, sunionostore, sdiffstore events respectively. In the special case the resulting set is empty, and the key where the result is stored already exists, a del event is generated since the key is removed.

ZINCR generates a zincr event.

ZADD generates a single zadd event even when multiple elements are added.

ZREM generates a single zrem event even when multiple elements are deleted. When the resulting sorted set is empty and the key is generated, an additional del event is generated.

ZREMBYSCORE generates a single zrembyscore event. When the resulting sorted set is empty and the key is generated, an additional del event is generated.

ZREMBYRANK generates a single zrembyrank event. When the resulting sorted set is empty and the key is generated, an additional del event is generated.

ZINTERSTORE and ZUNIONSTORE respectively generate zinterstore and zunionstore events. In the special case the resulting sorted set is empty, and the key where the result is stored already exists, a del event is generated since the key is removed.

Every time a key with a time to live associated is removed from the data set because it expired, an expired event is generated.

Every time a key is evicted from the data set in order to free memory as a result of the maxmemory policy, an evicted event is generated.
```

## 注意

IMPORTANT all the commands generate events **only if the target key is really modified**. 

For instance an SREM deleting a non-existing element from a Set will not actually change the value of the key, so no event will be generated.

If in doubt about how events are generated for a given command, the simplest thing to do is to watch yourself:

```
$ redis-cli config set notify-keyspace-events KEA
$ redis-cli --csv psubscribe '__key*__:*'
Reading messages... (press Ctrl-C to quit)
"psubscribe","__key*__:*",1
```

At this point use redis-cli in another terminal to send commands to the Redis server and watch the events generated:

```
"pmessage","__key*__:*","__keyspace@0__:foo","set"
"pmessage","__key*__:*","__keyevent@0__:set","foo"
...
```

# Timing of expired events

Keys with a time to live associated are expired by Redis in two ways:

1. When the key is accessed by a command and is found to be expired.

2. Via a background system that looks for expired keys in background, incrementally, in order to be able to also collect keys that are never accessed.

The expired events are generated when a key is accessed and is found to be expired by one of the above systems, as a result there are no guarantees that the Redis server will be able to generate the expired event at the time the key time to live reaches the value of zero.

If no command targets the key constantly, and there are many keys with a TTL associated, there can be a significant（重大） delay between the time the key time to live drops to zero, and the time the expired event is generated.

Basically expired events are generated when the Redis server deletes the key and not when the time to live theoretically（理论上） reaches the value of zero.

# 参考资料

[Redis Keyspace Notifications](https://redis.io/topics/notifications)

* any list
{:toc}