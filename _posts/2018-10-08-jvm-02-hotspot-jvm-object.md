---
layout: post
title: JVM-02-HotSpot 虚拟机对象探秘
date:  2018-10-08 07:19:52 +0800
categories: [Java]
tags: [sql, java, jdbc, sf]
published: true
---

# 对象的内存布局

在 HotSpot 虚拟机中，对象的内存布局分为以下 3 块区域：

- 对象头（Header）

- 实例数据（Instance Data）

- 对齐填充（Padding）

![对象的内存布局](https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/object-memory-layout.png)

## 对象头

对象头记录了对象在运行过程中所需要使用的一些数据：

- 哈希码

- GC 分代年龄

- 锁状态标志

- 线程持有的锁

- 偏向线程 ID

- 偏向时间戳

对象头可能包含类型指针，通过该指针能确定对象属于哪个类。

如果对象是一个数组，那么对象头还会包括数组长度。

## 实例数据

实例数据部分就是成员变量的值，其中包括父类成员变量和本类成员变量。

## 对齐填充

用于确保对象的总长度为 8 字节的整数倍。

HotSpot VM 的自动内存管理系统要求对象的大小必须是 8 字节的整数倍。

而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。

# 对象的创建过程

## 类加载检查

虚拟机在解析.class文件时，若遇到一条 new 指令，首先它会去检查常量池中是否有这个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。

如果没有，那么必须先执行相应的类加载过程。

## 为新生对象分配内存

对象所需内存的大小在类加载完成后便可完全确定，接下来从堆中划分一块对应大小的内存空间给新的对象。

分配堆中内存有两种方式：

（1）指针碰撞

如果 Java 堆中内存绝对规整（说明采用的是“复制算法”或“标记整理法”），空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式称为“指针碰撞”。

（2）空闲列表

如果 Java 堆中内存并不规整，已使用的内存和空闲内存交错（说明采用的是标记-清除法，有碎片），此时没法简单进行指针碰撞， VM 必须维护一个列表，记录其中哪些内存块空闲可用。

分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。

这种方式称为“空闲列表”。

## 初始化

分配完内存后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。

至此，整个对象的创建过程就完成了。

# 对象的访问方式

所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。

也就是说在建立一个对象时两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。 

那么根据引用存放的地址类型的不同，对象有不同的访问方式。

## 句柄访问方式

堆中需要有一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。

引用类型的变量存放的是该对象的句柄地址（reference）。

访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。

![句柄访问方式](https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/handle-access.jpg)

## 直接指针访问方式

引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。

但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址。

![直接指针访问方式](https://cdn.jsdelivr.net/gh/doocs/jvm@main/images/direct-pointer.jpg)

需要说明的是，HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。

但像上面所说，它需要额外的策略来存储对象在方法区中类信息的地址。

# HotSpot 虚拟机对象的解密

## 对象的创建过程

当虚拟机遇到一条含有new的指令时，会进行一系列对象创建的操作：

1、检查常量池中是否有即将要创建的这个对象所属的类的符号引用；

若常量池中没有这个类的符号引用，说明这个类还没有被定义！抛出ClassNotFoundException；

若常量池中有这个类的符号引用，则进行下一步工作；

2、进而检查这个符号引用所代表的类是否已经被JVM加载；

若该类还没有被加载，就找该类的class文件，并加载进方法区；若该类已经被JVM加载，则准备为对象分配内存；

3、根据方法区中该类的信息确定该类所需的内存大小； 

一个对象所需的内存大小是在这个对象所属类被定义完就能确定的。且一个类所生产的所有对象的内存大小是一样的。

JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小。

4、从堆中划分一块对应大小的内存空间给新的对象； 

分配堆中内存有两种方式：

4.1、指针碰撞 

如果JVM的垃圾收集器采用复制算法或标记-整理算法，那么堆中空闲内存是完整的区域，并且空闲内存和已使用内存之间由一个指针标记。

那么当为一个对象分配内存时，只需移动指针即可。因此，这种在完整空闲区域上通过移动指针来分配内存的方式就叫做“指针碰撞”。

4.2、空闲列表 

如果JVM的垃圾收集器采用标记-清除算法，那么堆中空闲区域和已使用区域交错，因此需要用一张“空闲列表”来记录堆中哪些区域是空闲区域，从而在创建对象的时候根据这张“空闲列表”找到空闲区域，并分配内存。 

综上所述：JVM究竟采用哪种内存分配方法，取决于它使用了何种垃圾收集器。

5、为对象中的成员变量赋上初始值(默认初始化)；

6、设置对象头中的信息；

7、调用对象的构造函数进行初始化 

此时，整个对象的创建过程就完成了。

## 并发处理

在分配的时候，由于创建对象的频率比较高，然而操作的都是同一个堆，肯定是线程不安全的，因此，需要同步处理
 
同步处理的方式有两种:
  
a.采用CAS配上失败重试保证更新操作原子性（个人理解就是，分配完了找一下，看看有哪些更新操作失败了，再重新分配一次）

b.把内存分配的动作按照线程划分在不同空间上进行，即就是每个线程在java堆中预先分配一小块的内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有在TLAB用完并重新分配的时候，才需要重锁定java堆

# 对象的内存模型

一个对象从逻辑角度看，它由成员变量和成员函数构成，从物理角度来看，对象是存储在堆中的一串二进制数，这串二进制数的组织结构如下。

对象在内存中分为三个部分：

- 对象头

- 实例数据

- 对齐补充

## 对象头

对象头中记录了对象在运行过程中所需要使用的一些数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

此外，对象头中可能还包含类型指针。通过该指针能确定这个对象所属哪个类。

此外，如果对象是一个数组，那么对象头中还要包含数组长度。

- HotSpot 虚拟机对象头 Mark Word

HotSpot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。

| 存储内容	                |         标志位   | 状态 |
|:---|:---|:---|
| 对象哈希码、对象分代年龄	        |   01	   |  未锁定 |
| 指向锁记录的指针	            |      00	   | 轻量级锁定 |
| 指向重量级锁的指针	           |       10 | 膨胀（重量级锁定 |
| 空，不需要记录信息	           |       11 | GC标记 |
| 偏向线程ID、偏向时间戳、对象分代年龄	 | 01 |    可偏向 |

## 实例数据

实力数据部分就是成员变量的值，其中包含父类的成员变量和本类的成员变量。

## 对齐补充

用于确保对象的总长度为 8 字节的整数倍。 

HotSpot要求对象的总长度必须是8字节的整数倍。由于对象头一定是8字节的整数倍，但实例数据部分的长度是任意的，因此需要对齐补充字段确保整个对象的总长度为8的整数倍。

# 对象的访问

我们知道，引用类型的变量中存放的是一个地址，那么根据地址类型的不同，对象有不同的访问方式：

## 句柄访问方式 

堆中需要有一块叫做“句柄池”的内存空间，用于存放所有对象的地址和所有对象所属类的类信息。 

引用类型的变量存放的是该对象在句柄池中的地址。

访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址再访问对象。

## 直接指针访问方式 

引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。 

但对象所在的内存空间中需要额外的策略存储对象所属的类信息的地址。

HotSpot采用直接指针方式访问对象，因为它只需一次寻址操作，从而性能比句柄访问方式快一倍。

但它需要额外的策略存储对象在方法区中类信息的地址。


# 参考资料

《深入理解 jvm》

https://doocs.github.io/jvm/#/docs/02-hotspot-jvm-object

* any list
{:toc}