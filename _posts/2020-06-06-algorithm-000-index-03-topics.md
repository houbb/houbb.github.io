---
layout: post
title: 从零开始的数据结构与算法-02-leetcode 算法系统分类
date:  2020-6-8 15:13:08 +0800
categories: [Algorithm]
tags: [algorithm, data-struct, topics, sf]
published: true
---

#



# chat

# 系统分类

**我们要构建一个更完整的「LeetCode 数据结构与算法知识图谱」：**

* ✅ 覆盖 **所有经典算法思想**（排序、分治、扫描线、位运算等）
* ✅ 明确哪些算法和哪些数据结构强相关（比如：树 + DFS、堆 + 贪心）
* ✅ 按照**学习难度** & **适配阶段**循序渐进
* ✅ 易于整理成 **笔记 / Notion / 题单**

---

## 📚 完整版：LeetCode 数据结构与算法系统分类（升级加强版）

---

### 🟢 一、基础数据结构 + 基本操作

| 模块             | 内容          | 关键算法 / 技巧   |
| -------------- | ----------- | ----------- |
| 数组 Array       | 遍历、滑动窗口、双指针、前缀和、差分数组、矩阵 | 双指针、哈希、区间处理 |
| 字符串 String     | 反转、子串、KMP   | 模拟、字符串哈希、滚动哈希    |
| 链表 Linked List | 单/双链表、快慢指针  | 翻转、合并、环检测   |
| 栈 Stack        | 括号匹配、逆波兰表达式 | 单调栈、辅助栈     |
| 队列 Queue       | 普通队列、双端队列   | 滑动窗口最大值     |

哈希：哈希函数、滚动哈希、一致性哈希、bloom-filter

模拟?

枚举？

---

### 🟠 二、树结构 + 遍历算法

| 模块              | 内容            | 技巧       |
| --------------- | ------------- | -------- |
| 二叉树 Binary Tree | 先中后序遍历        | 递归 / 栈模拟 |
| BFS & 层序        | 102. 二叉树层序遍历  | 队列       |
| 树的构造            | 中序+后序重构、序列化   | 分治       |
| 树上DP            | 337. 打家劫舍 III | 后序DP     |

---

### 🟡 三、图结构 + 搜索算法

| 模块             | 内容                              | 技巧    |
| -------------- | ------------------------------- | ----- |
| 图的遍历           | DFS / BFS                       | 递归/队列 |
| 拓扑排序           | 207. 课程表                        | 入度表   |
| 并查集 Union-Find | 547. 省份数量                       | 路径压缩  |
| 最短路径           | Dijkstra / Floyd / Bellman-Ford | 最小堆   |
| 图构造            | 拓扑图、无向图、邻接表                     | 边集建图  |

---

### 🔵 四、常用算法思想（💥全核心模块💥）

| 类型           | 子类                                  | 代表题目/技巧                                                         |
| ------------ | ----------------------------------- | --------------------------------------------------------------- |
| **排序算法**     | - 快速排序<br>- 归并排序<br>- 计数排序<br>- 堆排序 | **88. 合并两个有序数组**<br>**912. 排序数组**<br>**315. 计算右侧小于当前元素（归并+索引）** |
| **分治算法**     | - 归并排序<br>- 最大子数组和<br>- 树构造         | **53. 最大子序和**<br>**241. 为表达式加括号**                               |
| **贪心算法**     | - 区间调度<br>- 加油问题<br>- 跳跃游戏          | **55. 跳跃游戏**<br>**435. 无重叠区间**                                  |
| **回溯算法**     | - 子集 / 排列 / 数独 / N皇后                | **46. 全排列**<br>**51. N皇后**                                      |
| **二分查找**     | - 搜索有序数组<br>- 二分答案                  | **34. 查找区间**<br>**410. 分割数组最大值**                                |
| **扫描线算法**    | - 区间交叉处理                            | **56. 合并区间**<br>**218. 天际线问题**                                  |
| **滑动窗口**     | - 固定 / 动态窗口                         | **76. 最小覆盖子串**<br>**3. 无重复最长子串**                                |
| **前缀和 / 差分** | - 区间统计 / 快速构造数组                     | **560. 和为 K 的子数组**<br>**370. 区间加法**                             |
| **位运算**      | - 异或 / 掩码 / 状态压缩                    | **136. 只出现一次的数字**<br>**268. 缺失数字**                              |
| **数学类**      | - 质数、欧拉函数、快速幂                       | **204. 计数质数**<br>**50. Pow(x, n)**                              |
| **概率算法**     | - 蓄水池抽样、随机算法                        | **382. 链表随机节点**                                                 |



### 核心算法

DP--记忆化

递归

二分

DFS

BFS

回溯

greedy

分治算法：快排序、归并

### 核心技巧

双指针

滑动窗口

位运算

扫描线

哈希函数--滚动哈希

counting 计数



### 🔶 五、动态规划分类

| 类型   | 内容               | 例题                 |
| ---- | ---------------- | ------------------ |
| 一维DP | 斐波那契 / 股票 / 打家劫舍 | 70. 爬楼梯、198. 打家劫舍  |
| 二维DP | 编辑距离 / 公共子序列     | 72. 编辑距离、1143. LCS |
| 区间DP | 括号加法 / 合并石头      | 312. 戳气球           |
| 背包DP | 0/1 背包 / 完全背包    | 416. 分割等和子集        |
| 状态压缩 | 旅行商问题 / 子集 DP    | 847. 访问所有节点最短路径    |

---

### 🟣 六、特殊结构算法（提升段）

| 模块             | 内容            | 技巧             |
| -------------- | ------------- | -------------- |
| **堆（优先队列）**    | TopK、合并多个有序链表 | 小顶堆、快排替代       |
| **字典树 Trie**   | 单词前缀匹配        | 插入/查找字符树       |
| **线段树 / 树状数组** | 区间查询 / 修改     | 307. 区域和更新     |
| **LRU 缓存结构**   | 双向链表 + 哈希表    | 146. LRU Cache |


并查集

Trie

suffix array 后缀数组


## 🎓 建议学习顺序（按阶段）

| 阶段      | 内容              | 建议周期  |
| ------- | --------------- | ----- |
| 🟩 入门阶段 | 数组、字符串、双指针、基础哈希 | 1-2 周 |
| 🟨 基础进阶 | 链表、栈队列、递归、树     | 1-2 周 |
| 🟦 算法精讲 | 二分、回溯、排序、贪心、前缀和 | 2 周   |
| 🟥 算法拔高 | 动态规划、图论、状态压缩    | 2-3 周 |
| 🟪 高阶专题 | 线段树、字典树、拓扑图     | 按需选学  |

---

## ✅ 最终成果可以形成：

* 一个 **算法学习大图谱**（Notion/Obsidian/思维导图）
* 每个分类配对应 **LeetCode 精选题单**
* 搭建自己的 **刷题笔记库或 GitHub 仓库**
* 自己构建的 **错题集 + 模板题集 + 应用题集**



# 结构和算法之间的关系

好的，对LeetCode中的数据结构和算法进行系统分类并遵循循序渐进的学习路径，是一个非常有效的学习方法。

以下是一个全面的分类体系，按照从基础到进阶、从简单到复杂的顺序排列：

**核心原则：**

1.  **先数据结构，后算法：** 理解数据结构是应用算法的基础。
2.  **先基础操作，后复杂应用：** 掌握数据结构的基本操作（增删改查）是解决更复杂问题的前提。
3.  **由浅入深：** 从线性结构到非线性结构，从简单算法到组合算法。
4.  **关联性学习：** 学习数据结构时，同步学习与之密切相关的典型算法。

**系统分类与学习路径：**

## 第一阶段：基础数据结构与算法 (入门)

1.  **数组 (Array) & 字符串 (String)**
    *   **特点：** 连续内存、随机访问高效、大小固定（通常）、插入删除低效（中间）。
    *   **核心操作：** 遍历、索引访问、查找。
    *   **密切关联算法：**
        *   **二分查找 (Binary Search)：** 在**有序数组**中高效查找（基础模板、变种）。
        *   **双指针 (Two Pointers)：** 解决有序数组对、滑动窗口、快慢指针（去重、链表基础）问题。**非常重要！**
        *   **滑动窗口 (Sliding Window)：** 解决子串/子数组问题（固定大小或可变大小）。
        *   **前缀和 (Prefix Sum)：** 快速计算子数组的和（一维、二维）。
        *   **基础排序思想：** 理解选择、冒泡、插入排序的原理（虽然效率低，但帮助理解）。
    *   **学习目标：** 熟练掌握遍历、二分查找、双指针的各种应用场景。

2.  **链表 (Linked List)**
    *   **特点：** 非连续内存、顺序访问、插入删除高效（特定位置）、无随机访问。
    *   **核心操作：** 遍历、插入（头/尾/中）、删除（头/尾/中）、查找（按值/位置）。
    *   **密切关联算法：**
        *   **指针操作：** 熟练操作指针（或引用）是链表题的核心。
        *   **虚拟头节点 (Dummy Node)：** 简化头节点操作（插入/删除）。
        *   **双指针进阶：**
            *   **快慢指针 (Fast & Slow Pointers)：** 找中点、判断环、找环入口。**极其重要！**
            *   **前后指针：** 链表反转、特定节点删除。
        *   **链表反转 (Reverse Linked List)：** 迭代法、递归法。基础中的基础。
        *   **链表合并 (Merge Linked Lists)：** 合并两个有序链表（迭代、递归）。
    *   **学习目标：** 熟练操作指针，掌握快慢指针技巧，能独立完成链表反转和合并。

3.  **基础线性结构：栈 (Stack) & 队列 (Queue)**
    *   **栈 (LIFO)：**
        *   **特点：** 后进先出。
        *   **核心操作：** `push`, `pop`, `peek/top`, `isEmpty`。
        *   **密切关联算法：**
            *   括号匹配、表达式求值（中缀转后缀/后缀计算）、函数调用栈模拟、单调栈（解决“下一个更大元素”类问题）。
    *   **队列 (FIFO)：**
        *   **特点：** 先进先出。
        *   **核心操作：** `enqueue/offer`, `dequeue/poll`, `peek/front`, `isEmpty`。
        *   **密切关联算法：**
            *   BFS基础层序遍历、滑动窗口最大值（双端队列Deque）、任务调度。
    *   **实现：** 常用数组或链表实现。
    *   **学习目标：** 理解LIFO/FIFO特性，掌握经典应用场景（括号匹配、BFS层序基础），了解单调栈和双端队列的用途。

## 第二阶段：核心数据结构与算法 (进阶)

4.  **哈希表 (Hash Table / Map / Set)**
    *   **特点：** 基于键值对、平均O(1)的查找、插入、删除（理想情况下）。
    *   **核心思想：** 哈希函数、冲突解决（链地址法、开放寻址法）。
    *   **密切关联算法：**
        *   **快速查找与去重：** 利用`O(1)`查找特性解决需要频繁检查元素是否存在或计数的问题（两数之和、重复元素检测、频率统计）。
        *   **配合其他数据结构：** 常作为辅助数据结构加速查找过程（如DFS/BFS中的`visited`记录）。
    *   **学习目标：** 理解哈希原理，熟练运用Map和Set解决查找、计数、去重问题。

5.  **树 (Tree) - 基础 (二叉树为主)**
    *   **特点：** 分层结构、非线性。
    *   **核心概念：** 节点、根、叶子、父节点、子节点、兄弟节点、深度、高度、路径。
    *   **二叉树 (Binary Tree)：**
        *   **核心遍历：** **极其重要！**
            *   **深度优先遍历 (DFS)：**
                *   **前序遍历 (Preorder)：** 根 -> 左 -> 右 (常用于复制、序列化)。
                *   **中序遍历 (Inorder)：** 左 -> 根 -> 右 (在**二叉搜索树BST**中产生有序序列)。
                *   **后序遍历 (Postorder)：** 左 -> 右 -> 根 (常用于删除、表达式树计算)。
            *   **广度优先遍历 (BFS) / 层序遍历 (Level Order)：** 按层遍历 (利用队列)。
        *   **递归：** 树的问题天然适合递归解决（定义子树上的操作）。
        *   **二叉搜索树 (Binary Search Tree, BST)：**
            *   **性质：** 左子树所有节点值 < 根节点值 < 右子树所有节点值。
            *   **密切关联算法：**
                *   查找、插入、删除（需处理多种情况）。
                *   利用中序遍历有序性解决相关问题（验证BST、BST第K小元素、恢复BST）。
                *   利用BST性质优化搜索（如范围搜索）。
    *   **学习目标：** 熟练掌握递归思想，深刻理解并能独立实现DFS三种遍历和BFS层序遍历（递归和迭代）。掌握BST的基本性质与操作。

6.  **堆 (Heap) / 优先队列 (Priority Queue)**
    *   **特点：** 一种特殊的完全二叉树，父节点值总 >= 或 <= 子节点值（大顶堆/小顶堆）。优先队列是堆的抽象。
    *   **核心操作：** `insert/push` (O(log n)), `extract-max/pop` (O(log n)), `peek` (O(1))。
    *   **密切关联算法：**
        *   **Top K 问题：** 最大/最小的K个元素（用堆维护）。
        *   **流式数据中位数：** 利用大小顶堆组合。
        *   **Dijkstra算法（单源最短路径）、Prim算法（最小生成树）** 的核心优化数据结构。
    *   **学习目标：** 理解堆的结构和性质，掌握优先队列的API，熟练解决Top K问题。

7.  **递归 (Recursion) & 回溯 (Backtracking)**
    *   **递归：** 函数直接或间接调用自身。**树DFS的基础。**
        *   **核心要素：** 递归终止条件、递归调用、递归返回处理（后序）。
        *   **思维：** 将问题分解为结构相似的子问题。
    *   **回溯：** 一种通过**尝试所有可能性**并**在失败时撤销（回溯）** 来寻找问题解的算法。本质是DFS + 剪枝。
        *   **核心思想：** 选择 -> 递归 -> 撤销选择。
        *   **模板：** 非常结构化。
        *   **密切关联问题：**
            *   排列、组合、子集问题（N皇后、数独、全排列、组合总和）。
            *   图的路径搜索（DFS实现）。
    *   **学习目标：** 深刻理解递归的调用栈和返回过程，掌握回溯法的经典模板并能解决排列组合类问题。

## 第三阶段：高级数据结构与算法 (深入)

8.  **树 (Tree) - 进阶**
    *   **平衡二叉搜索树 (AVL, Red-Black Tree - 了解原理)：** 理解其如何通过旋转保持平衡，保证O(log n)操作。LeetCode中通常直接使用语言库（如`TreeMap`, `TreeSet`）。
    *   **字典树 (Trie / Prefix Tree)：**
        *   **特点：** 专门处理字符串集合的前缀查找。
        *   **核心操作：** 插入单词、搜索单词、搜索前缀。
        *   **密切关联问题：** 单词搜索II（配合DFS）、自动补全、拼写检查。
    *   **线段树 (Segment Tree) & 树状数组 (Fenwick Tree / Binary Indexed Tree)：**
        *   **特点：** 用于高效处理**区间查询**（如区间和、最小值）和**单点/区间更新**。
        *   **应用场景：** 解决频繁查询和更新数组区间信息的问题。
    *   **学习目标：** 理解Trie结构并解决字符串前缀问题。理解线段树/树状数组解决区间问题的思路（能实现或理解模板）。

9.  **图 (Graph)**
    *   **特点：** 由顶点和边构成，表示实体间关系。比树更一般（可有环、可不连通）。
    *   **核心概念：** 顶点、边（有向/无向、权重）、度（入度/出度）、邻接点、连通分量。
    *   **表示方法：** 邻接矩阵、邻接表（常用）。
    *   **密切关联算法：**
        *   **遍历：**
            *   **广度优先搜索 (BFS)：** 利用队列，**最短路径（无权图）**、层级遍历。
            *   **深度优先搜索 (DFS)：** 利用栈（递归或迭代），**连通分量、拓扑排序（有向无环图DAG）、环检测、路径记录**。
        *   **拓扑排序 (Topological Sorting)：** 对有向无环图(DAG)排序，解决任务调度、编译依赖。
        *   **最短路径 (Shortest Path)：**
            *   **Dijkstra算法：** **非负权重图**单源最短路径。**核心数据结构：优先队列（小顶堆）。**
            *   **Bellman-Ford算法：** 可处理负权边（无负权环），单源。
            *   **Floyd-Warshall算法：** 所有顶点对最短路径。
        *   **最小生成树 (Minimum Spanning Tree - MST)：**
            *   **Prim算法：** 从一个顶点开始扩展。**核心数据结构：优先队列（小顶堆）。**
            *   **Kruskal算法：** 按权重从小到大选择边，用**并查集**判断是否形成环。
        *   **并查集 (Union-Find / Disjoint Set Union - DSU)：**
            *   **特点：** 高效处理**不相交集合**的**合并(Union)**与**查找(Find)** 操作。
            *   **核心操作：** `find` (路径压缩), `union` (按秩合并)。
            *   **密切关联问题：** 连通性问题（岛屿数量、朋友圈）、Kruskal算法实现、检测环（无向图）。
    *   **学习目标：** 掌握图的两种表示方法，熟练实现BFS和DFS遍历。掌握拓扑排序、Dijkstra（优先队列优化）、并查集（路径压缩+按秩合并）、基础MST（Prim/Kruskal）的原理和实现。

10. **高级算法**
    *   **动态规划 (Dynamic Programming - DP)：**
        *   **核心思想：** 将复杂问题分解为重叠子问题，记忆化子问题的解（避免重复计算），自底向上或自顶向下（记忆化搜索）求解。
        *   **关键要素：** 状态定义、状态转移方程、初始化、边界条件。
        *   **经典问题：**
            *   线性DP：斐波那契、爬楼梯、最长递增子序列(LIS)、最大子数组和、背包问题(01背包、完全背包)。
            *   区间DP：最长回文子串、石子合并。
            *   树形DP：二叉树中的最大路径和、打家劫舍III。
            *   状态压缩DP：旅行商问题(TSP)简化版。
    *   **贪心算法 (Greedy Algorithm)：**
        *   **核心思想：** 每一步都做出**当前看起来最优**的选择，希望导致全局最优解。
        *   **特点：** 高效，但**需要证明其正确性**（有时困难）。
        *   **经典问题：** 活动选择、区间调度、找零钱（特定面额）、霍夫曼编码、Dijkstra/Prim算法（本质包含贪心）。
    *   **学习目标：** 理解DP的核心思想和解题步骤（状态、转移方程），能解决经典背包、LCS、LIS问题。理解贪心思想并能识别适用场景（需注意证明）。

## 第四阶段：补充与专项 (查漏补缺与优化)

11. **位运算 (Bit Manipulation)**
    *   **核心操作：** AND(`&`), OR(`|`), XOR(`^`), NOT(`~`), 左移(`<<`), 右移(`>>`, `>>>`)。
    *   **常用技巧：** 判断奇偶、交换两数、取反、检查某位、设置/清除/翻转特定位、统计1的个数、判断2的幂、只出现一次的数字（异或）、位掩码。
    *   **学习目标：** 掌握常用位操作技巧，用于空间优化和特定问题（如状态压缩）。

12. **数学与设计**
    *   **数学：** 质数判断/生成、最大公约数/最小公倍数（欧几里得算法）、进制转换、随机数生成、概率、组合数学（排列组合计算）。
    *   **设计：**
        *   **LRU缓存：** 结合哈希表（快速查找）和双向链表（维护顺序）实现。
        *   **LFU缓存：** 比LRU更复杂，需维护频率信息。
        *   **数据结构设计：** 设计支持特定操作的栈/队列/哈希表等（如最小栈、用栈实现队列）。
    *   **学习目标：** 掌握基础数学算法。理解经典系统设计问题（LRU）的实现原理。

13. **高级图论与字符串**
    *   **图：** 网络流（Ford-Fulkerson）、强连通分量（Kosaraju, Tarjan）、欧拉路径/回路。
    *   **字符串：**
        *   **高级匹配：** KMP算法（高效子串查找）、Rabin-Karp（哈希滚动）、Boyer-Moore。
        *   **后缀数组 & 后缀自动机：** 解决复杂字符串问题（最长重复子串、不同子串计数等）。
    *   **学习目标：** 了解更高级的图论和字符串算法（KMP等），解决更复杂的问题。

**总结建议：**

1.  **按顺序学习：** 强烈建议按照上述阶段顺序学习，打好基础再攻坚克难。
2.  **理解优先：** 不要死记硬背代码。深刻理解数据结构的内在原理和算法的核心思想。
3.  **刻意练习：** 每个类别学习后，集中刷该类别对应的经典题目（LeetCode的标签功能很好用）。从Easy开始，逐步过渡到Medium和Hard。
4.  **归纳总结：** 对做过的题目进行分类总结，提炼解题模板和技巧（如回溯模板、双指针类型、DP状态定义套路）。
5.  **重视基础：** 数组、链表、哈希表、栈、队列、树（遍历、BST）、递归、双指针、二分查找是绝对的基础，必须滚瓜烂熟。它们是解决更复杂问题的基石。
6.  **攻克难点：** 动态规划、图论（尤其是Dijkstra、并查集）、回溯是公认的难点，需要投入更多时间和精力去理解和练习。
7.  **利用资源：** LeetCode官方分类、讨论区、优质题解（尤其高赞图解）、经典算法书籍（《算法导论》、《算法4》）、在线教程都是宝贵资源。

这个分类体系涵盖了LeetCode中绝大多数题目涉及的数据结构和算法。

按照这个路径，结合理解、练习和总结，你就能建立起系统的知识框架，逐步提升解决算法问题的能力。

* any list
{:toc}